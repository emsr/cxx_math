// { dg-options "-D__STDCPP_WANT_MATH_SPEC_FUNCS__" }
//
// Copyright (C) 2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING3.  If not see
// <http://www.gnu.org/licenses/>.

//  cyl_neumann
//  Compare against values generated by the GNU Scientific Library.
//  The GSL can be found on the web: http://www.gnu.org/software/gsl/
#include <limits>
#include <cmath>
#if defined(__TEST_DEBUG)
#  include <iostream>
#  define VERIFY(A) \
  if (!(A)) \
    { \
      std::cout << "line " << __LINE__ \
	<< "  max_abs_frac = " << max_abs_frac \
	<< std::endl; \
    }
#else
#  include <testsuite_hooks.h>
#endif
#include "../testcase.h"


// Test data for nu=0.0000000000000000.
testcase_cyl_neumann<double> data001[] = {
  { -0.30851762524903359, 0.0000000000000000, 5.0000000000000000 },
  { 0.055671167283599457, 0.0000000000000000, 10.000000000000000 },
  { 0.20546429603891822, 0.0000000000000000, 15.000000000000000 },
  { 0.062640596809384053, 0.0000000000000000, 20.000000000000000 },
  { -0.12724943226800617, 0.0000000000000000, 25.000000000000000 },
  { -0.11729573168666413, 0.0000000000000000, 30.000000000000000 },
  { 0.045797987195155689, 0.0000000000000000, 35.000000000000000 },
  { 0.12593641705826092, 0.0000000000000000, 40.000000000000000 },
  { 0.027060469763313333, 0.0000000000000000, 45.000000000000000 },
  { -0.098064995470077118, 0.0000000000000000, 50.000000000000000 },
  { -0.077569178730412594, 0.0000000000000000, 55.000000000000000 },
  { 0.047358952209449426, 0.0000000000000000, 60.000000000000000 },
  { 0.097183557740181920, 0.0000000000000000, 65.000000000000000 },
  { 0.0093096664589409992, 0.0000000000000000, 70.000000000000000 },
  { -0.085369047647775656, 0.0000000000000000, 75.000000000000000 },
  { -0.055620339089770016, 0.0000000000000000, 80.000000000000000 },
  { 0.049567884951494251, 0.0000000000000000, 85.000000000000000 },
  { 0.079776475854877751, 0.0000000000000000, 90.000000000000000 },
  { -0.0028230995861232107, 0.0000000000000000, 95.000000000000000 },
  { -0.077244313365083153, 0.0000000000000000, 100.00000000000000 },
};

// Test function for nu=0.0000000000000000.
template<typename Tp>
  void
  test001()
  {
    bool test [[gnu::unused]] = true;
    const Tp eps = std::numeric_limits<Tp>::epsilon();
    Tp max_abs_diff = -Tp(1);
    Tp max_abs_frac = -Tp(1);
    unsigned int num_datum = sizeof(data001)
			   / sizeof(testcase_cyl_neumann<double>);
    for (unsigned int i = 0; i < num_datum; ++i)
      {
	const Tp f = std::cyl_neumann(Tp(data001[i].nu), Tp(data001[i].x));
	const Tp f0 = data001[i].f0;
	const Tp diff = f - f0;
	if (std::abs(diff) > max_abs_diff)
	  max_abs_diff = std::abs(diff);
	if (std::abs(f0) > Tp(10) * eps
	 && std::abs(f) > Tp(10) * eps)
	  {
	    const Tp frac = diff / f0;
	    if (std::abs(frac) > max_abs_frac)
	      max_abs_frac = std::abs(frac);
	  }
      }
    VERIFY(max_abs_frac < Tp(1.0000000000000006e-10));
  }

// Test data for nu=0.33333333333333331.
testcase_cyl_neumann<double> data002[] = {
  { -0.18192321129343850, 0.33333333333333331, 5.0000000000000000 },
  { 0.17020111788268760, 0.33333333333333331, 10.000000000000000 },
  { 0.18540507541540796, 0.33333333333333331, 15.000000000000000 },
  { -0.028777707635715043, 0.33333333333333331, 20.000000000000000 },
  { -0.15829741864944163, 0.33333333333333331, 25.000000000000000 },
  { -0.058645772316705209, 0.33333333333333331, 30.000000000000000 },
  { 0.10294930308870617, 0.33333333333333331, 35.000000000000000 },
  { 0.10547870367098922, 0.33333333333333331, 40.000000000000000 },
  { -0.034334228816010816, 0.33333333333333331, 45.000000000000000 },
  { -0.11283489933031279, 0.33333333333333331, 50.000000000000000 },
  { -0.030007358986895105, 0.33333333333333331, 55.000000000000000 },
  { 0.086699173295718121, 0.33333333333333331, 60.000000000000000 },
  { 0.074875579668878658, 0.33333333333333331, 65.000000000000000 },
  { -0.039323246374552680, 0.33333333333333331, 70.000000000000000 },
  { -0.091263539574475236, 0.33333333333333331, 75.000000000000000 },
  { -0.013358849535984318, 0.33333333333333331, 80.000000000000000 },
  { 0.078373575537830198, 0.33333333333333331, 85.000000000000000 },
  { 0.055812482883955940, 0.33333333333333331, 90.000000000000000 },
  { -0.043310380106990683, 0.33333333333333331, 95.000000000000000 },
  { -0.076900504962136559, 0.33333333333333331, 100.00000000000000 },
};

// Test function for nu=0.33333333333333331.
template<typename Tp>
  void
  test002()
  {
    bool test [[gnu::unused]] = true;
    const Tp eps = std::numeric_limits<Tp>::epsilon();
    Tp max_abs_diff = -Tp(1);
    Tp max_abs_frac = -Tp(1);
    unsigned int num_datum = sizeof(data002)
			   / sizeof(testcase_cyl_neumann<double>);
    for (unsigned int i = 0; i < num_datum; ++i)
      {
	const Tp f = std::cyl_neumann(Tp(data002[i].nu), Tp(data002[i].x));
	const Tp f0 = data002[i].f0;
	const Tp diff = f - f0;
	if (std::abs(diff) > max_abs_diff)
	  max_abs_diff = std::abs(diff);
	if (std::abs(f0) > Tp(10) * eps
	 && std::abs(f) > Tp(10) * eps)
	  {
	    const Tp frac = diff / f0;
	    if (std::abs(frac) > max_abs_frac)
	      max_abs_frac = std::abs(frac);
	  }
      }
    VERIFY(max_abs_frac < Tp(2.5000000000000014e-11));
  }

// Test data for nu=0.50000000000000000.
testcase_cyl_neumann<double> data003[] = {
  { -0.10121770918510846, 0.50000000000000000, 5.0000000000000000 },
  { 0.21170886633139810, 0.50000000000000000, 10.000000000000000 },
  { 0.15650551590730855, 0.50000000000000000, 15.000000000000000 },
  { -0.072806904785061938, 0.50000000000000000, 20.000000000000000 },
  { -0.15817308404205055, 0.50000000000000000, 25.000000000000000 },
  { -0.022470290598831138, 0.50000000000000000, 30.000000000000000 },
  { 0.12187835265849535, 0.50000000000000000, 35.000000000000000 },
  { 0.084138655676395377, 0.50000000000000000, 40.000000000000000 },
  { -0.062482641933003201, 0.50000000000000000, 45.000000000000000 },
  { -0.10888475635053954, 0.50000000000000000, 50.000000000000000 },
  { -0.0023805454010949376, 0.50000000000000000, 55.000000000000000 },
  { 0.098104683735037918, 0.50000000000000000, 60.000000000000000 },
  { 0.055663470218594434, 0.50000000000000000, 65.000000000000000 },
  { -0.060396767883824871, 0.50000000000000000, 70.000000000000000 },
  { -0.084922578922046868, 0.50000000000000000, 75.000000000000000 },
  { 0.0098472271924441284, 0.50000000000000000, 80.000000000000000 },
  { 0.085190643574343625, 0.50000000000000000, 85.000000000000000 },
  { 0.037684970437156268, 0.50000000000000000, 90.000000000000000 },
  { -0.059772904856097500, 0.50000000000000000, 95.000000000000000 },
  { -0.068803091468728109, 0.50000000000000000, 100.00000000000000 },
};

// Test function for nu=0.50000000000000000.
template<typename Tp>
  void
  test003()
  {
    bool test [[gnu::unused]] = true;
    const Tp eps = std::numeric_limits<Tp>::epsilon();
    Tp max_abs_diff = -Tp(1);
    Tp max_abs_frac = -Tp(1);
    unsigned int num_datum = sizeof(data003)
			   / sizeof(testcase_cyl_neumann<double>);
    for (unsigned int i = 0; i < num_datum; ++i)
      {
	const Tp f = std::cyl_neumann(Tp(data003[i].nu), Tp(data003[i].x));
	const Tp f0 = data003[i].f0;
	const Tp diff = f - f0;
	if (std::abs(diff) > max_abs_diff)
	  max_abs_diff = std::abs(diff);
	if (std::abs(f0) > Tp(10) * eps
	 && std::abs(f) > Tp(10) * eps)
	  {
	    const Tp frac = diff / f0;
	    if (std::abs(frac) > max_abs_frac)
	      max_abs_frac = std::abs(frac);
	  }
      }
    VERIFY(max_abs_frac < Tp(5.0000000000000028e-11));
  }

// Test data for nu=0.66666666666666663.
testcase_cyl_neumann<double> data004[] = {
  { -0.016050662643389627, 0.66666666666666663, 5.0000000000000000 },
  { 0.23937232657540733, 0.66666666666666663, 10.000000000000000 },
  { 0.11762106604241235, 0.66666666666666663, 15.000000000000000 },
  { -0.11182254014899558, 0.66666666666666663, 20.000000000000000 },
  { -0.14756582982938804, 0.66666666666666663, 25.000000000000000 },
  { 0.015078692908077713, 0.66666666666666663, 30.000000000000000 },
  { 0.13260911815705795, 0.66666666666666663, 35.000000000000000 },
  { 0.057217565989652698, 0.66666666666666663, 40.000000000000000 },
  { -0.086373755152382006, 0.66666666666666663, 45.000000000000000 },
  { -0.097624139208051616, 0.66666666666666663, 50.000000000000000 },
  { 0.025354902147023392, 0.66666666666666663, 55.000000000000000 },
  { 0.10288136476351206, 0.66666666666666663, 60.000000000000000 },
  { 0.032728379560128203, 0.66666666666666663, 65.000000000000000 },
  { -0.077363672735747818, 0.66666666666666663, 70.000000000000000 },
  { -0.072855870458293961, 0.66666666666666663, 75.000000000000000 },
  { 0.032358106046953543, 0.66666666666666663, 80.000000000000000 },
  { 0.086240651537394228, 0.66666666666666663, 85.000000000000000 },
  { 0.017029601697285190, 0.66666666666666663, 90.000000000000000 },
  { -0.072173520560584681, 0.66666666666666663, 95.000000000000000 },
  { -0.056057339204073887, 0.66666666666666663, 100.00000000000000 },
};

// Test function for nu=0.66666666666666663.
template<typename Tp>
  void
  test004()
  {
    bool test [[gnu::unused]] = true;
    const Tp eps = std::numeric_limits<Tp>::epsilon();
    Tp max_abs_diff = -Tp(1);
    Tp max_abs_frac = -Tp(1);
    unsigned int num_datum = sizeof(data004)
			   / sizeof(testcase_cyl_neumann<double>);
    for (unsigned int i = 0; i < num_datum; ++i)
      {
	const Tp f = std::cyl_neumann(Tp(data004[i].nu), Tp(data004[i].x));
	const Tp f0 = data004[i].f0;
	const Tp diff = f - f0;
	if (std::abs(diff) > max_abs_diff)
	  max_abs_diff = std::abs(diff);
	if (std::abs(f0) > Tp(10) * eps
	 && std::abs(f) > Tp(10) * eps)
	  {
	    const Tp frac = diff / f0;
	    if (std::abs(frac) > max_abs_frac)
	      max_abs_frac = std::abs(frac);
	  }
      }
    VERIFY(max_abs_frac < Tp(2.5000000000000014e-11));
  }

// Test data for nu=1.0000000000000000.
testcase_cyl_neumann<double> data005[] = {
  { 0.14786314339122700, 1.0000000000000000, 5.0000000000000000 },
  { 0.24901542420695386, 1.0000000000000000, 10.000000000000000 },
  { 0.021073628036873522, 1.0000000000000000, 15.000000000000000 },
  { -0.16551161436252115, 1.0000000000000000, 20.000000000000000 },
  { -0.098829964783237412, 1.0000000000000000, 25.000000000000000 },
  { 0.084425570661747135, 1.0000000000000000, 30.000000000000000 },
  { 0.12751273354559009, 1.0000000000000000, 35.000000000000000 },
  { -0.0057935058215497536, 1.0000000000000000, 40.000000000000000 },
  { -0.11552517964639945, 1.0000000000000000, 45.000000000000000 },
  { -0.056795668562014692, 1.0000000000000000, 50.000000000000000 },
  { 0.073846265432577926, 1.0000000000000000, 55.000000000000000 },
  { 0.091869609369866892, 1.0000000000000000, 60.000000000000000 },
  { -0.017940374275377362, 1.0000000000000000, 65.000000000000000 },
  { -0.094844652625716230, 1.0000000000000000, 70.000000000000000 },
  { -0.035213785160580421, 1.0000000000000000, 75.000000000000000 },
  { 0.069395913784588037, 1.0000000000000000, 80.000000000000000 },
  { 0.071233187582749768, 1.0000000000000000, 85.000000000000000 },
  { -0.026187238607768244, 1.0000000000000000, 90.000000000000000 },
  { -0.081827958724501215, 1.0000000000000000, 95.000000000000000 },
  { -0.020372312002759834, 1.0000000000000000, 100.00000000000000 },
};

// Test function for nu=1.0000000000000000.
template<typename Tp>
  void
  test005()
  {
    bool test [[gnu::unused]] = true;
    const Tp eps = std::numeric_limits<Tp>::epsilon();
    Tp max_abs_diff = -Tp(1);
    Tp max_abs_frac = -Tp(1);
    unsigned int num_datum = sizeof(data005)
			   / sizeof(testcase_cyl_neumann<double>);
    for (unsigned int i = 0; i < num_datum; ++i)
      {
	const Tp f = std::cyl_neumann(Tp(data005[i].nu), Tp(data005[i].x));
	const Tp f0 = data005[i].f0;
	const Tp diff = f - f0;
	if (std::abs(diff) > max_abs_diff)
	  max_abs_diff = std::abs(diff);
	if (std::abs(f0) > Tp(10) * eps
	 && std::abs(f) > Tp(10) * eps)
	  {
	    const Tp frac = diff / f0;
	    if (std::abs(frac) > max_abs_frac)
	      max_abs_frac = std::abs(frac);
	  }
      }
    VERIFY(max_abs_frac < Tp(2.5000000000000014e-11));
  }

// Test data for nu=2.0000000000000000.
testcase_cyl_neumann<double> data006[] = {
  { 0.36766288260552438, 2.0000000000000000, 5.0000000000000000 },
  { -0.0058680824422086830, 2.0000000000000000, 10.000000000000000 },
  { -0.20265447896733507, 2.0000000000000000, 15.000000000000000 },
  { -0.079191758245636165, 2.0000000000000000, 20.000000000000000 },
  { 0.11934303508534717, 2.0000000000000000, 25.000000000000000 },
  { 0.12292410306411394, 2.0000000000000000, 30.000000000000000 },
  { -0.038511545278264829, 2.0000000000000000, 35.000000000000000 },
  { -0.12622609234933840, 2.0000000000000000, 40.000000000000000 },
  { -0.032194922192042195, 2.0000000000000000, 45.000000000000000 },
  { 0.095793168727596537, 2.0000000000000000, 50.000000000000000 },
  { 0.080254497473415426, 2.0000000000000000, 55.000000000000000 },
  { -0.044296631897120527, 2.0000000000000000, 60.000000000000000 },
  { -0.097735569256347382, 2.0000000000000000, 65.000000000000000 },
  { -0.012019513676818605, 2.0000000000000000, 70.000000000000000 },
  { 0.084430013376826846, 2.0000000000000000, 75.000000000000000 },
  { 0.057355236934384719, 2.0000000000000000, 80.000000000000000 },
  { -0.047891809949547198, 2.0000000000000000, 85.000000000000000 },
  { -0.080358414490605934, 2.0000000000000000, 90.000000000000000 },
  { 0.0011004057182389746, 2.0000000000000000, 95.000000000000000 },
  { 0.076836867125027963, 2.0000000000000000, 100.00000000000000 },
};

// Test function for nu=2.0000000000000000.
template<typename Tp>
  void
  test006()
  {
    bool test [[gnu::unused]] = true;
    const Tp eps = std::numeric_limits<Tp>::epsilon();
    Tp max_abs_diff = -Tp(1);
    Tp max_abs_frac = -Tp(1);
    unsigned int num_datum = sizeof(data006)
			   / sizeof(testcase_cyl_neumann<double>);
    for (unsigned int i = 0; i < num_datum; ++i)
      {
	const Tp f = std::cyl_neumann(Tp(data006[i].nu), Tp(data006[i].x));
	const Tp f0 = data006[i].f0;
	const Tp diff = f - f0;
	if (std::abs(diff) > max_abs_diff)
	  max_abs_diff = std::abs(diff);
	if (std::abs(f0) > Tp(10) * eps
	 && std::abs(f) > Tp(10) * eps)
	  {
	    const Tp frac = diff / f0;
	    if (std::abs(frac) > max_abs_frac)
	      max_abs_frac = std::abs(frac);
	  }
      }
    VERIFY(max_abs_frac < Tp(2.5000000000000017e-10));
  }

// Test data for nu=5.0000000000000000.
testcase_cyl_neumann<double> data007[] = {
  { -0.45369482249110193, 5.0000000000000000, 5.0000000000000000 },
  { 0.13540304768936234, 5.0000000000000000, 10.000000000000000 },
  { 0.16717271575940015, 5.0000000000000000, 15.000000000000000 },
  { -0.10003576788953220, 5.0000000000000000, 20.000000000000000 },
  { -0.14705799311372267, 5.0000000000000000, 25.000000000000000 },
  { 0.031627359289264301, 5.0000000000000000, 30.000000000000000 },
  { 0.13554781474770028, 5.0000000000000000, 35.000000000000000 },
  { 0.031869448780850247, 5.0000000000000000, 40.000000000000000 },
  { -0.10426932700176872, 5.0000000000000000, 45.000000000000000 },
  { -0.078548413913081594, 5.0000000000000000, 50.000000000000000 },
  { 0.055257033062858375, 5.0000000000000000, 55.000000000000000 },
  { 0.099464632840450887, 5.0000000000000000, 60.000000000000000 },
  { 0.00023860469499595305, 5.0000000000000000, 65.000000000000000 },
  { -0.091861802216406052, 5.0000000000000000, 70.000000000000000 },
  { -0.048383671296970042, 5.0000000000000000, 75.000000000000000 },
  { 0.060293667104896316, 5.0000000000000000, 80.000000000000000 },
  { 0.077506166682733996, 5.0000000000000000, 85.000000000000000 },
  { -0.015338764062239767, 5.0000000000000000, 90.000000000000000 },
  { -0.081531504045514361, 5.0000000000000000, 95.000000000000000 },
  { -0.029480196281661937, 5.0000000000000000, 100.00000000000000 },
};

// Test function for nu=5.0000000000000000.
template<typename Tp>
  void
  test007()
  {
    bool test [[gnu::unused]] = true;
    const Tp eps = std::numeric_limits<Tp>::epsilon();
    Tp max_abs_diff = -Tp(1);
    Tp max_abs_frac = -Tp(1);
    unsigned int num_datum = sizeof(data007)
			   / sizeof(testcase_cyl_neumann<double>);
    for (unsigned int i = 0; i < num_datum; ++i)
      {
	const Tp f = std::cyl_neumann(Tp(data007[i].nu), Tp(data007[i].x));
	const Tp f0 = data007[i].f0;
	const Tp diff = f - f0;
	if (std::abs(diff) > max_abs_diff)
	  max_abs_diff = std::abs(diff);
	if (std::abs(f0) > Tp(10) * eps
	 && std::abs(f) > Tp(10) * eps)
	  {
	    const Tp frac = diff / f0;
	    if (std::abs(frac) > max_abs_frac)
	      max_abs_frac = std::abs(frac);
	  }
      }
    VERIFY(max_abs_frac < Tp(2.5000000000000013e-09));
  }

// Test data for nu=10.000000000000000.
testcase_cyl_neumann<double> data008[] = {
  { -25.129110095610095, 10.000000000000000, 5.0000000000000000 },
  { -0.35981415218340279, 10.000000000000000, 10.000000000000000 },
  { 0.21997141360195577, 10.000000000000000, 15.000000000000000 },
  { -0.043894653515658105, 10.000000000000000, 20.000000000000000 },
  { -0.14871839049980651, 10.000000000000000, 25.000000000000000 },
  { 0.075056702122397012, 10.000000000000000, 30.000000000000000 },
  { 0.12222473135000546, 10.000000000000000, 35.000000000000000 },
  { -0.046723877232677985, 10.000000000000000, 40.000000000000000 },
  { -0.11739339009322181, 10.000000000000000, 45.000000000000000 },
  { 0.0057238971820535930, 10.000000000000000, 50.000000000000000 },
  { 0.10733910125831631, 10.000000000000000, 55.000000000000000 },
  { 0.036290350559545478, 10.000000000000000, 60.000000000000000 },
  { -0.083239127691715667, 10.000000000000000, 65.000000000000000 },
  { -0.069639384138314858, 10.000000000000000, 70.000000000000000 },
  { 0.045798335061325066, 10.000000000000000, 75.000000000000000 },
  { 0.086269195064844456, 10.000000000000000, 80.000000000000000 },
  { -0.0018234674126248740, 10.000000000000000, 85.000000000000000 },
  { -0.082067762371231284, 10.000000000000000, 90.000000000000000 },
  { -0.038798074754578089, 10.000000000000000, 95.000000000000000 },
  { 0.058331574236414913, 10.000000000000000, 100.00000000000000 },
};

// Test function for nu=10.000000000000000.
template<typename Tp>
  void
  test008()
  {
    bool test [[gnu::unused]] = true;
    const Tp eps = std::numeric_limits<Tp>::epsilon();
    Tp max_abs_diff = -Tp(1);
    Tp max_abs_frac = -Tp(1);
    unsigned int num_datum = sizeof(data008)
			   / sizeof(testcase_cyl_neumann<double>);
    for (unsigned int i = 0; i < num_datum; ++i)
      {
	const Tp f = std::cyl_neumann(Tp(data008[i].nu), Tp(data008[i].x));
	const Tp f0 = data008[i].f0;
	const Tp diff = f - f0;
	if (std::abs(diff) > max_abs_diff)
	  max_abs_diff = std::abs(diff);
	if (std::abs(f0) > Tp(10) * eps
	 && std::abs(f) > Tp(10) * eps)
	  {
	    const Tp frac = diff / f0;
	    if (std::abs(frac) > max_abs_frac)
	      max_abs_frac = std::abs(frac);
	  }
      }
    VERIFY(max_abs_frac < Tp(2.5000000000000017e-10));
  }

// Test data for nu=20.000000000000000.
testcase_cyl_neumann<double> data009[] = {
  { -593396529.69143200, 20.000000000000000, 5.0000000000000000 },
  { -1597.4838482696259, 20.000000000000000, 10.000000000000000 },
  { -3.3087330924737621, 20.000000000000000, 15.000000000000000 },
  { -0.28548945860020319, 20.000000000000000, 20.000000000000000 },
  { 0.19804074776289243, 20.000000000000000, 25.000000000000000 },
  { -0.16848153948742683, 20.000000000000000, 30.000000000000000 },
  { 0.10102784152594022, 20.000000000000000, 35.000000000000000 },
  { 0.045161820565805755, 20.000000000000000, 40.000000000000000 },
  { -0.12556489308015448, 20.000000000000000, 45.000000000000000 },
  { 0.016442633948115834, 20.000000000000000, 50.000000000000000 },
  { 0.10853448778255181, 20.000000000000000, 55.000000000000000 },
  { -0.026721408520664701, 20.000000000000000, 60.000000000000000 },
  { -0.098780425256324175, 20.000000000000000, 65.000000000000000 },
  { 0.016201957786018233, 20.000000000000000, 70.000000000000000 },
  { 0.093591198265063721, 20.000000000000000, 75.000000000000000 },
  { 0.0040484400737296200, 20.000000000000000, 80.000000000000000 },
  { -0.086314929459920531, 20.000000000000000, 85.000000000000000 },
  { -0.028274110097231530, 20.000000000000000, 90.000000000000000 },
  { 0.072349520791638741, 20.000000000000000, 95.000000000000000 },
  { 0.051247973076188474, 20.000000000000000, 100.00000000000000 },
};

// Test function for nu=20.000000000000000.
template<typename Tp>
  void
  test009()
  {
    bool test [[gnu::unused]] = true;
    const Tp eps = std::numeric_limits<Tp>::epsilon();
    Tp max_abs_diff = -Tp(1);
    Tp max_abs_frac = -Tp(1);
    unsigned int num_datum = sizeof(data009)
			   / sizeof(testcase_cyl_neumann<double>);
    for (unsigned int i = 0; i < num_datum; ++i)
      {
	const Tp f = std::cyl_neumann(Tp(data009[i].nu), Tp(data009[i].x));
	const Tp f0 = data009[i].f0;
	const Tp diff = f - f0;
	if (std::abs(diff) > max_abs_diff)
	  max_abs_diff = std::abs(diff);
	if (std::abs(f0) > Tp(10) * eps
	 && std::abs(f) > Tp(10) * eps)
	  {
	    const Tp frac = diff / f0;
	    if (std::abs(frac) > max_abs_frac)
	      max_abs_frac = std::abs(frac);
	  }
      }
    VERIFY(max_abs_frac < Tp(1.0000000000000006e-10));
  }

// Test data for nu=50.000000000000000.
testcase_cyl_neumann<double> data010[] = {
  { -2.7888370175838930e+42, 50.000000000000000, 5.0000000000000000 },
  { -3.6410665018007421e+27, 50.000000000000000, 10.000000000000000 },
  { -1.0929732912175415e+19, 50.000000000000000, 15.000000000000000 },
  { -15606426801663.734, 50.000000000000000, 20.000000000000000 },
  { -753573251.44662738, 50.000000000000000, 25.000000000000000 },
  { -386759.32602734759, 50.000000000000000, 30.000000000000000 },
  { -1172.8690492895323, 50.000000000000000, 35.000000000000000 },
  { -15.615608873419944, 50.000000000000000, 40.000000000000000 },
  { -0.87058346204176895, 50.000000000000000, 45.000000000000000 },
  { -0.21031655464397747, 50.000000000000000, 50.000000000000000 },
  { 0.093048240412999389, 50.000000000000000, 55.000000000000000 },
  { 0.0086417699626744754, 50.000000000000000, 60.000000000000000 },
  { -0.025019788459222037, 50.000000000000000, 65.000000000000000 },
  { -0.0014815155191909152, 50.000000000000000, 70.000000000000000 },
  { 0.050335774732164121, 50.000000000000000, 75.000000000000000 },
  { -0.092924250967987232, 50.000000000000000, 80.000000000000000 },
  { 0.087332463030205698, 50.000000000000000, 85.000000000000000 },
  { -0.016164237701651860, 50.000000000000000, 90.000000000000000 },
  { -0.068897613820457934, 50.000000000000000, 95.000000000000000 },
  { 0.076505263944803045, 50.000000000000000, 100.00000000000000 },
};

// Test function for nu=50.000000000000000.
template<typename Tp>
  void
  test010()
  {
    bool test [[gnu::unused]] = true;
    const Tp eps = std::numeric_limits<Tp>::epsilon();
    Tp max_abs_diff = -Tp(1);
    Tp max_abs_frac = -Tp(1);
    unsigned int num_datum = sizeof(data010)
			   / sizeof(testcase_cyl_neumann<double>);
    for (unsigned int i = 0; i < num_datum; ++i)
      {
	const Tp f = std::cyl_neumann(Tp(data010[i].nu), Tp(data010[i].x));
	const Tp f0 = data010[i].f0;
	const Tp diff = f - f0;
	if (std::abs(diff) > max_abs_diff)
	  max_abs_diff = std::abs(diff);
	if (std::abs(f0) > Tp(10) * eps
	 && std::abs(f) > Tp(10) * eps)
	  {
	    const Tp frac = diff / f0;
	    if (std::abs(frac) > max_abs_frac)
	      max_abs_frac = std::abs(frac);
	  }
      }
    VERIFY(max_abs_frac < Tp(2.5000000000000017e-10));
  }

// Test data for nu=100.00000000000000.
testcase_cyl_neumann<double> data011[] = {
  { -5.0848639160196196e+115, 100.00000000000000, 5.0000000000000000 },
  { -4.8491482711800252e+85, 100.00000000000000, 10.000000000000000 },
  { -1.6375955323195320e+68, 100.00000000000000, 15.000000000000000 },
  { -8.2002648144679126e+55, 100.00000000000000, 20.000000000000000 },
  { -2.9712216432562368e+46, 100.00000000000000, 25.000000000000000 },
  { -7.2875284708240751e+38, 100.00000000000000, 30.000000000000000 },
  { -3.4251079902108953e+32, 100.00000000000000, 35.000000000000000 },
  { -1.4552439438101802e+27, 100.00000000000000, 40.000000000000000 },
  { -3.4506612476220073e+22, 100.00000000000000, 45.000000000000000 },
  { -3.2938001882025953e+18, 100.00000000000000, 50.000000000000000 },
  { -1005686182055527.4, 100.00000000000000, 55.000000000000000 },
  { -831892881402.11377, 100.00000000000000, 60.000000000000000 },
  { -1650863778.0598330, 100.00000000000000, 65.000000000000000 },
  { -7192614.1976097794, 100.00000000000000, 70.000000000000000 },
  { -64639.072261231595, 100.00000000000000, 75.000000000000000 },
  { -1152.5905185698466, 100.00000000000000, 80.000000000000000 },
  { -40.250761402101560, 100.00000000000000, 85.000000000000000 },
  { -2.8307771387185459, 100.00000000000000, 90.000000000000000 },
  { -0.45762200495904848, 100.00000000000000, 95.000000000000000 },
  { -0.16692141141757652, 100.00000000000000, 100.00000000000000 },
};

// Test function for nu=100.00000000000000.
template<typename Tp>
  void
  test011()
  {
    bool test [[gnu::unused]] = true;
    const Tp eps = std::numeric_limits<Tp>::epsilon();
    Tp max_abs_diff = -Tp(1);
    Tp max_abs_frac = -Tp(1);
    unsigned int num_datum = sizeof(data011)
			   / sizeof(testcase_cyl_neumann<double>);
    for (unsigned int i = 0; i < num_datum; ++i)
      {
	const Tp f = std::cyl_neumann(Tp(data011[i].nu), Tp(data011[i].x));
	const Tp f0 = data011[i].f0;
	const Tp diff = f - f0;
	if (std::abs(diff) > max_abs_diff)
	  max_abs_diff = std::abs(diff);
	if (std::abs(f0) > Tp(10) * eps
	 && std::abs(f) > Tp(10) * eps)
	  {
	    const Tp frac = diff / f0;
	    if (std::abs(frac) > max_abs_frac)
	      max_abs_frac = std::abs(frac);
	  }
      }
    VERIFY(max_abs_frac < Tp(1.0000000000000006e-11));
  }

int
main()
{
  test001<double>();
  test002<double>();
  test003<double>();
  test004<double>();
  test005<double>();
  test006<double>();
  test007<double>();
  test008<double>();
  test009<double>();
  test010<double>();
  test011<double>();
  return 0;
}
