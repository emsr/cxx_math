#ifndef TESTCASE_TCC
#define TESTCASE_TCC 1

#include <complex>
#include <sstream>
#include <experimental/type_traits>
#include <experimental/string_view>

const std::experimental::string_view boilerplate = 
R"(// { dg-options "-D__STDCPP_WANT_MATH_SPEC_FUNCS__" }
//
// Copyright (C) 2016 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING3.  If not see
// <http://www.gnu.org/licenses/>.
)";

const std::experimental::string_view header = 
R"(//  Compare against values generated by the GNU Scientific Library.
//  The GSL can be found on the web: http://www.gnu.org/software/gsl/
#include <limits>
#include <cmath>
#if defined(__TEST_DEBUG)
#  include <iostream>
#  define VERIFY(A) \
  if (!(A)) \
    { \
      std::cout << "line " << __LINE__ \
	<< "  max_abs_frac = " << max_abs_frac \
	<< std::endl; \
    }
#else
#  include <testsuite_hooks.h>
#endif
#include <specfun_testcase.h>
)";

const std::experimental::string_view riemann_limits = 
R"(// This can take long on simulators, timing out the test.
// { dg-options "-DMAX_ITERATIONS=5" { target simulator } }

#ifndef MAX_ITERATIONS
#define MAX_ITERATIONS (sizeof(data001) / sizeof(testcase_riemann_zeta<double>))
#endif
)";

/**
 * Introspection class to detect if a type is std::complex.
 */
template<typename _Tp>
  struct is_complex : public std::false_type
  { };

/**
 * Introspection class to detect if a type is std::complex.
 */
template<>
  template<typename _Tp>
    struct is_complex<std::complex<_Tp>> : public std::true_type
    { };

/**
 * Introspection type to detect if a type is std::complex.
 */
template<typename _Tp>
  using is_complex_t = typename is_complex<_Tp>::type;

/**
 * Introspection variable template to detect if a type is std::complex.
 */
template<typename _Tp>
  constexpr bool is_complex_v = is_complex<_Tp>::value;

/**
 * A sane operator< for complex numbers.
 */
template<typename _Tp, typename _Up>
  constexpr bool
  operator<(const std::complex<_Tp>& __y, const std::complex<_Up>& __z)
  {
    if (__y.real() < __z.real())
      return true;
    else if (__z.real() < __y.real())
      return false;
    else
      return __y.imag() < __z.imag();
  }

/**
 * A sane operator< for complex numbers.
 */
template<typename _Tp, typename _Up>
  constexpr bool
  operator<(const std::complex<_Tp>& __y, _Up __z)
  {
    if (__y.real() < __z)
      return true;
    else if (__z < __y.real())
      return false;
    else
      return __y.imag() < _Up{};
  }

/**
 * A sane operator< for complex numbers.
 */
template<typename _Tp, typename _Up>
  constexpr bool
  operator<(_Tp __y, const std::complex<_Up>& __z)
  {
    if (__y < __z.real())
      return true;
    else if (__z.real() < __y)
      return false;
    else
      return _Tp{} < __z.imag();
  }

/**
 * A sane operator> for complex numbers.
 */
template<typename _Tp, typename _Up>
  constexpr bool
  operator>(const std::complex<_Tp>& __y, const std::complex<_Up>& __z)
  { return operator<(__z, __y); }

/**
 * A sane operator> for complex numbers.
 */
template<typename _Tp, typename _Up>
  constexpr bool
  operator>(const std::complex<_Tp>& __y, _Up __z)
  { return operator<(__z, __y); }

/**
 * A sane operator> for complex numbers.
 */
template<typename _Tp, typename _Up>
  constexpr bool
  operator>(_Tp __y, const std::complex<_Up>& __z)
  { return operator<(__z, __y); }

/**
 * A sane operator>= for complex numbers.
 */
template<typename _Tp, typename _Up>
  constexpr bool
  operator>=(const std::complex<_Tp>& __y, const std::complex<_Up>& __z)
  { return !operator<(__y, __z); }

/**
 * A sane operator>= for complex numbers.
 */
template<typename _Tp, typename _Up>
  constexpr bool
  operator>=(const std::complex<_Tp>& __y, _Up __z)
  { return !operator<(__y, __z); }

/**
 * A sane operator>= for complex numbers.
 */
template<typename _Tp, typename _Up>
  constexpr bool
  operator>=(_Tp __y, const std::complex<_Up>& __z)
  { return !operator<(__y, __z); }

/**
 * A sane operator<= for complex numbers.
 */
template<typename _Tp, typename _Up>
  constexpr bool
  operator<=(const std::complex<_Tp>& __y, const std::complex<_Up>& __z)
  { return !operator>(__y, __z); }

/**
 * A sane operator<= for complex numbers.
 */
template<typename _Tp, typename _Up>
  constexpr bool
  operator<=(const std::complex<_Tp>& __y, _Up __z)
  { return !operator>(__y, __z); }

/**
 * A sane operator<= for complex numbers.
 */
template<typename _Tp, typename _Up>
  constexpr bool
  operator<=(_Tp __y, const std::complex<_Up>& __z)
  { return !operator>(__y, __z); }

/**
 *  Incremental computation of statistics.
 */
template<typename _Tp>
  struct _Statistics
  {
    _Statistics&
    operator<<(_Tp __diff)
    {
      ++_M_count;
      auto __old_mean = _M_mean;
      _M_mean = (_M_type(__diff) + _M_type(_M_count - 1) * _M_mean) / _M_type(_M_count);
      auto __del_mean = _M_mean - __old_mean;
      auto __del_diff = _M_type(__diff) - _M_mean;
      if (_M_count > 1)
	_M_variance = (_M_type(_M_count - 2) * _M_variance * _M_variance
		    + _M_type(_M_count - 1) * __del_mean * __del_mean
		    + __del_diff * __del_diff) / _M_type(_M_count - 1);
      if (__diff < _M_min)
	_M_min = __diff;
      if (__diff > _M_max)
	_M_max = __diff;

      return *this;
    }

    static constexpr bool _M_is_complex = is_complex_v<_Tp>;

    using _M_type = std::conditional_t<is_complex_v<_Tp>,
				       std::complex<long double>, long double>;

    _Tp
    count() const
    { return _Tp(_M_count); }

    _Tp
    mean() const
    { return _Tp(_M_mean); }

    _Tp
    variance() const
    { return _Tp(_M_variance); }

    _Tp
    std_deviation() const
    { return _Tp(std::sqrt(_M_variance)); }

    _Tp
    min() const
    { return _Tp(_M_min); }

    _Tp
    max() const
    { return _Tp(_M_max); }

    std::size_t _M_count = 0;
    _M_type _M_mean = 0;
    _M_type _M_variance = 0;
    _M_type _M_min = std::numeric_limits<long double>::max();
    _M_type _M_max = std::numeric_limits<long double>::lowest();
  };


/// A class to abstract the scalar data type in a generic way.
template<typename Tp>
  struct __num_traits
  {
    using __value_type = Tp;
  };

template<>
  template<typename Tp>
    struct __num_traits<std::complex<Tp>>
    {
      using __value_type = typename std::complex<Tp>::value_type;
    };

template<typename Tp>
  using __num_traits_t = typename __num_traits<Tp>::__value_type;

template<typename Tp>
  struct type_strings
  {
    static const std::experimental::string_view
    type()
    { return std::experimental::string_view(""); }

    static const std::experimental::string_view
    suffix()
    { return std::experimental::string_view(""); }
  };

template<>
  struct type_strings<float>
  {
    static const std::experimental::string_view
    type()
    { return std::string("float"); }

    static const std::experimental::string_view
    suffix()
    { return std::experimental::string_view("F"); }
  };

template<>
  struct type_strings<double>
  {
    static const std::experimental::string_view
    type()
    { return std::experimental::string_view("double"); }

    static const std::experimental::string_view
    suffix()
    { return std::experimental::string_view(""); }
  };

template<>
  struct type_strings<long double>
  {
    static const std::experimental::string_view
    type()
    { return std::experimental::string_view("long double"); }

    static const std::experimental::string_view
    suffix()
    { return std::experimental::string_view("L"); }
  };

template<>
  struct type_strings<__float128>
  {
    static const std::experimental::string_view
    type()
    { return std::experimental::string_view("__float128"); }

    static const std::experimental::string_view
    suffix()
    { return std::experimental::string_view("Q"); }
  };

// Fuck me.  I'm too stupid to do this right.
template<>
  struct type_strings<std::complex<float>>
  {
    static const std::experimental::string_view
    type()
    { return std::experimental::string_view("std::complex<float>"); }

    static const std::experimental::string_view
    suffix()
    { return std::experimental::string_view(""); }
  };

template<>
  struct type_strings<std::complex<double>>
  {
    static const std::experimental::string_view
    type()
    { return std::experimental::string_view("std::complex<double>"); }

    static const std::experimental::string_view
    suffix()
    { return std::experimental::string_view(""); }
  };

template<>
  struct type_strings<std::complex<long double>>
  {
    static const std::experimental::string_view
    type()
    { return std::experimental::string_view("std::complex<long double>"); }

    static const std::experimental::string_view
    suffix()
    { return std::experimental::string_view(""); }
  };

template<>
  struct type_strings<std::complex<__float128>>
  {
    static const std::experimental::string_view
    type()
    { return std::experimental::string_view("std::complex<__float128>"); }

    static const std::experimental::string_view
    suffix()
    { return std::experimental::string_view(""); }
  };


/**
 * A tool to clamp a number between two values.
 */
template<typename Tp>
  Tp
  clamp(Tp min, Tp max, Tp x)
  {
    if (x < min)
      return min;
    else if (x > max)
      return max;
    else
      return x;
  }


///
///  @brief  Append two testcase vectors.
///
template<typename Tp>
  std::vector<Tp>
  fill_argument(std::vector<Tp>&& arg, std::vector<Tp>&& more)
  {
    std::vector<Tp> ret;
    ret.reserve(arg.size() + more.size());
    ret.insert(ret.end(), arg.begin(), arg.end());
    ret.insert(ret.end(), more.begin(), more.end());
    return ret;
  }

///
///  @brief  Fill an array with evenly spaced values between two limits.
///
template<typename Tp>
  std::vector<Tp>
  fill_argument(const std::pair<Tp,Tp> & range,
		const std::pair<bool,bool> & inclusive,
		unsigned int num_points)
  {
    std::vector<Tp> argument;

    if (num_points == 1)
      {
	argument.push_back(range.first);
	return argument;
      }

    auto delta = (range.second - range.first) / (num_points - 1);
    auto min = std::min(range.first, range.second);
    auto max = std::max(range.first, range.second);
    auto clamp = [min, max](Tp x)
		 -> Tp
		 {
		   if (x < min)
		     return min;
		   else if (x > max)
		     return max;
		   else
		     return x;
		 };
    for (unsigned int i = 0; i < num_points; ++i)
      {
	if (i == 0 && ! inclusive.first)
	  continue;
	if (i == num_points - 1 && ! inclusive.second)
	  continue;

	argument.push_back(clamp(range.first + i * delta));
      }

    return argument;
  }


///
///  @brief  Find a nice round number limit.
///
template<typename Tp>
  Tp
  get_tolerance(Tp delta, Tp min_tol, bool & ok)
  {
    using Val = __num_traits_t<Tp>;

    const auto abs_delta = std::abs(delta);
    //  Make this some number larger because you lose some accuracy writing and reading.
    const auto eps = Tp{10} * std::numeric_limits<Val>::epsilon();
    Tp tol = min_tol;
    while (tol > std::abs(delta)
	&& tol > eps)
      {
	if (Tp(0.5L) * tol > abs_delta
	 && Tp(0.5L) * tol > eps)
	  {
	    if (Tp(0.2L) * tol > abs_delta
	     && Tp(0.2L) * tol > eps)
	      {
		if (Tp(0.1L) * tol > abs_delta
		 && Tp(0.1L) * tol > eps)
		  {
		    tol *= Tp(0.1L);
		  }
		else
		  {
		    tol *= Tp(0.2L);
		    break;
		  }
	      }
	    else
	      {
		tol *= Tp(0.5L);
		break;
	      }
	  }
	else
	  break;
      }
    ok = true;
    if (tol < min_tol && tol <= abs_delta)
      {
	ok = false;
	std::cerr << "**** Error in get_tolerance:"
		  << " abs(delta)=" << abs_delta
		  << " tol=" << tol
		  << '\n';
      }
    if (tol == min_tol && tol < abs_delta)
      {
	ok = false;
	std::cerr << "Note in get_tolerance:"
		  << " delta=" << delta
		  << " tol=" << tol
		  << '\n';
      }

    //  Somehow, we seem to need extra space to get the tests to pass.
    //  TODO: Figure this out.
    return Tp(50.0L) * tol;
  }

//==========================================================================================

/**
 * A class for function arguments.
 */
template<typename Arg>
  class argument
  {

  public:

    argument(const std::string & arg,
	     const std::vector<Arg> & val)
    : name(arg),
      value(val)
    {}

    std::string name;
    std::vector<Arg> value;
    std::vector<Arg> error;

  private:

  };

/**
 * A class for test function - the function to be tested.
 */
template<typename Ret, typename... Arg>
  class test_function
  {

  public:

    test_function(const std::string & name,
		  Ret func(Arg...))
    : funcname(name),
      function(func)
    {}

    std::string funcname;
    Ret (*function)(Arg...);

  private:
  
  };

/**
 * A class for test function - the function to be tested.
 */
template<typename... Arg>
  class mask_function
  {

  public:

    mask_function(bool mfunc(Arg...))
    : mask(mfunc)
    {}

    bool
    operator()(Arg... args)
    { return mask(args...); }

    bool (*mask)(Arg...);
  };

/**
 * A class for baseline function - the function that is a baseline.
 */
template<typename Ret, typename... Arg>
  class baseline_function
  {

  public:

    baseline_function(const std::string & src,
		      const std::string & name,
		      Ret func(Arg...))
    : source(src),
      funcname(name),
      function(func)
    {}

    std::string source;
    std::string funcname;
    Ret (*function)(Arg...);

  private:
  
  };

/**
 * A class for testcases.
 */
template<typename Ret, typename... Arg>
  class testcase
  {

  public:

    testcase(const std::string & structname,
	     test_function<Ret, Arg...> test,
	     baseline_function<Ret, Arg...> base,
	     mask_function<Arg...> mask,
	     argument<Arg>... arg,
	     std::ostream & out)
    : test_structname(structname),
      function1(test.function),
      function2(base.function),
      maskfunction(mask),
      argument(arg)
    {}

    void
    operator()() const
    {
      output << boilerplate << '\n';
      run_poo<Ret, Arg...>();
      output <<  << '\n';
    }

    std::string test_structname;

  private:

    std::ostringstream get_funcall();
    template<typename RetX, typename ArgX1, typename... ArgX>
      void get_funcall_help(std::ostringstream &);
    template<typename RetX, typename ArgX>
      void get_funcall_help(std::ostringstream &);

    template<typename RetX, typename ArgX1, typename... ArgX>
      void
      run_poo();

    template<typename RetX, typename ArgX>
      void
      run_poo();

    unsigned int start_test = 1;
    Ret (*function1)(Arg...);
    Ret (*function2)(Arg...);
    bool (*mask_function)(Arg...);
    std::tuple<argument<Arg>...> argument;
    const std::tuple_size<argument<Arg>...> arity;
  };

template<typename Ret, typename... Arg>
  template<typename RetX, typename ArgX1, typename... ArgX>
    void
    testcase<Ret, Arg...>::run_poo()
    {
      run_poo<RetX, ArgX...>();
    }

template<typename Ret, typename... Arg>
  template<typename RetX, typename ArgX>
    void
    testcase<Ret, Arg...>::run_poo()
    {
      using Val = __num_traits_t<RetX>;

      const int old_prec = output.precision(std::numeric_limits<Val>::max_digits10);
      output.flags(std::ios::showpoint);

      bool riemann_zeta_limits = (funcname == "riemann_zeta");

      std::string templparm;
      if (!std::experimental::is_floating_point_v<ArgX>)
	templparm += "<Tp>";

      if (write_header)
	output << boilerplate << '\n';
      output << "//  " << funcname << '\n' << '\n';
      if (riemann_zeta_limits)
	output << riemann_limits << '\n';
      if (write_header)
	output << header;

      constexpr auto eps = std::numeric_limits<Val>::epsilon();
      constexpr auto inf = std::numeric_limits<Val>::infinity();
      constexpr auto NaN = std::numeric_limits<Val>::quiet_NaN();
      constexpr auto ret_complex = is_complex_v<RetX>;

      std::string numname = type_strings<Val>::type();
      structname = test_structname + '<' + numname + '>';
    }

template<typename Ret, typename... Arg>
  std::ostringstream
  get_funcall()
  {
    std::ostringstream funcall;
    funcall /*<< nsname << "::"*/
	    << funcname << templparm << "(";
    get_funcall_help<Ret, Arg...>();
    return funcall;
  }
  
template<typename Ret, typename... Arg>
  template<typename RetX, typename ArgX1, typename... ArgX>
    void
    get_funcall_help(std::ostringstream & funcall)
    {
      funcall << "data[i]." << arg1 << ", "
	      << get_funcall_help<RetX, ArgX...>();
    }

template<typename Ret, typename... Arg>
  template<typename RetX, typename ArgX>
    void
    get_funcall_help(std::ostringstream & funcall)
    {
      funcall << "data[i]." << arg1 << ");\n";
    }


//==========================================================================================

///
///  @brief  Difference two one-argument functions.
///
template<typename Tp, typename Tp1>
  unsigned int
  maketest(Tp function1(Tp1),
	   Tp function2(Tp1),
	   const std::string & nsname,
	   const std::string & funcname,
	   const std::string & arg1, const std::vector<Tp1> & argument1,
	   const std::string & baseline,
	   std::ostream & output,
	   bool write_header = true, bool write_main = true, unsigned int start_test = 1)
  {
    using Val = __num_traits_t<Tp>;

    const int old_prec = output.precision(std::numeric_limits<Val>::max_digits10);
    output.flags(std::ios::showpoint);

    bool riemann_zeta_limits = (funcname == "riemann_zeta");

    std::string templparm;
    if (!std::experimental::is_floating_point_v<Tp1>)
      templparm += "<Tp>";

    if (write_header)
      output << boilerplate << '\n';
    output << "//  " << funcname << '\n' << '\n';
    if (riemann_zeta_limits)
      output << riemann_limits << '\n';
    if (write_header)
      output << header;

    constexpr auto eps = std::numeric_limits<Val>::epsilon();
    constexpr auto inf = std::numeric_limits<Val>::infinity();
    constexpr auto NaN = std::numeric_limits<Val>::quiet_NaN();
    constexpr auto ret_complex = is_complex_v<Tp>;

    std::string numname = type_strings<Val>::type();

    std::string structname = "testcase_";
    structname += funcname;
    structname += '<' + numname + '>';

    std::vector<std::tuple<Tp, Tp1>> crud;
    _Statistics<Tp> raw_stats;
    _Statistics<decltype(std::abs(Tp{}))> abs_stats;
    auto max_abs_frac = Val{-1};
    auto num_divergences = 0;
    std::tuple<Tp, Tp, Tp1> last_divergence;
    for (unsigned int i = 0; i < argument1.size(); ++i)
      {
	const auto x = argument1[i];

	try
	  {
	    const auto f1 = function1(x);
	    const auto f2 = function2(x);

	    if (std::abs(f1) == inf || std::abs(f2) == inf)
	      {
		++num_divergences;
		last_divergence = std::make_tuple(f1, f2, x);
		if (num_divergences <= 3)
		  output << "//  Divergence at"
			 << " " << arg1 << "=" << x
			 << " f=" << f1
			 << " f_" << baseline << "=" << f2 << '\n';
		continue;
	      }

	    if (std::isnan(std::real(f1)) || std::isnan(std::real(f2)))
	      {
		output << "//  Failure at"
		       << " " << arg1 << "=" << x
		       << " f=" << f1
		       << " f_" << baseline << "=" << f2 << '\n';
		break;
	      }

	    const auto diff = f1 - f2;
	    raw_stats << diff;
	    abs_stats << std::abs(diff);
	    if (std::abs(f2) > Val{10} * eps && std::abs(f1) > Val{10} * eps)
	      {
		const auto frac = diff / f2;
		if (std::abs(frac) > max_abs_frac)
		  max_abs_frac = std::abs(frac);
	      }
	    crud.push_back(std::tuple<Tp, Tp1>(f2, x));
	  }
	catch (...)
	  {
	    continue;
	  }
      }
    if (num_divergences > 0)
      {
	if (num_divergences > 4)
	  output << "//  ...\n";
	output << "//  Divergence at"
	       << " " << arg1 << "=" << std::get<2>(last_divergence)
	       << " f=" << std::get<0>(last_divergence)
	       << " f_" << baseline << "=" << std::get<1>(last_divergence) << '\n';
	num_divergences = 0;
      }

    if (abs_stats.max() >= Val{0} && max_abs_frac >= Val{0})
      {
	bool tol_ok = false;
	const auto min_tol = Val{1.0e-3L};
	const auto frac_toler = get_tolerance(max_abs_frac, min_tol, tol_ok);
	std::string tname;
	if (ret_complex)
	  tname = type_strings<Tp>::type();
	std::ostringstream dataname;
	dataname.fill('0');
	dataname << "data" << std::setw(3) << start_test;
	dataname.fill(' ');
	output << '\n';
	output << "// Test data.\n";
	output << "// max(|f - f_" << baseline << "|): " << abs_stats.max() << '\n';
	output << "// max(|f - f_" << baseline << "| / |f_" << baseline << "|): " << max_abs_frac << '\n';
	output << "// mean(f - f_" << baseline << "): " << raw_stats.mean() << '\n';
	output << "// variance(f - f_" << baseline << "): " << raw_stats.variance() << '\n';
	output << "// stddev(f - f_" << baseline << "): " << raw_stats.std_deviation() << '\n';
	output.fill('0');
	output << "const " << structname << '\n' << dataname.str() << '[' << crud.size() << "] =\n{\n";
	output.fill(' ');
	for (unsigned int i = 0; i < crud.size(); ++i)
	  {
	    output << "  { " << tname << std::get<0>(crud[i]) << type_strings<Tp>::suffix();
	    output << ", " << std::get<1>(crud[i]) << type_strings<Tp>::suffix();
	    output << " },\n";
	  }
	output << "};\n";
	output.fill('0');
	output << "const " << numname << " toler" << std::setw(3) << start_test << " = " << frac_toler << ";\n";
	output.fill(' ');
	++start_test;
      }

    if (write_main)
      {
	std::string structname = "testcase_";
	structname += funcname;
	structname += "<Tp>";

	std::string tname = "Tp";
	if (ret_complex)
	  tname = "std::complex<Tp>";

	output << '\n';
	output << "template<typename Tp, unsigned int Num>\n";
	output.fill('0');
	output << "  void\n";
	output << "  test(const " << structname << " (&data)[Num], Tp toler)\n";
	output.fill(' ');
	output << "  {\n";
	output << "    bool test __attribute__((unused)) = true;\n";
	output << "    const Tp eps = std::numeric_limits<Tp>::epsilon();\n";
	output << "    Tp max_abs_diff = -Tp(1);\n";
	output << "    Tp max_abs_frac = -Tp(1);\n";
	if (riemann_zeta_limits)
	  output << "    unsigned int num_datum = MAX_ITERATIONS;\n";
	else
	  output << "    unsigned int num_datum = Num;\n";
	output << "    for (unsigned int i = 0; i < num_datum; ++i)\n";
	output << "      {\n";
	output << "\tconst " << tname << " f = " << nsname << "::" << funcname << templparm << "(data[i]." << arg1 << ");\n";
	output << "\tconst " << tname << " f0 = data[i].f0;\n";
	output << "\tconst " << tname << " diff = f - f0;\n";
	output << "\tif (std::abs(diff) > max_abs_diff)\n";
	output << "\t  max_abs_diff = std::abs(diff);\n";
	output << "\tif (std::abs(f0) > Tp(10) * eps\n";
	output << "\t && std::abs(f) > Tp(10) * eps)\n";
	output << "\t  {\n";
	output << "\t    const " << tname << " frac = diff / f0;\n";
	output << "\t    if (std::abs(frac) > max_abs_frac)\n";
	output << "\t      max_abs_frac = std::abs(frac);\n";
	output << "\t  }\n";
	output << "      }\n";
	output << "    VERIFY(max_abs_frac < toler);\n";
	output << "  }\n";

	output << '\n';
	output << "int\n";
	output << "main()\n";
	output << "{\n";
	output.fill('0');
	for (unsigned int t = 1; t < start_test; ++t)
	  output << "  test(data" << std::setw(3) << t << ", toler" << std::setw(3) << t << ");\n";
	output.fill(' ');
	output << "  return 0;\n";
	output << "}\n";
      }

    output.flush();

    return start_test;
  }


///
///  @brief  Difference two two-argument functions.
///
template<typename Tp, typename Tp1, typename Tp2>
  unsigned int
  maketest(Tp function1(Tp1,Tp2),
	   Tp function2(Tp1,Tp2),
	   const std::string & nsname,
	   const std::string & funcname,
	   const std::string & arg1, const std::vector<Tp1> & argument1,
	   const std::string & arg2, const std::vector<Tp2> & argument2,
	   const std::string & baseline,
	   std::ostream & output,
	   bool write_header = true, bool write_main = true, unsigned int start_test = 1)
  {
    using Val = __num_traits_t<Tp>;

    const int old_prec = output.precision(std::numeric_limits<Val>::max_digits10);
    output.flags(std::ios::showpoint);

    std::string templparm;
    if (!std::experimental::is_floating_point_v<Tp1>
     && !std::experimental::is_floating_point_v<Tp2>)
      templparm += "<Tp>";

    if (write_header)
      output << boilerplate << '\n';
    output << "//  " << funcname << '\n';
    if (write_header)
      output << header << '\n';

    constexpr auto eps = std::numeric_limits<Val>::epsilon();
    constexpr auto inf = std::numeric_limits<Val>::infinity();
    constexpr auto NaN = std::numeric_limits<Val>::quiet_NaN();
    constexpr auto ret_complex = is_complex_v<Tp>;

    std::string numname = type_strings<Val>::type();

    std::string structname = "testcase_";
    structname += funcname;
    structname += '<' + numname + '>';

    for (unsigned int i = 0; i < argument1.size(); ++i)
      {
	const auto x = argument1[i];

	std::vector<std::tuple<Tp, Tp1, Tp2>> crud;
	_Statistics<Tp> raw_stats;
	_Statistics<decltype(std::abs(Tp{}))> abs_stats;
	auto num_divergences = 0;
	std::tuple<Tp, Tp, Tp1, Tp2> last_divergence;

	auto max_abs_frac = Val{-1};
	for (unsigned int j = 0; j < argument2.size(); ++j)
	  {
	    const auto y = argument2[j];

	    try
	      {
		const auto f1 = function1(x, y);
		const auto f2 = function2(x, y);
		if (std::abs(f1) == inf || std::abs(f2) == inf)
		  {
		    ++num_divergences;
		    last_divergence = std::make_tuple(f1, f2, x, y);
		    if (num_divergences <= 3)
		      output << "//  Divergence at"
			     << " " << arg1 << "=" << x
			     << " " << arg2 << "=" << y
			     << " f=" << f1
			     << " f_" << baseline << "=" << f2 << '\n';
		    continue;
		  }

		if (std::isnan(std::real(f1)) || std::isnan(std::real(f2)))
		  {
		    output << "//  Failure at"
			   << " " << arg1 << "=" << x
			   << " " << arg2 << "=" << y
			   << " f=" << f1
			   << " f_" << baseline << "=" << f2 << '\n';
		    break;
		  }

		const auto diff = f1 - f2;
		raw_stats << diff;
		abs_stats << std::abs(diff);
		if (std::abs(f2) > Val{10} * eps && std::abs(f1) > Val{10} * eps)
		  {
		    const auto frac = diff / f2;
		    if (std::abs(frac) > max_abs_frac)
		      max_abs_frac = std::abs(frac);
		  }
		crud.push_back(std::tuple<Tp, Tp1, Tp2>(f2, x, y));
	      }
	    catch (...)
	      {
		continue;
	      }
	  }
	if (num_divergences > 0)
	  {
	    if (num_divergences > 4)
	      output << "//  ...\n";
	    output << "//  Divergence at"
		   << " " << arg1 << "=" << std::get<2>(last_divergence)
		   << " " << arg2 << "=" << std::get<3>(last_divergence)
		   << " f=" << std::get<0>(last_divergence)
		   << " f_" << baseline << "=" << std::get<1>(last_divergence) << '\n';
	    num_divergences = 0;
	  }

	if (abs_stats.max() >= Val{0} && max_abs_frac >= Val{0})
	  {
	    bool tol_ok = false;
	    const auto min_tol = Val{1.0e-3L};
	    const auto frac_toler = get_tolerance(max_abs_frac, min_tol, tol_ok);
	    std::string tname;
	    if (ret_complex)
	      tname = type_strings<Tp>::type();
	    std::ostringstream dataname;
	    dataname.fill('0');
	    dataname << "data" << std::setw(3) << start_test;
	    dataname.fill(' ');
	    output << '\n';
	    output << "// Test data for " << arg1 << '=' << std::get<1>(crud[0]) << ".\n";
	    output << "// max(|f - f_" << baseline << "|): " << abs_stats.max() << '\n';
	    output << "// max(|f - f_" << baseline << "| / |f_" << baseline << "|): " << max_abs_frac << '\n';
	    output << "// mean(f - f_" << baseline << "): " << raw_stats.mean() << '\n';
	    output << "// variance(f - f_" << baseline << "): " << raw_stats.variance() << '\n';
	    output << "// stddev(f - f_" << baseline << "): " << raw_stats.std_deviation() << '\n';
	    output.fill('0');
	    output << "const " << structname << '\n' << dataname.str() << '[' << crud.size() << "] =\n{\n";
	    output.fill(' ');
	    for (unsigned int j = 0; j < crud.size(); ++j)
	      {
		output << "  { " << tname << std::get<0>(crud[j]) << type_strings<Tp>::suffix();
		output << ", " << std::get<1>(crud[j]) << type_strings<Tp>::suffix();
		output << ", " << std::get<2>(crud[j]) << type_strings<Tp>::suffix();
		output << " },\n";
	      }
	    output << "};\n";
	    output.fill('0');
	    output << "const " << numname << " toler" << std::setw(3) << start_test << " = " << frac_toler << ";\n";
	    output.fill(' ');
	    ++start_test;
	  }
      }

    if (write_main)
      {
	std::string structname = "testcase_";
	structname += funcname;
	structname += "<Tp>";

	std::string tname = "Tp";
	if (ret_complex)
	  tname = "std::complex<Tp>";

	output << '\n';
	output << "template<typename Tp, unsigned int Num>\n";
	output.fill('0');
	output << "  void\n";
	output << "  test(const " << structname << " (&data)[Num], Tp toler)\n";
	output.fill(' ');
	output << "  {\n";
	output << "    bool test __attribute__((unused)) = true;\n";
	output << "    const Tp eps = std::numeric_limits<Tp>::epsilon();\n";
	output << "    Tp max_abs_diff = -Tp(1);\n";
	output << "    Tp max_abs_frac = -Tp(1);\n";
	output << "    unsigned int num_datum = Num;\n";
	output << "    for (unsigned int i = 0; i < num_datum; ++i)\n";
	output << "      {\n";
	output << "\tconst " << tname << " f = " << nsname << "::" << funcname << templparm << '('
	       << "data[i]." << arg1 << ", data[i]." << arg2 << ");\n";
	output << "\tconst " << tname << " f0 = data[i].f0;\n";
	output << "\tconst " << tname << " diff = f - f0;\n";
	output << "\tif (std::abs(diff) > max_abs_diff)\n";
	output << "\t  max_abs_diff = std::abs(diff);\n";
	output << "\tif (std::abs(f0) > Tp(10) * eps\n";
	output << "\t && std::abs(f) > Tp(10) * eps)\n";
	output << "\t  {\n";
	output << "\t    const " << tname << " frac = diff / f0;\n";
	output << "\t    if (std::abs(frac) > max_abs_frac)\n";
	output << "\t      max_abs_frac = std::abs(frac);\n";
	output << "\t  }\n";
	output << "      }\n";
	output << "    VERIFY(max_abs_frac < toler);\n";
	output << "  }\n";
	output << '\n';

	output << "int\n";
	output << "main()\n";
	output << "{\n";
	output.fill('0');
	for (unsigned int t = 1; t < start_test; ++t)
	  output << "  test(data" << std::setw(3) << t << ", toler" << std::setw(3) << t << ");\n";
	output.fill(' ');
	output << "  return 0;\n";
	output << "}\n";
      }

    output.flush();

    return start_test;
  }


///
///  @brief  Difference two three-argument functions.
///
template<typename Tp, typename Tp1, typename Tp2, typename Tp3>
  unsigned int
  maketest(Tp function1(Tp1,Tp2,Tp3),
	   Tp function2(Tp1,Tp2,Tp3),
	   const std::string & nsname,
	   const std::string & funcname,
	   const std::string & arg1, const std::vector<Tp1> & argument1,
	   const std::string & arg2, const std::vector<Tp2> & argument2,
	   const std::string & arg3, const std::vector<Tp3> & argument3,
	   const std::string & baseline,
	   std::ostream & output,
	   bool write_header = true, bool write_main = true, unsigned int start_test = 1)
  {
    using Val = __num_traits_t<Tp>;

    const int old_prec = output.precision(std::numeric_limits<Val>::max_digits10);
    output.flags(std::ios::showpoint);

    std::string templparm;
    if (!std::experimental::is_floating_point_v<Tp1>
     && !std::experimental::is_floating_point_v<Tp2>
     && !std::experimental::is_floating_point_v<Tp3>)
      templparm += "<Tp>";

    if (write_header)
      output << boilerplate << '\n';
    output << "//  " << funcname << '\n';
    if (write_header)
      output << header << '\n';

    constexpr auto eps = std::numeric_limits<Val>::epsilon();
    constexpr auto inf = std::numeric_limits<Val>::infinity();
    constexpr auto NaN = std::numeric_limits<Val>::quiet_NaN();
    constexpr auto ret_complex = is_complex_v<Tp>;

    std::string numname = type_strings<Val>::type();

    std::string structname = "testcase_";
    structname += funcname;
    structname += '<' + numname + '>';

    for (unsigned int i = 0; i < argument1.size(); ++i)
      {
	const auto x = argument1[i];

	for (unsigned int j = 0; j < argument2.size(); ++j)
	  {
	    const auto y = argument2[j];

	    std::vector<std::tuple<Tp, Tp1, Tp2, Tp3>> crud;
	    _Statistics<Tp> raw_stats;
	    _Statistics<decltype(std::abs(Tp{}))> abs_stats;
	    auto num_divergences = 0;
	    std::tuple<Tp, Tp, Tp1, Tp2, Tp3> last_divergence;

	    auto max_abs_frac = Val{-1};
	    for (unsigned int k = 0; k < argument3.size(); ++k)
	      {
		const auto z = argument3[k];

		try
		  {
		    const auto f1 = function1(x, y, z);
		    const auto f2 = function2(x, y, z);
		    if (std::abs(f1) == inf || std::abs(f2) == inf)
		      {
			++num_divergences;
			last_divergence = std::make_tuple(f1, f2, x, y, z);
			if (num_divergences <= 3)
			  output << "//  Divergence at"
				 << " " << arg1 << "=" << x
				 << " " << arg2 << "=" << y
				 << " " << arg3 << "=" << z
				 << " f=" << f1
				 << " f_" << baseline << "=" << f2 << '\n';
			continue;
		      }

		    if (std::isnan(std::real(f1)) || std::isnan(std::real(f2)))
		      {
			output << "//  Failure at"
			       << " " << arg1 << "=" << x
			       << " " << arg2 << "=" << y
			       << " " << arg3 << "=" << z
			       << " f=" << f1
			       << " f_" << baseline << "=" << f2 << '\n';
			break;
		      }

		    const auto diff = f1 - f2;
		    raw_stats << diff;
		    abs_stats << std::abs(diff);
		    if (std::abs(f2) > Val{10} * eps && std::abs(f1) > Val{10} * eps)
		      {
			const auto frac = diff / f2;
			if (std::abs(frac) > max_abs_frac)
			  max_abs_frac = std::abs(frac);
		      }
		    crud.push_back(std::tuple<Tp, Tp1, Tp2, Tp3>(f2, x, y, z));
		  }
		catch (...)
		  {
		    continue;
		  }
	      }
	    if (num_divergences > 0)
	      {
		if (num_divergences > 4)
		  output << "//  ...\n";
		output << "//  Divergence at"
		       << " " << arg1 << "=" << std::get<2>(last_divergence)
		       << " " << arg2 << "=" << std::get<3>(last_divergence)
		       << " " << arg3 << "=" << std::get<4>(last_divergence)
		       << " f=" << std::get<0>(last_divergence)
		       << " f_" << baseline << "=" << std::get<1>(last_divergence) << '\n';
		num_divergences = 0;
	      }

	    if (abs_stats.max() >= Val{0} && max_abs_frac >= Val{0})
	      {
		bool tol_ok = false;
		const auto min_tol = Val{1.0e-3L};
		const auto frac_toler = get_tolerance(max_abs_frac, min_tol, tol_ok);
		std::string tname;
		if (ret_complex)
		  tname = type_strings<Tp>::type();
		std::ostringstream dataname;
		dataname.fill('0');
		dataname << "data" << std::setw(3) << start_test;
		dataname.fill(' ');
		output << '\n';
		output << "// Test data for " << arg1 << '=' << std::get<1>(crud[0]);
		output << ", " << arg2 << '=' << std::get<2>(crud[0]) << ".\n";
		output << "// max(|f - f_" << baseline << "|): " << abs_stats.max() << '\n';
		output << "// max(|f - f_" << baseline << "| / |f_" << baseline << "|): " << max_abs_frac << '\n';
		output << "// mean(f - f_" << baseline << "): " << raw_stats.mean() << '\n';
		output << "// variance(f - f_" << baseline << "): " << raw_stats.variance() << '\n';
		output << "// stddev(f - f_" << baseline << "): " << raw_stats.std_deviation() << '\n';
		output.fill('0');
		output << "const " << structname << '\n' << dataname.str() << '[' << crud.size() << "] =\n{\n";
		output.fill(' ');
		for (unsigned int k = 0; k < crud.size(); ++k)
		  {
		    output << "  { " << tname << std::get<0>(crud[k]) << type_strings<Tp>::suffix();
		    output << ", " << std::get<1>(crud[k]) << type_strings<Tp>::suffix();
		    output << ", " << std::get<2>(crud[k]) << type_strings<Tp>::suffix();
		    output << ", \n";
		    output << "\t  " << std::get<3>(crud[k]) << type_strings<Tp>::suffix();
		    output << " },\n";
		  }
		output << "};\n";
		output.fill('0');
		output << "const " << numname << " toler" << std::setw(3) << start_test << " = " << frac_toler << ";\n";
		output.fill(' ');
		++start_test;
	      }
	  }
      }


    if (write_main)
      {
	std::string structname = "testcase_";
	structname += funcname;
	structname += "<Tp>";

	std::string tname = "Tp";
	if (ret_complex)
	  tname = "std::complex<Tp>";

	output << '\n';
	output << "template<typename Tp, unsigned int Num>\n";
	output.fill('0');
	output << "  void\n";
	output << "  test(const " << structname << " (&data)[Num], Tp toler)\n";
	output.fill(' ');
	output << "  {\n";
	output << "    bool test __attribute__((unused)) = true;\n";
	output << "    const Tp eps = std::numeric_limits<Tp>::epsilon();\n";
	output << "    Tp max_abs_diff = -Tp(1);\n";
	output << "    Tp max_abs_frac = -Tp(1);\n";
	output << "    unsigned int num_datum = Num;\n";
	output << "    for (unsigned int i = 0; i < num_datum; ++i)\n";
	output << "  	 {\n";
	output << "\tconst " << tname << " f = " << nsname << "::" << funcname << templparm << '('
	       << "data[i]." << arg1 << ", data[i]." << arg2 << ",\n";
	output << "\t\t     data[i]." << arg3 << ");\n";
	output << "\tconst " << tname << " f0 = data[i].f0;\n";
	output << "\tconst " << tname << " diff = f - f0;\n";
	output << "\tif (std::abs(diff) > max_abs_diff)\n";
	output << "\t  max_abs_diff = std::abs(diff);\n";
	output << "\tif (std::abs(f0) > Tp(10) * eps\n";
	output << "\t && std::abs(f) > Tp(10) * eps)\n";
	output << "\t  {\n";
	output << "\t    const " << tname << " frac = diff / f0;\n";
	output << "\t    if (std::abs(frac) > max_abs_frac)\n";
	output << "\t      max_abs_frac = std::abs(frac);\n";
	output << "\t  }\n";
	output << "      }\n";
	output << "    VERIFY(max_abs_frac < toler);\n";
	output << "  }\n";

	output << '\n';
	output << "int\n";
	output << "main()\n";
	output << "{\n";
	output.fill('0');
	for (unsigned int t = 1; t < start_test; ++t)
	  output << "  test(data" << std::setw(3) << t << ", toler" << std::setw(3) << t << ");\n";
	output.fill(' ');
	output << "  return 0;\n";
	output << "}\n";
      }

    output.flush();

    return start_test;
  }


///
///  @brief  Difference two four-argument functions.
///
template<typename Tp, typename Tp1, typename Tp2, typename Tp3, typename Tp4>
  unsigned int
  maketest(Tp function1(Tp1,Tp2,Tp3,Tp4),
	   Tp function2(Tp1,Tp2,Tp3,Tp4),
	   const std::string & nsname,
	   const std::string & funcname,
	   const std::string & arg1, const std::vector<Tp1> & argument1,
	   const std::string & arg2, const std::vector<Tp2> & argument2,
	   const std::string & arg3, const std::vector<Tp3> & argument3,
	   const std::string & arg4, const std::vector<Tp4> & argument4,
	   const std::string & baseline,
	   std::ostream & output,
	   bool write_header = true, bool write_main = true, unsigned int start_test = 1)
  {
    using Val = __num_traits_t<Tp>;

    const int old_prec = output.precision(std::numeric_limits<Val>::max_digits10);
    output.flags(std::ios::showpoint);

    std::string templparm;
    if (!std::experimental::is_floating_point_v<Tp1>
     && !std::experimental::is_floating_point_v<Tp2>
     && !std::experimental::is_floating_point_v<Tp3>
     && !std::experimental::is_floating_point_v<Tp4>)
      templparm += "<Tp>";

    if (write_header)
      output << boilerplate << '\n';
    output << "//  " << funcname << '\n';
    if (write_header)
      output << header << '\n';

    constexpr auto eps = std::numeric_limits<Val>::epsilon();
    constexpr auto inf = std::numeric_limits<Val>::infinity();
    constexpr auto NaN = std::numeric_limits<Val>::quiet_NaN();
    constexpr auto ret_complex = is_complex_v<Tp>;

    std::string numname = type_strings<Val>::type();

    std::string structname = "testcase_";
    structname += funcname;
    structname += '<' + numname + '>';

    for (unsigned int i = 0; i < argument1.size(); ++i)
      {
	const auto w = argument1[i];

	for (unsigned int j = 0; j < argument2.size(); ++j)
	  {
	    const auto x = argument2[j];

	    for (unsigned int k = 0; k < argument3.size(); ++k)
	      {
		const auto y = argument3[k];

		std::vector<std::tuple<Tp, Tp1, Tp2, Tp3, Tp4>> crud;
		_Statistics<Tp> raw_stats;
		_Statistics<decltype(std::abs(Tp{}))> abs_stats;
		auto num_divergences = 0;
		std::tuple<Tp, Tp, Tp1, Tp2, Tp3, Tp4> last_divergence;

		auto max_abs_frac = Val{-1};
		for (unsigned int l = 0; l < argument4.size(); ++l)
		  {
		    const auto z = argument4[l];

		    try
		      {
			const auto f1 = function1(w, x, y, z);
			const auto f2 = function2(w, x, y, z);
			if (std::abs(f1) == inf || std::abs(f2) == inf)
			  {
			    ++num_divergences;
			    last_divergence = std::make_tuple(f1, f2, w, x, y, z);
			    if (num_divergences <= 3)
			      output << "//  Divergence at"
				     << " " << arg1 << "=" << w
				     << " " << arg2 << "=" << x
				     << " " << arg3 << "=" << y
				     << " " << arg4 << "=" << z
				     << " f=" << f1
				     << " f_" << baseline << "=" << f2 << '\n';
			    continue;
			  }

			if (std::isnan(std::real(f1)) || std::isnan(std::real(f2)))
			  {
			    output << "//  Failure at"
				   << " " << arg1 << "=" << w
				   << " " << arg1 << "=" << x
				   << " " << arg3 << "=" << y
				   << " " << arg4 << "=" << z
				   << " f=" << f1
				   << " f_" << baseline << "=" << f2 << '\n';
			    break;
			  }

			const auto diff = f1 - f2;
			raw_stats << diff;
			abs_stats << std::abs(diff);
			if (std::abs(f2) > Val{10} * eps && std::abs(f1) > Val{10} * eps)
			  {
			    const auto frac = diff / f2;
			    if (std::abs(frac) > max_abs_frac)
			      max_abs_frac = std::abs(frac);
			  }
			crud.push_back(std::tuple<Tp, Tp1, Tp2, Tp3, Tp4>(f2, w, x, y, z));
		      }
		    catch (...)
		      {
			continue;
		      }
		  }
		if (num_divergences > 0)
		  {
		    if (num_divergences > 4)
		      output << "//  ...\n";
		    output << "//  Divergence at"
			   << " " << arg1 << "=" << std::get<2>(last_divergence)
			   << " " << arg2 << "=" << std::get<3>(last_divergence)
			   << " " << arg3 << "=" << std::get<4>(last_divergence)
			   << " " << arg4 << "=" << std::get<5>(last_divergence)
			   << " f=" << std::get<0>(last_divergence)
			   << " f_" << baseline << "=" << std::get<1>(last_divergence) << '\n';
		    num_divergences = 0;
		  }

		if (abs_stats.max() >= Val{0} && max_abs_frac >= Val{0})
		 {
		    bool tol_ok = false;
		    const auto min_tol = Val{1.0e-3L};
		    const auto frac_toler = get_tolerance(max_abs_frac, min_tol, tol_ok);
		    std::string tname;
		    if (ret_complex)
		      tname = type_strings<Tp>::type();
		    std::ostringstream dataname;
		    dataname.fill('0');
		    dataname << "data" << std::setw(3) << start_test;
		    dataname.fill(' ');
		    output << '\n';
		    output << "// Test data for " << arg1 << '=' << std::get<1>(crud[0]);
		    output << ", " << arg2 << '=' << std::get<2>(crud[0]);
		    output << ", " << arg3 << '=' << std::get<3>(crud[0]) << ".\n";
		    output << "// max(|f - f_" << baseline << "|): " << abs_stats.max() << '\n';
		    output << "// max(|f - f_" << baseline << "| / |f_" << baseline << "|): " << max_abs_frac << '\n';
		    output << "// mean(f - f_" << baseline << "): " << raw_stats.mean() << '\n';
		    output << "// variance(f - f_" << baseline << "): " << raw_stats.variance() << '\n';
		    output << "// stddev(f - f_" << baseline << "): " << raw_stats.std_deviation() << '\n';
		    output.fill('0');
		    output << "const " << structname << '\n' << dataname.str() << '[' << crud.size() << "] =\n{\n";
		    output.fill(' ');
		    for (unsigned int l = 0; l < crud.size(); ++l)
		      {
			output << "  { " << tname << std::get<0>(crud[l]) << type_strings<Tp>::suffix();
			output << ", " << std::get<1>(crud[l]) << type_strings<Tp>::suffix();
			output << ", " << std::get<2>(crud[l]) << type_strings<Tp>::suffix();
			output << ", \n";
			output << "\t  " << std::get<3>(crud[l]) << type_strings<Tp>::suffix();
			output << ", " << std::get<4>(crud[l]) << type_strings<Tp>::suffix();
			output << " },\n";
		      }
		    output << "};\n";
		    output.fill('0');
		    output << "const " << numname << " toler" << std::setw(3) << start_test << " = " << frac_toler << ";\n";
		    output.fill(' ');
		    ++start_test;
		  }
	      }
	  }
      }

    if (write_main)
      {
	std::string structname = "testcase_";
	structname += funcname;
	structname += "<Tp>";

	std::string tname = "Tp";
	if (ret_complex)
	  tname = "std::complex<Tp>";

	output << '\n';
	output << "template<typename Tp, unsigned int Num>\n";
	output.fill('0');
	output << "  void\n";
	output << "  test(const " << structname << " (&data)[Num], Tp toler)\n";
	output.fill(' ');
	output << "  {\n";
	output << "    bool test __attribute__((unused)) = true;\n";
	output << "    const Tp eps = std::numeric_limits<Tp>::epsilon();\n";
	output << "    Tp max_abs_diff = -Tp(1);\n";
	output << "    Tp max_abs_frac = -Tp(1);\n";
	output << "    unsigned int num_datum = Num;\n";
	output << "    for (unsigned int i = 0; i < num_datum; ++i)\n";
	output << "      {\n";
	output << "\tconst " << tname << " f = " << nsname << "::" << funcname << templparm << '('
	       << "data[i]." << arg1 << ", data[i]." << arg2 << ",\n";
	output << "\t\t     data[i]." << arg3 << ", data[i]." << arg4 << ");\n";
	output << "\tconst " << tname << " f0 = data[i].f0;\n";
	output << "\tconst " << tname << " diff = f - f0;\n";
	output << "\tif (std::abs(diff) > max_abs_diff)\n";
	output << "\t  max_abs_diff = std::abs(diff);\n";
	output << "\tif (std::abs(f0) > Tp(10) * eps\n";
	output << "\t && std::abs(f) > Tp(10) * eps)\n";
	output << "\t  {\n";
	output << "\t    const " << tname << " frac = diff / f0;\n";
	output << "\t    if (std::abs(frac) > max_abs_frac)\n";
	output << "\t      max_abs_frac = std::abs(frac);\n";
	output << "\t  }\n";
	output << "      }\n";
	output << "    VERIFY(max_abs_frac < toler);\n";
	output << "  }\n";

	output << '\n';
	output << "int\n";
	output << "main()\n";
	output << "{\n";
	output.fill('0');
	for (unsigned int t = 1; t < start_test; ++t)
	  output << "  test(data" << std::setw(3) << t << ", toler" << std::setw(3) << t << ");\n";
	output.fill(' ');
	output << "  return 0;\n";
	output << "}\n";
      }

    output.flush();

    return start_test;
  }

#endif // TESTCASE_TCC

