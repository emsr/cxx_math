<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
  "http://www.w3.org/TR/REC-html40/transitional.dtd">
<HTML>
<HEAD>
  <TITLE>VecMat - Matrix&lt;T&gt;</TITLE>
  <META HTTP-EQUIV="Content-Type" CONTENT="text/html;charset=iso-8859-1">
  <META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">
  <META NAME="Author" CONTENT="Kevin Dolan">
  <LINK HREF="vecmat.css" REL="stylesheet" TYPE="text/css">
</HEAD>

<BODY>

<H2>3.4. Matrix&lt;T&gt;</H2>

<P>This is a templatized class for viewing data as a matrix. A matrix, in
general, does not have its own data. Instead, it views a block of data in a
certain way. It is therefore possible to have multiple matrices and vectors
that view the same data. Class <CODE>T</CODE> must have a public default
constructor, copy constructor, destructor, and assignment operator. Many of the
operators and member functions will only work for types that behave like
standard numeric types.</P>
 
<H3>3.4.1. Constructors.</H3>

<H4><CODE>Matrix&lt;T&gt;()</CODE></H4>
<P>This constructs an empty matrix.</P>

<H4><CODE>Matrix&lt;T&gt;(size_t n, size_t m)</CODE></H4>
<P>This constructor creates a matrix of <CODE>n</CODE> rows and <CODE>m</CODE>
columns. If <CODE>T</CODE> is a standard numeric type, pointer, or any type
without a constructor, including <CODE>std::complex&lt;T&gt;</CODE>, then the
matrix will be initialized to zero. If not, then the elements are initialized
with a default constructed object. This constructor uses the
<CODE>Zero&lt;T&gt;()</CODE> function to obtain the value to initialize to. Use
of this contructor is therefore equivelent to <CODE>Matrix&lt;T&gt;
x(Zero&lt;T&gt;(), n, m)</CODE>.</P>

<H4><CODE>Matrix&lt;T&gt;(NoInit, size_t n, size_t m)</CODE></H4>
<P>This constructor creates a matrix of <CODE>n</CODE> rows and <CODE>m</CODE>
columns, with each element initialized with the default constructor of class
<CODE>T</CODE>. If class <CODE>T</CODE> has a specialized version of the
<CODE>VMTraits&lt;T&gt;</CODE> structure, with the flag <CODE>is_simple</CODE>
set to <CODE>true</CODE>, then the elements will not be initialized at all.
This flag is set for all the standard numeric types, including
<CODE>std::complex&lt;float&gt;</CODE> and
<CODE>std::complex&lt;double&gt;</CODE>.</P>

<H4><CODE>Matrix&lt;T&gt;(const T&amp; a, size_t n, size_t m)</CODE></H4>
<P>This creates a matrix of <CODE>n</CODE> rows and <CODE>m</CODE> columns,
with each element initialized to the value <CODE>a</CODE>. This initialization
is done through the copy constructor of class <CODE>T</CODE>.</P>

<H4><CODE>Matrix&lt;T&gt;(const T* a, size_t n, size_t m, ptrdiff_t s =
    1)</CODE></H4>
<P>This creates a matrix of <CODE>n</CODE> rows and <CODE>m</CODE> columns from
a C-style array given by the pointer <CODE>a</CODE>. The data is copied in row
major order, and it is up to the user to make sure the array actually has
<CODE>n * m</CODE> elements. Copying is done with the copy constructor of type
<CODE>T</CODE>. The optional parameter <CODE>s</CODE> allows for copying from
arrays with strides other than one.</P>

<H4><CODE>Matrix&lt;T&gt;(const Matrix&lt;T&gt;&amp; rhs)</CODE></H4>
<P>The copy constructor makes a shallow copy of the matrix <CODE>rhs</CODE>.
This means that it views the same data as <CODE>rhs</CODE>, in exactly the same
way. The primary purpose of this constructor is for making permanent versions
of returned temporary matrices, for example:</P>

<DIV CLASS=sc><CODE>
<P>Mat_DP x(4.5, 10, 5), y(2.5, 10, 5);</P>
<P>Mat_DP z(x + y);</P>
</CODE></DIV>

<H4><CODE>Matrix&lt;complex&lt;T&gt; &gt;(const Matrix&lt;T&gt;&amp; re, const
    Matrix&lt;T&gt;&amp; im)</CODE></H4>
<P>This creates a complex matrix from two real matrices. It will only work
properly for the following types: <CODE>float</CODE> and
<CODE>double</CODE>.</P>

<H4><CODE>Matrix&lt;complex&lt;T&gt; &gt;(const Matrix&lt;T&gt;&amp; re, const
    T&amp; im)</CODE></H4>
<P>This creates a complex matrix from a real matrix, and a scalar. It also only
works for the types above.</P>

<H3>3.4.2. Member functions.</H3>

<H4><CODE>Matrix&lt;T&gt;& apply(T (*fn)(T x))</CODE></H4>
<P>This function applies the function <CODE>fn</CODE> to each element of the
matrix it is called for. The function must take one argument of type
<CODE>T</CODE>, and return a value that can be cast to type <CODE>T</CODE>.
This member function returns itself by reference, allowing for cascading.</P>

<H4><CODE>Matrix&lt;T&gt;& apply(T (*fn)(const T&amp; x))</CODE></H4>
<P>This function applies the function fn to each element of the matrix it is
called for. The function must take one argument of type <CODE>T&amp;</CODE>,
and return a value that can be cast to type <CODE>T</CODE>. This member
function returns itself by reference, allowing for cascading.</P>

<H4><CODE>Matrix&lt;T&gt; copy() const</CODE></H4>
<P>This function returns a deep copy of the matrix it is called for. This means
that the returned matrix will be the only object referencing its data, and that
its column stride will be one, and its row stride will be equal to the number
of columns. Copying is done with the copy constructor of type
<CODE>T</CODE>.</P>

<H4><CODE>bool isdeap() const</CODE></H4>
<P>Returns <CODE>true</CODE> if the following criteria are met:</P>
<UL>
  <LI>The matrix must be the only object referencing its data.</LI>
  <LI>The matrix must have a row-stride equal to the number of columns, and a
  column-stride of one.</LI>
  <LI>The matrix must start at the beginning of its data object, and have the
  same total size as the data object.</LI></UL>

<P>If any of these criteria are not met, <CODE>false</CODE> is returned.</P>

<H4><CODE>void makedeep()</CODE></H4>
<P>This function causes a matrix to become a deep copy of itself. It now
references its own data, has a row-stride equal to its number of columns, and a
column-stride of one. Its original data is not changed, although it is
deallocated if the matrix it is called for is the only object referencing it.
If new memory is allocated, then copying is done with the copy constructor of
type <CODE>T</CODE>.</P>

<H4><CODE>void reference(const Matrix&lt;T&gt;&amp; x)</CODE></H4>
<P>This causes the matrix it is called for to become a shallow copy of
<CODE>x</CODE>. This is very useful for setting a matrix to a returned
temporary, for example:</P>

<DIV CLASS=sc><CODE>
<P>Mat_INT x(2, 10, 20), y;</P>
<P>y.reference(x + 2);</P>
</CODE></DIV>

<H4><CODE>void free()</CODE></H4>
<P>This sets the size of the matrix to zero (zero rows and zero columns). If
the matrix is the only object referencing its data, the data is
deallocated.</P>

<H4><CODE>void reshape(size_t n, size_t m)</CODE></H4>
<P>This changes the dimensions of the matrix to <CODE>(n, m)</CODE>. The matrix
no longer views its old data. Instead, it has new data of its own. The new
values are initialized with the <CODE>Zero&lt;T&gt;()</CODE> function, using
the copy constructor of type <CODE>T</CODE>.</P>

<H4><CODE>void resize(size_t n, size_t m)</CODE></H4>
<P>The same as <CODE>reshape()</CODE>, except that the data is copied. If the
matrix is made shorter along either dimension, then the copied data is
truncated. If it is made larger in either of its dimensions, then the new
values will be initialized with the <CODE>Zero&lt;T&gt;()</CODE> function.
Copying is done with the copy constructor of type <CODE>T</CODE>.</P>

<H4><CODE>Matrix submatrix(size_t rb, size_t cb, size_t rn, size_t cn,
    ptrdiff_t rs, ptrdiff_t cs) const</CODE></H4>
<P>This returns a new view of the data that is a submatrix of the current view.
<CODE>(rb, cb)</CODE> is the element that the submatrix should start with,
<CODE>rn</CODE> and <CODE>cn</CODE> are the dimensions of the submatrix, and
<CODE>rs</CODE> and <CODE>cs</CODE> are the number of rows and columns to skip
between rows and columns of the submatrix. Note that <CODE>rs</CODE> and
<CODE>cs</CODE> can be negative. For example, the following views a matrix in
reverse order:</P>

<DIV CLASS=sc><CODE>
<P>Mat_DP x(10, 20);</P>
<P>Mat_DP y = x.submatrix(9, 19, 10, 20, -1, -1);</P>
</CODE></DIV>

<H4><CODE>Matrix&lt;T&gt; real() const</CODE></H4>
<P>This returns the real part of a <CODE>complex&lt;T&gt;</CODE> matrix. Note
that this returns a deep copy. It is not possible to view the real and
imaginary parts of complex matrices as real matrices. This function is only
defined for <CODE>complex&lt;float&gt;</CODE> and
<CODE>complex&lt;double&gt;</CODE>. Attempting to use it with other complex
types, or with non-complex types, will almost certainly result in compiler
errors.</P>

<H4><CODE>Matrix&lt;T&gt; imag() const</CODE></H4>
<P>This returns the imaginary part of a <CODE>complex&lt;T&gt;</CODE> matrix.
The same limitations apply as for <CODE>real()</CODE>.</P>

<H4><CODE>size_t nrows() const</CODE></H4>
<P>This returns the number of rows.</P>

<H4><CODE>size_t ncols() const</CODE></H4>
<P>This returns the number of columns.</P>

<H4><CODE>ptrdiff_t rstride() const</CODE></H4>
<P>This returns the row-stride of the matrix.</P>

<H4><CODE>ptrdiff_t cstride() const</CODE></H4>
<P>This returns the column-stride of the matrix.</P>

<H4><CODE>T* data()</CODE></H4>
<P>This returns a pointer to the beginning of the matrix's data. It is up to
the user to keep track of the row and column stride.</P>

<H4><CODE>const T* data() const</CODE></H4>
<P>The constant version of this member function returns a constant pointer.</P>

<H4><CODE>Matrix&lt;T&gt; transpose() const</CODE></H4>
<P>This returns a view of the transpose of the matrix.</P>

<H4><CODE>Vector&lt;T&gt; row(size_t i) const</CODE></H4>
<P>This creates a vector view of the <CODE>i</CODE>th row of the matrix.</P>

<H4><CODE>Vector&lt;T&gt; column(size_t j) const</CODE></H4>
<P>This creates a vector view of the <CODE>j</CODE>th column of the matrix.</P>

<H4><CODE>Vector&lt;T&gt; unwrap() const</CODE></H4>
<P>This takes a matrix that is in contiguous order, and creates a vector view.
This vector will view the matrix such that
<CODE>V[i*M.ncols()+j] = M(i, j)</CODE>. This requires that <CODE>M.rstride()
== M.cstride() * M.ncols()</CODE>.</P>

<H4><CODE>Vector&lt;T&gt;::iterator rbegin(size_t i)</CODE></H4>
<P>This returns an iterator to the beginning of row <CODE>i</CODE> of the
matrix.</P>

<H4><CODE>Vector&lt;T&gt;::iterator rend(size_t i)</CODE></H4>
<P>This returns an iterator to the end of row <CODE>i</CODE> of the matrix.</P>

<H4><CODE>Vector&lt;T&gt;::iterator cbegin(size_t j)</CODE></H4>
<P>This returns an iterator to the beginning of column <CODE>j</CODE> of the
matrix.</P>

<H4><CODE>Vector&lt;T&gt;::iterator cend(size_t j)</CODE></H4>
<P>This returns an iterator to the end of column <CODE>j</CODE> of the
matrix.</P>

<H4><CODE>Vector&lt;T&gt;::const_iterator rbegin(size_t i) const</CODE></H4>
<P>This returns a constant iterator to the beginning of row <CODE>i</CODE> of
the matrix.</P>

<H4><CODE>Vector&lt;T&gt;::const_iterator rend(size_t i) const</CODE></H4>
<P>This returns a constant iterator to the end of row <CODE>i</CODE> of the
matrix.</P>

<H4><CODE>Vector&lt;T&gt;::const_iterator cbegin(size_t j) const</CODE></H4>
<P>This returns a constant iterator to the beginning of column <CODE>j</CODE>
of the matrix.</P>

<H4><CODE>Vector&lt;T&gt;::const_iterator cend(size_t j) const</CODE></H4>
<P>This returns a constant iterator to the end of column <CODE>j</CODE> of the
matrix.</P>

<H4><CODE>void read(istream&amp; in)</CODE></H4>
<P>This reads the contents of a stream into the matrix. The matrix is reshaped
to a base size of one row with 1024 columns, and if this is insufficient for
reading in the entire stream, the matrix is resized by a factor of two, and so
on. When the full stream is read in, the matrix is resized, if necessary, to
the number of elements read. This results in the stream being read to the end,
so you may need to use the <CODE>clear()</CODE> member function if you wish to
continue using the stream. The final result is a matrix with one row.</P>

<H4><CODE>void read(istream&amp; in, size_t ncount)</CODE></H4>
<P>This reads the contents of a stream into the matrix. The matrix is reshaped
to size <CODE>(1, ncount)</CODE>, and the stream is read in until either the
end of the stream is reached, or until <CODE>ncount</CODE> elements have been
read. When the full stream is read in, the matrix is resized, if necessary, to
the number of elements read. This function may result in the stream being read
to the end, so you may need to use the <CODE>clear()</CODE> member function if
you wish to continue using the stream. The final result is a matrix with one
row.</P>

<H4><CODE>void write(ostream&amp; out) const</CODE></H4>
<P>This outputs the contents of the matrix to a stream in row major form. The
rows are separated with a carriage return delimiter, and elements of the row
are separated by a tab delimiter. To output in column major form, simply call
this function for a transpose view of the matrix.</P>
 
<H4><CODE>template &lt;class G&gt; Matrix&lt;T&gt;& fill(const G&amp;
    gen)</CODE></H4>
<P>This function fills the matrix with values from the generator
<CODE>gen</CODE>. Class <CODE>G</CODE> must have a function call operator which
takes no arguments, and returns a value that can be cast to type
<CODE>T</CODE>. This includes the four random number generator classes
<CODE>BaseGen</CODE>, <CODE>IntGen</CODE>, <CODE>UniformGen</CODE>, and
<CODE>NormalGen</CODE>. Ordinary function pointers can be passed as well, but
note that the compiler will not be able to resolve the function if it is
overloaded. This member function returns itself by reference, allowing for
cascading.</P>

<H4><CODE>template &lt;class G&gt; Matrix&lt;T&gt;& fill2(const F&amp;
    fn)</CODE></H4>
<P>This function applies the function object <CODE>fn</CODE> to each element of
the matrix it is called for. Class <CODE>F</CODE> must have a function call
operator which takes one argument of type <CODE>T</CODE>, and returns a value
that can be cast to type <CODE>T</CODE>. Ordinary function pointers can be
passed as well, but note that the compiler will not be able to resolve the
function if it is overloaded. This member function returns itself by reference,
allowing for cascading.</P>

<H4><CODE>template &lt;class U&gt; Matrix&lt;U&gt; convert(const U&amp; a)
    const</CODE></H4>
<P>This creates a matrix of type <CODE>U</CODE> from a matrix of type
<CODE>T</CODE>. It must be possible to explicitly cast type <CODE>T</CODE> to
type <CODE>U</CODE>. <CODE>a</CODE> is a dummy value that is used simply to
tell the compiler what type to convert to. Example:</P>

<DIV CLASS=sc><CODE>
<P>Mat_DP x(4.5, 10, 4);</P>
<P>Mat_SP y = x.convert(float());</P>
</CODE></DIV>

<H4><CODE>template &lt;class U&gt; Matrix&lt;U&gt; shallow_cast(const U&amp; a)
    const</CODE></H4>
<P>This creates a shallow copy of the matrix it is called for, but of type
<CODE>Matrix&lt;U&gt;</CODE>. This is done using pointer casting, which means
the new matrix views the same data as the original, but views it as data of
type <CODE>U</CODE> instead of as type <CODE>T</CODE>. For example, the
internal representation if <CODE>int</CODE> and <CODE>long</CODE> is the same
on many platforms. This function allows you to view a matrix of type
<CODE>int</CODE> as a matrix of type <CODE>long</CODE>, without making a
seperate copy of the data. If used for non-standard types with non-trivial
constructors, this function has the potential to cause some serious bugs, since
the wrong destructor may be called to destroy the matrix elements. Types
<CODE>T</CODE> and <CODE>U</CODE> must have the same size.</P>

<H3>3.4.3. Overloaded operators.</H3>

<H4><CODE>Matrix&lt;T&gt;&amp; operator=(const Matrix&lt;T&gt;&amp;
    rhs)</CODE></H4>
<P>This uses the assignment operator of type <CODE>T</CODE> to do an
element-by-element copy of <CODE>rhs</CODE> to the matrix it is called for,
which is the left hand side of the expression. The matrices must have the same
dimensions.</P>

<H4><CODE>Matrix&lt;T&gt;&amp; operator=(const T&amp; rhs)</CODE></H4>
<P>This uses the assignment operator of type <CODE>T</CODE> to copy
<CODE>rhs</CODE> to each element of the matrix it is called for.</P>

<CODE><STRONG>
<P>Matrix&lt;T&gt;&amp; operator+=(const Matrix&lt;T&gt;&amp; rhs)</P>
<P>Matrix&lt;T&gt;&amp; operator-=(const Matrix&lt;T&gt;&amp; rhs)</P>
<P>Matrix&lt;T&gt;&amp; operator*=(const Matrix&lt;T&gt;&amp; rhs)</P>
<P>Matrix&lt;T&gt;&amp; operator/=(const Matrix&lt;T&gt;&amp; rhs)</P>
<P>Matrix&lt;T&gt;&amp; operator%=(const Matrix&lt;T&gt;&amp; rhs)</P>
<P>Matrix&lt;T&gt;&amp; operator&amp;=(const Matrix&lt;T&gt;&amp; rhs)</P>
<P>Matrix&lt;T&gt;&amp; operator^=(const Matrix&lt;T&gt;&amp; rhs)</P>
<P>Matrix&lt;T&gt;&amp; operator|=(const Matrix&lt;T&gt;&amp; rhs)</P>
<P>Matrix&lt;T&gt;&amp; operator&gt;&gt;=(const Matrix&lt;T&gt;&amp; rhs)</P>
<P>Matrix&lt;T&gt;&amp; operator&lt;&lt;=(const Matrix&lt;T&gt;&amp; rhs)</P>
</STRONG></CODE>
<P>These operators use the arithmetic assignment operators of type
<CODE>T</CODE> to do element-by-element arithmetic assignment. The matrices
must have the same dimensions.</P>

<CODE><STRONG>
<P>Matrix&lt;T&gt;&amp; operator+=(const T&amp; rhs),</P>
<P>Matrix&lt;T&gt;&amp; operator-=(const T&amp; rhs),</P>
<P>Matrix&lt;T&gt;&amp; operator*=(const T&amp; rhs),</P>
<P>Matrix&lt;T&gt;&amp; operator/=(const T&amp; rhs),</P>
<P>Matrix&lt;T&gt;&amp; operator%=(const T&amp; rhs),</P>
<P>Matrix&lt;T&gt;&amp; operator&amp;=(const T&amp; rhs),</P>
<P>Matrix&lt;T&gt;&amp; operator^=(const T&amp; rhs),</P>
<P>Matrix&lt;T&gt;&amp; operator|=(const T&amp; rhs),</P>
<P>Matrix&lt;T&gt;&amp; operator&gt;&gt;=(const T&amp; rhs),</P>
<P>Matrix&lt;T&gt;&amp; operator&lt;&lt;=(const T&amp; rhs),</P>
</STRONG></CODE>
<P>These operators use the arithmetic assignment operators of type
<CODE>T</CODE> to perform the corrosponding operation on the matrix.</P>

<H4><CODE>Matrix&lt;T&gt; operator+() const</CODE></H4>
<P>This returns a matrix such that each element is the result of applying the
unary <CODE>+</CODE> operator to each element of the original matrix. This
operator must be available for type <CODE>T</CODE>.</P>

<H4><CODE>Matrix&lt;T&gt; operator-() const</CODE></H4>
<P>This returns a matrix such that each element is the negation of the original
value. The unary <CODE>-</CODE> operator must be available for type
<CODE>T</CODE>.</P>

<H4><CODE>Matrix&lt;bool&gt; operator!() const</CODE></H4>
<P>This returns a matrix of <CODE>bool</CODE> values such that <CODE>B(i, j) =
!M(i, j)</CODE>, where <CODE>B</CODE> is the returned matrix, and
<CODE>M</CODE> is the original matrix. This operator must be available for type
<CODE>T</CODE>.</P>

<H4><CODE>Matrix&lt;T&gt; operator~() const</CODE></H4>
<P>This returns a matrix by applying the <CODE>~</CODE> operator to each
element. This operator must be available for type <CODE>T</CODE>.</P>

<H4><CODE>T&amp; operator()(size_t i, size_t j)</CODE></H4>
<P>Indexing. This returns a reference to the <CODE>(i, j)</CODE> element of the
matrix.</P>

<H4><CODE>const T&amp; operator()(size_t i, size_t j) const</CODE></H4>
<P>The constant version of this operator returns a constant reference.</P>

<H4><CODE>Vector&lt;T&gt;::iterator operator[](size_t i)</CODE></H4>
<P>This returns an iterator to the <CODE>i</CODE>th row of the matrix. This is
identical to the <CODE>rbegin()</CODE> member function, except that
bounds-checking on the row is only done if bounds-checking is enabled. It is
provided to facilitate C-style indexing. Example:</P>

<DIV CLASS=sc><CODE>
<P>Mat_DP x(10,20);</P>
<P>UniformGen gen(0);</P>
<P>x.fill(gen);</P>
<P>cout &lt;&lt; x[5][4];</P>
</CODE></DIV>

<P>This is less efficient that using the <CODE>()</CODE> operator, and is
included to allow compatibility with software like <EM>Numerical Recipes in
C++</EM>.</P>

<H4><CODE>Vector&lt;T&gt;::const_iterator operator[](size_t i)
    const</CODE></H4>
<P>The constant version of this operator returns a constant iterator.</P>

<H3>3.4.4. Global Functions.</H3>

<P>These functions mimic the Standard Library functions of the same name,
performing the associated operation on every element of the matrix.</P>

<CODE><STRONG>
<P>Matrix&lt;T&gt; abs(const Matrix&lt;T&gt;&amp; x)</P>
<P>Matrix&lt;T&gt; abs(const Matrix&lt;complex&lt;T&gt; &gt;&amp; x)</P>
<P>Matrix&lt;T&gt; acos(const Matrix&lt;T&gt;&amp; x)</P>
<P>Matrix&lt;T&gt; asin(const Matrix&lt;T&gt;&amp; x)</P>
<P>Matrix&lt;T&gt; atan(const Matrix&lt;T&gt;&amp; x)</P>
<P>Matrix&lt;T&gt; atan2(const Matrix&lt;T&gt;&amp; x, const
Matrix&lt;T&gt;&amp; y)</P>
<P>Matrix&lt;T&gt; atan2(const Matrix&lt;T&gt;&amp; x, const T&amp; y)</P>
<P>Matrix&lt;T&gt; atan2(const T&amp; x, const Matrix&lt;T&gt;&amp; y)</P>
<P>Matrix&lt;T&gt; cos(const Matrix&lt;T&gt;&amp; x)</P>
<P>Matrix&lt;T&gt; cosh(const Matrix&lt;T&gt;&amp; x)</P>
<P>Matrix&lt;T&gt; exp(const Matrix&lt;T&gt;&amp; x)</P>
<P>Matrix&lt;T&gt; log(const Matrix&lt;T&gt;&amp; x)</P>
<P>Matrix&lt;T&gt; log10(const Matrix&lt;T&gt;&amp; x)</P>
<P>Matrix&lt;T&gt; pow(const Matrix&lt;T&gt;&amp; x, const Matrix&lt;T&gt;&amp;
y)</P>
<P>Matrix&lt;T&gt; pow(const Matrix&lt;T&gt;&amp; x, const T&amp; y)</P>
<P>Matrix&lt;T&gt; pow(const T&amp; x, const Matrix&lt;T&gt;&amp; y)</P>
<P>Matrix&lt;T&gt; sin(const Matrix&lt;T&gt;&amp; x)</P>
<P>Matrix&lt;T&gt; sinh(const Matrix&lt;T&gt;&amp; x)</P>
<P>Matrix&lt;T&gt; sqrt(const Matrix&lt;T&gt;&amp; x)</P>
<P>Matrix&lt;T&gt; tan(const Matrix&lt;T&gt;&amp; x)</P>
<P>Matrix&lt;T&gt; tanh(const Matrix&lt;T&gt;&amp; x)</P>
<P>Matrix&lt;T&gt; arg(const Matrix&lt;complex&lt;T&gt; &gt;&amp; x)</P>
<P>Matrix&lt;T&gt; norm(const Matrix&lt;complex&lt;T&gt; &gt;&amp; x)</P>
<P>Matrix&lt;complex&lt;T&gt; &gt; polar(const Matrix&lt;T&gt;&amp; rho, const
Matrix&lt;T&gt;&amp; theta)</P>
<P>Matrix&lt;complex&lt;T&gt; &gt; polar(const Matrix&lt;T&gt;&amp; rho, const
T&amp; theta)</P>
<P>Matrix&lt;complex&lt;T&gt; &gt; polar(const T&amp; rho, const
Matrix&lt;T&gt;&amp; theta)</P>
<P>Matrix&lt;complex&lt;T&gt; &gt; conj(const Matrix&lt;complex&lt;T&gt;
&gt;&amp; x)</P>
<P>Matrix&lt;T&gt; real(const Matrix&lt;complex&lt;T&gt; &gt;&amp; x)</P>
<P>Matrix&lt;T&gt; imag(const Matrix&lt;complex&lt;T&gt; &gt;&amp; x)</P>
</STRONG></CODE>

<P>Note that the <CODE>real()</CODE> and <CODE>imag()</CODE> functions only
work for complex types with a specialization of the
<CODE>VMTraits&lt;T&gt;</CODE> structure. Similarly, the complex version of the
<CODE>abs()</CODE> function only works for these types. Attempting to use these
functions for other types will probably result in compiler errors.</P>

<H3>3.4.5. Global Operators.</H3>

<H3>Binary Operators For Two Matrices.</H3>

<P>These operators perform the associated operation element by element. The two
matricess must have the same size. The result is a new matrix with the
appropriate values.</P>

<CODE><STRONG>
<P>Matrix&lt;T&gt; operator+(const Matrix&lt;T&gt;&amp; lhs, const
Matrix&lt;T&gt;&amp; rhs)</P>
<P>Matrix&lt;T&gt; operator-(const Matrix&lt;T&gt;&amp; lhs, const
Matrix&lt;T&gt;&amp; rhs)</P>
<P>Matrix&lt;T&gt; operator*(const Matrix&lt;T&gt;&amp; lhs, const
Matrix&lt;T&gt;&amp; rhs)</P>
<P>Matrix&lt;T&gt; operator/(const Matrix&lt;T&gt;&amp; lhs, const
Matrix&lt;T&gt;&amp; rhs)</P>
<P>Matrix&lt;T&gt; operator%(const Matrix&lt;T&gt;&amp; lhs, const
Matrix&lt;T&gt;&amp; rhs)</P>
<P>Matrix&lt;T&gt; operator&amp;(const Matrix&lt;T&gt;&amp; lhs, const
Matrix&lt;T&gt;&amp; rhs)</P>
<P>Matrix&lt;T&gt; operator^(const Matrix&lt;T&gt;&amp; lhs, const
Matrix&lt;T&gt;&amp; rhs)</P>
<P>Matrix&lt;T&gt; operator|(const Matrix&lt;T&gt;&amp; lhs, const
Matrix&lt;T&gt;&amp; rhs)</P>
<P>Matrix&lt;T&gt; operator&lt;&lt;(const Matrix&lt;T&gt;&amp; lhs, const
Matrix&lt;T&gt;&amp; rhs)</P>
<P>Matrix&lt;T&gt; operator&gt;&gt;(const Matrix&lt;T&gt;&amp; lhs, const
Matrix&lt;T&gt;&amp; rhs)</P>
<P>Matrix&lt;bool&gt; operator==(const Matrix&lt;T&gt;&amp; lhs, const
Matrix&lt;T&gt;&amp; rhs)</P>
<P>Matrix&lt;bool&gt; operator!=(const Matrix&lt;T&gt;&amp; lhs, const
Matrix&lt;T&gt;&amp; rhs)</P>
<P>Matrix&lt;bool&gt; operator&lt;(const Matrix&lt;T&gt;&amp; lhs, const
Matrix&lt;T&gt;&amp; rhs)</P>
<P>Matrix&lt;bool&gt; operator&gt;(const Matrix&lt;T&gt;&amp; lhs, const
Matrix&lt;T&gt;&amp; rhs)</P>
<P>Matrix&lt;bool&gt; operator&lt;=(const Matrix&lt;T&gt;&amp; lhs, const
Matrix&lt;T&gt;&amp; rhs)</P>
<P>Matrix&lt;bool&gt; operator&gt;=(const Matrix&lt;T&gt;&amp; lhs, const
Matrix&lt;T&gt;&amp; rhs)</P>
<P>Matrix&lt;bool&gt; operator&amp;&amp;(const Matrix&lt;T&gt;&amp; lhs, const
Matrix&lt;T&gt;&amp; rhs)</P>
<P>Matrix&lt;bool&gt; operator||(const Matrix&lt;T&gt;&amp; lhs, const
Matrix&lt;T&gt;&amp; rhs)</P>
</STRONG></CODE>

<P>These operators perform the associated operation element-by-element. The two
matrices must have the same dimensions. The result is a new matrix with the
appropriate values.</P>

<H3>Binary Operators for Matrices and Scalers.</H3>

<P>These operators perform the associated operation element-by-element with a
scalar. The result is a new matrix with the appropriate values.</P>

<CODE><STRONG>
<P>Matrix&lt;T&gt; operator+(const Matrix&lt;T&gt;&amp; lhs, const T&amp;
a)</P>
<P>Matrix&lt;T&gt; operator+(const T&amp; a, const Matrix&lt;T&gt;&amp;
rhs)</P>
<P>Matrix&lt;T&gt; operator-(const Matrix&lt;T&gt;&amp; lhs, const T&amp;
a)</P>
<P>Matrix&lt;T&gt; operator-(const T&amp; a, const Matrix&lt;T&gt;&amp;
rhs)</P>
<P>Matrix&lt;T&gt; operator*(const Matrix&lt;T&gt;&amp; lhs, const T&amp;
a)</P>
<P>Matrix&lt;T&gt; operator*(const T&amp; a, const Matrix&lt;T&gt;&amp;
rhs)</P>
<P>Matrix&lt;T&gt; operator/(const Matrix&lt;T&gt;&amp; lhs, const T&amp;
a)</P>
<P>Matrix&lt;T&gt; operator/(const T&amp; a, const Matrix&lt;T&gt;&amp;
rhs)</P>
<P>Matrix&lt;T&gt; operator%(const Matrix&lt;T&gt;&amp; lhs, const T&amp;
a)</P>
<P>Matrix&lt;T&gt; operator%(const T&amp; a, const Matrix&lt;T&gt;&amp;
rhs)</P>
<P>Matrix&lt;T&gt; operator&amp;(const Matrix&lt;T&gt;&amp; lhs, const T&amp;
a)</P>
<P>Matrix&lt;T&gt; operator&amp;(const T&amp; a, const Matrix&lt;T&gt;&amp;
rhs)</P>
<P>Matrix&lt;T&gt; operator^(const Matrix&lt;T&gt;&amp; lhs, const T&amp;
a)</P>
<P>Matrix&lt;T&gt; operator^(const T&amp; a, const Matrix&lt;T&gt;&amp;
rhs)</P>
<P>Matrix&lt;T&gt; operator|(const Matrix&lt;T&gt;&amp; lhs, const T&amp;
a)</P>
<P>Matrix&lt;T&gt; operator|(const T&amp; a, const Matrix&lt;T&gt;&amp;
rhs)</P>
<P>Matrix&lt;T&gt; operator&lt;&lt;(const Matrix&lt;T&gt;&amp; lhs, const
T&amp; a)</P>
<P>Matrix&lt;T&gt; operator&lt;&lt;(const T&amp; a, const Matrix&lt;T&gt;&amp;
rhs)</P>
<P>Matrix&lt;T&gt; operator&gt;&gt;(const Matrix&lt;T&gt;&amp; lhs, const
T&amp; a)</P>
<P>Matrix&lt;T&gt; operator&gt;&gt;(const T&amp; a, const Matrix&lt;T&gt;&amp;
rhs)</P>
<P>Matrix&lt;bool&gt; operator==(const Matrix&lt;T&gt;&amp; lhs, const T&amp;
a)</P>
<P>Matrix&lt;bool&gt; operator==(const T&amp; a, const Matrix&lt;T&gt;&amp;
rhs)</P>
<P>Matrix&lt;bool&gt; operator!=(const Matrix&lt;T&gt;&amp; lhs, const T&amp;
a)</P>
<P>Matrix&lt;bool&gt; operator!=(const T&amp; a, const Matrix&lt;T&gt;&amp;
rhs)</P>
<P>Matrix&lt;bool&gt; operator&lt;(const Matrix&lt;T&gt;&amp; lhs, const T&amp;
a)</P>
<P>Matrix&lt;bool&gt; operator&lt;(const T&amp; a, const Matrix&lt;T&gt;&amp;
rhs)</P>
<P>Matrix&lt;bool&gt; operator&gt;(const Matrix&lt;T&gt;&amp; lhs, const T&amp;
a)</P>
<P>Matrix&lt;bool&gt; operator&gt;(const T&amp; a, const Matrix&lt;T&gt;&amp;
rhs)</P>
<P>Matrix&lt;bool&gt; operator&lt;=(const Matrix&lt;T&gt;&amp; lhs, const
T&amp; a)</P>
<P>Matrix&lt;bool&gt; operator&lt;=(const T&amp; a, const Matrix&lt;T&gt;&amp;
rhs)</P>
<P>Matrix&lt;bool&gt; operator&gt;=(const Matrix&lt;T&gt;&amp; lhs, const
T&amp; a)</P>
<P>Matrix&lt;bool&gt; operator&gt;=(const T&amp; a, const Matrix&lt;T&gt;&amp;
rhs)</P>
<P>Matrix&lt;bool&gt; operator&amp;&amp;(const Matrix&lt;T&gt;&amp; lhs, const
T&amp; a)</P>
<P>Matrix&lt;bool&gt; operator&amp;&amp;(const T&amp; a, const
Matrix&lt;T&gt;&amp; rhs)</P>
<P>Matrix&lt;bool&gt; operator||(const Matrix&lt;T&gt;&amp; lhs, const T&amp;
a)</P>
<P>Matrix&lt;bool&gt; operator||(const T&amp; a, const Matrix&lt;T&gt;&amp;
rhs)</P>
</STRONG></CODE>

<H3>Streaming IO Operators.</H3>

<P>These operators provide insertion and extraction operators for using
matrices with iostreams. The corresponding operators must exist for type
<CODE>T</CODE>.</P>

<H4><CODE>ostream&amp; operator&lt;&lt;(ostream&amp; out, const
    Matrix&lt;T&gt;&amp; x)</CODE></H4>
<P>This functions identically to the <CODE>write()</CODE> member function,
except that it returns a reference to the stream, for cascading.</P>

<H4><CODE>istream&amp; operator&gt;&gt;(istream&amp; in, Matrix&lt;T&gt;&amp;
    x)</CODE></H4>
<P>This reads a stream into a matrix. Unlike the <CODE>read()</CODE> member
function, this does not reshape the matrix. It simply reads in from the stream
until either the stream ends, or the end of the matrix is reached. Data is read
in row major form. To read in column major form, simply pass the operator a
transpose view of the matrix.</P>

<P><A HREF="VM_FFTWPlan.htm">Next Section</A></P>
<P><A HREF="VM_Classes.htm">Back to Classes</A></P>

</BODY>
</HTML>