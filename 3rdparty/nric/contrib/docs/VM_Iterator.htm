<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
  "http://www.w3.org/TR/REC-html40/transitional.dtd">
<HTML>
<HEAD>
  <TITLE>VecMat - Vector&lt;T&gt;::Iterator</TITLE>
  <META HTTP-EQUIV="Content-Type" CONTENT="text/html;charset=iso-8859-1">
  <META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">
  <META NAME="Author" CONTENT="Kevin Dolan">
  <LINK HREF="vecmat.css" REL="stylesheet" TYPE="text/css">
</HEAD>

<BODY>

<H2>3.2. Vector&lt;T&gt;::iterator</H2>

<P>This class provides an <EM>STL</EM> style random access iterator for use
with generic algorithms. Since neither the vector nor the matrix classes are,
strictly speaking, container classes, the iterator class is really an iterator
of the data object that is viewed by a vector or matrix. Note that if any
operation occurs that would cause the memory this iterator references to be
deallocated, the iterator becomes invalidated. No bounds-checking is done for
iterators, nor is any checking done to make sure that the arguments for
relational operators refer to the same object.</P>

<H3>3.2.1. Constructors.</H3>

<H4><CODE>explicit Vector&lt;T&gt;::iterator(T* p = 0, ptrdiff_t s =
    1)</CODE></H4>
<P>This creates an iterator that points to the value pointed to by
<CODE>p</CODE>, with stride <CODE>s</CODE>.</P>

<H4><CODE>Vector&lt;T&gt;::iterator(const Vector&lt;T&gt;::iterator&amp;
    rhs)</CODE></H4>
<P>The copy constructor creates a new iterator, and sets it equal to
<CODE>rhs</CODE>.</P>

<H4><CODE>Vector&lt;T&gt;::~iterator()</CODE></H4>
<P>This destroys the iterator.</P>

<H3>3.2.2. Overloaded operators.</H3>

<H4><CODE>Vector&lt;T&gt;::iterator&amp; operator++()</CODE></H4>
<P>The prefix increment operator moves the iterator to the next element of the
object it is referencing, according to the stride of the object from which it
was created.</P>

<H4><CODE>Vector&lt;T&gt;::iterator&amp; operator--()</CODE></H4>
<P>The prefix decrement operator. This functions just like the increment
operator, except that it steps through the data backwards.</P>

<H4><CODE>Vector&lt;T&gt;::iterator operator++(int)</CODE></H4>
<P>The postfix increment operator.</P>

<H4><CODE>Vector&lt;T&gt;::iterator operator--(int)</CODE></H4>
<P>The postfix decrement operator.</P>

<H4><CODE>Vector&lt;T&gt;::iterator&amp; operator+=(ptrdiff_t n)</CODE></H4>
<P>This increments the iterator by <CODE>n</CODE> elements. The result is
equivalent to using the increment operator <CODE>n</CODE> times, but much more
efficient.</P>

<H4><CODE>Vector&lt;T&gt;::iterator&amp; operator-=(ptrdiff_t n)</CODE></H4>
<P>This decrements the iterator by <CODE>n</CODE> elements.</P>

<H4><CODE>Vector&lt;T&gt;::iterator&amp; operator=(const
    Vector&lt;T&gt;::iterator&amp; rhs)</CODE></H4>
<P>The assignment operator sets the iterator to reference the same data as
<CODE>rhs</CODE>, and points the iterator to the same element as
<CODE>rhs</CODE>.</P>

<H4><CODE>ptrdiff_t operator-(const Vector&lt;T&gt;::iterator&amp; rhs)
    const</CODE></H4>
<P>This returns the difference between two iterators. This operation is only
well defined if the two iterators reference the same data in the same way.</P>

<H4><CODE>Vector&lt;T&gt;::iterator operator-(ptrdiff_t n) const</CODE></H4>
<P>This returns an iterator pointing to <CODE>n</CODE> elements before the
iterator it is called for.</P>

<H4><CODE>Vector&lt;T&gt;::iterator operator+(ptrdiff_t n) const</CODE></H4>
<P>This returns an iterator pointing to <CODE>n</CODE> elements after the
iterator it is called for.</P>

<H4><CODE>T& operator*() const</CODE></H4>
<P>The dereferencing operator returns a reference to the element at which the
iterator is pointing.</P>

<H4><CODE>T* operator-&gt;() const</CODE></H4>
<P>The member selection operator returns a pointer to the element at which the
iterator is pointing.</P>

<H4><CODE>T&amp; operator[](size_t n) const</CODE></H4>
<P>The indexing operator returns a reference to the element <CODE>n</CODE>
elements after the element pointed to by the iterator.</P>

<H4><CODE>bool operator==(const Vector&lt;T&gt;::iterator&amp; rhs)
    const</CODE></H4>
<P>This returns <CODE>true</CODE> if the iterator it is called for points to
the same element as <CODE>rhs</CODE>, and <CODE>false</CODE> if it does not. It
is undefined if the two iterators reference the data in different ways, or if
they reference different data. This is also the case for the other relation
operators that follow.</P>

<CODE><STRONG>
<P>bool operator!=(const Vector&lt;T&gt;::iterator&amp; rhs) const</P>
<P>bool operator&lt;(const Vector&lt;T&gt;::iterator&amp; rhs) const</P>
<P>bool operator&gt;(const Vector&lt;T&gt;::iterator&amp; rhs) const</P>
<P>bool operator&lt;=(const Vector&lt;T&gt;::iterator&amp; rhs) const</P>
<P>bool operator&gt;=(const Vector&lt;T&gt;::iterator&amp; rhs) const</P>
</STRONG></CODE>
<P>These relation operators all work as would be expected based on the behavior
of <CODE>operator==()</CODE>.</P>

<H2><A NAME=ci>3.3. Vector&lt;T&gt;::const_iterator</A></H2>

<P>This class functions almost identically to the iterator class. The main
difference is that it cannot be dereferenced or indexed in a way that would
alter the data it references. A constant iterator can be made from a constant
or non-constant vector or matrix, but the ordinary iterators can only be made
from non-constant vectors and matrices.</P>

<H3>3.3.1. Constructors.</H3>

<H4><CODE>explicit Vector&lt;T&gt;::const_iterator(T* p = 0, ptrdiff_t s = 
    1)</CODE></H4>
<P>This creates a constant iterator, which points to the value pointed to by
<CODE>p</CODE>, with stride <CODE>s</CODE>.</P>

<H4><CODE>Vector&lt;T&gt;::const_iterator(const
    Vector&lt;T&gt;::const_iterator&amp; rhs)</CODE></H4>
<P>The copy constructor creates a new constant iterator, and sets it equal to
<CODE>rhs</CODE>.</P>

<H4><CODE>Vector&lt;T&gt;::const_iterator(const Vector&lt;T&gt;::iterator&amp;
    rhs)</CODE></H4>
<P>This constructor creates a new constant iterator from an ordinary
iterator.</P>

<H4><CODE>Vector&lt;T&gt;::~const_iterator()</CODE></H4>
<P>This destroys the iterator.</P>

<H3>3.3.2. Overloaded operators.</H3>

<H4><CODE>Vector&lt;T&gt;::const_iterator&amp; operator++()</CODE></H4>
<P>The prefix increment operator moves the iterator to the next element of the
object it is referencing, according to the stride of the object from which it
was created.</P>

<H4><CODE>Vector&lt;T&gt;::const_iterator&amp; operator--()</CODE></H4>
<P>The prefix decrement operator. This functions just like the increment
operator, except that it steps through the data backwards.</P>

<H4><CODE>Vector&lt;T&gt;::const_iterator operator++(int)</CODE></H4>
<P>The postfix increment operator.</P>

<H4><CODE>Vector&lt;T&gt;::const_iterator operator--(int)</CODE></H4>
<P>The postfix decrement operator.</P>

<H4><CODE>Vector&lt;T&gt;::const_iterator&amp; operator+=(ptrdiff_t n)</CODE></H4>
<P>This increments the iterator by <CODE>n</CODE> elements. The result is
equivalent to using the increment operator <CODE>n</CODE> times, but much more
efficient.</P>

<H4><CODE>Vector&lt;T&gt;::const_iterator&amp;
    operator-=(ptrdiff_t n)</CODE></H4>
<P>This decrements the iterator by <CODE>n</CODE> elements.</P>

<H4><CODE>Vector&lt;T&gt;::const_iterator&amp; operator=(const
    Vector&lt;T&gt;::const_iterator&amp; rhs)</CODE></H4>
<P>The assignment operator sets the iterator to reference the same data as
<CODE>rhs</CODE>, and points the iterator to the same element as
<CODE>rhs</CODE>.</P>

<H4><CODE>Vector&lt;T&gt;::const_iterator&amp; operator=(const
    Vector&lt;T&gt;::iterator&amp; rhs)</CODE></H4>
<P>This assignment operator sets the constant iterator to reference the same
data as the ordinary iterator <CODE>rhs</CODE>, and points the iterator to the
same element as <CODE>rhs</CODE>.</P>

<H4><CODE>ptrdiff_t operator-(const Vector&lt;T&gt;::const_iterator&amp; rhs)
    const</CODE></H4>
<P>This returns the difference between two iterators. This operation is only
well defined if the two iterators reference the same data in the same way.</P>

<H4><CODE>Vector&lt;T&gt;::const_iterator operator-(ptrdiff_t n)
    const</CODE></H4>
<P>This returns an iterator pointing to <CODE>n</CODE> elements before the
iterator it is called for.</P>

<H4><CODE>Vector&lt;T&gt;::const_iterator operator+(ptrdiff_t n)
    const</CODE></H4>
<P>This returns an iterator pointing to <CODE>n</CODE> elements after the
iterator it is called for.</P>

<H4><CODE>const T&amp; operator*() const</CODE></H4>
<P>The dereferencing operator returns a constant reference to the element at
which the iterator is pointing. This returned reference cannot be modified.</P>

<H4><CODE>const T* operator-&gt;() const</CODE></H4>
<P>The member selection operator returns a constant pointer to the element at
which the iterator is pointing.</P>

<H4><CODE>const T&amp; operator[](size_t n) const</CODE></H4>
<P>The indexing operator returns a constant reference to the element
<CODE>n</CODE> elements after the element pointed to by the iterator. This
returned reference cannot be modified.</P>

<H4><CODE>bool operator==(const Vector&lt;T&gt;::const_iterator&amp; rhs)
    const</CODE></H4>
<P>This returns <CODE>true</CODE> if the iterator it is called for points to
the same element as <CODE>rhs</CODE>, and <CODE>false</CODE> if it does not. It
is undefined if the two iterators reference the data in different ways, or if
they reference different data. This is also the case for the other relation
operators that follow.</P>

<CODE><STRONG>
<P>bool operator!=(const Vector&lt;T&gt;::const_iterator&amp; rhs) const</P>
<P>bool operator&lt;(const Vector&lt;T&gt;::const_iterator&amp; rhs) const</P>
<P>bool operator&gt;(const Vector&lt;T&gt;::const_iterator&amp; rhs) const</P>
<P>bool operator&lt;=(const Vector&lt;T&gt;::const_iterator&amp; rhs) const</P>
<P>bool operator&gt;=(const Vector&lt;T&gt;::const_iterator&amp; rhs) const</P>
</STRONG></CODE>
<P>These relation operators all work as would be expected based on the behavior
of <CODE>operator==()</CODE>.</P>

<P><A HREF="VM_Matrix.htm">Next Section</A></P>
<P><A HREF="VM_Classes.htm">Back to Classes</A></P>

</BODY>
</HTML>
