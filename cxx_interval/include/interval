#ifndef INTERVAL
#define INTERVAL 1

#include <algorithm>
#include <iostream>
#include <sstream>
#include <ios>

//#include "rounding_tools.h"
#include "rounded_cmath.h"

/// The four different interval classification
/// # ZERO	a=0 && b=0
/// # POSITIVE	a>=0 && b>0
/// # NEGATIVE	a<0 && b<=0
/// # MIXED	a<0 && b>0
enum int_class
{
  NO_CLASS,
  ZERO,
  POSITIVE,
  NEGATIVE,
  MIXED
};

//
// Interval class
//
template<typename _FloatTp>
  class interval
  {
    _FloatTp _M_lower;
    _FloatTp _M_upper;

  public:

    typedef _FloatTp value_type;

    // constructor. zero, one or two arguments for type _FloatTp
    interval()
    : _M_lower{0}, _M_upper{0}
    { }

    interval(const _FloatTp& __d)
    : _M_lower(__d), _M_upper(__d)
    { }

    interval(const _FloatTp& __lo, const _FloatTp& __up)
    {
      if (__lo < __up)
	{
	  this->_M_lower = __lo;
	  this->_M_upper = __up;
	}
      else
	{
	  this->_M_lower = __up;
	  this->_M_upper = __lo;
	}
    }

    interval(const interval&) = default;
    interval(interval&&) = default;

    interval&
    operator=(const interval&) = default;
    interval&
    operator=(interval&&) = default;

    // Constrcutor for mixed type _FloatTp != _X (base types).
    // Allows auto construction of e.g. interval<float_precision> x(float)
    template<typename _X>
      interval(const _X& x)
      : _M_lower(_FloatTp(x)), _M_upper(_FloatTp(x))
      { }

    // constructor for any other type to _FloatTp. Both up and down conversion possible
    template<typename X>
      interval(const interval<X>& __a)
      {
	if (__a.lower() < __a.upper())
          {
	    fpdown();
	    this->_M_lower = _FloatTp(__a.lower());
	    fpup();
	    this->_M_upper = _FloatTp(__a.upper());
	    fpnear();
	  }
	else
	  {
	    fpdown();
	    this->_M_lower = _FloatTp(__a.upper());
	    fpup();
	    this->_M_upper = _FloatTp(__a.lower());
	    fpnear();
	  }
      }
	
    // Coordinate functions
    _FloatTp
    upper() const
    { return this->_M_upper; }

    _FloatTp
    lower() const
    { return this->_M_lower; }

    _FloatTp
    upper(const _FloatTp& __up)
    { return (this->_M_upper = __up); }

    _FloatTp
    lower(const _FloatTp& __lo)
    { return (this->_M_lower = __lo); }


    _FloatTp
    center() const
    { return (this->_M_upper + this->_M_lower) / _FloatTp{2}; }

    _FloatTp
    radius() const
    {
      auto r = (this->_M_upper - this->_M_lower) / _FloatTp{2};
      if (r < _FloatTp{0})
        r = -r;
      return r;
    }

    _FloatTp
    width() const
    {
      _FloatTp r = this->_M_upper - this->_M_lower;
      if (r < _FloatTp{0})
	r = -r;
      return r;
    }

    bool
    contain_zero() const
    { return this->_M_lower <= _FloatTp{0} && _FloatTp{0} <= this->_M_upper; }  // Obsolete. use contains() instead.

    bool
    contain(const _FloatTp& __f=_FloatTp{0})
    { return this->_M_lower <= __f && __f <= this->_M_upper;  }

    bool contain(const interval<_FloatTp>& __i)
    { return this->_M_lower <= __i.lower() && __i.upper() <= this->_M_upper; }

    bool
    is_empty() const
    { return this->_M_upper < this->_M_lower; }

    enum int_class
    is_class() const
    {
      if (this->_M_lower == _FloatTp{0} && this->_M_upper == _FloatTp{0})
	return ZERO;
      if (this->_M_lower >= _FloatTp{0} && this->_M_upper > _FloatTp{0})
	return POSITIVE;
      if (this->_M_lower < _FloatTp{0} && this->_M_upper <= _FloatTp{0})
	return NEGATIVE;
      if (this->_M_lower < _FloatTp{0} && this->_M_upper > _FloatTp{0})
	return MIXED;
      return NO_CLASS;
    }

    // Operators
    operator short() const
    { return (short)((this->_M_upper + this->_M_lower) / _FloatTp{2}); }

    operator int() const
    { return (int)center(); }

    operator long() const
    { return (long)((this->_M_upper + this->_M_lower) / _FloatTp{2}); }

    operator unsigned short() const
    { return (unsigned short)((this->_M_upper + this->_M_lower) / _FloatTp{2}); }

    operator unsigned int() const
    { return (unsigned int)((this->_M_upper + this->_M_lower) / _FloatTp{2}); }

    operator unsigned long() const
    { return (unsigned long)((this->_M_upper + this->_M_lower) / _FloatTp{2}); }

    operator double() const
    { return (double)((this->_M_upper + this->_M_lower) / _FloatTp{2}); }

    operator float() const
    { return this->_M_upper == this->_M_lower? (float)this->_M_lower : (float)((this->_M_upper + this->_M_lower) / _FloatTp{2}); }

    interval<_FloatTp>& operator+=(const interval<_FloatTp>&);
    interval<_FloatTp>& operator-=(const interval<_FloatTp>&);
    interval<_FloatTp>& operator*=(const interval<_FloatTp>&);
    interval<_FloatTp>& operator/=(const interval<_FloatTp>&);
    interval<_FloatTp>& operator&=(const interval<_FloatTp>&);
    interval<_FloatTp>& operator|=(const interval<_FloatTp>&);
    interval<_FloatTp>& operator^=(const interval<_FloatTp>&);
  };


template<typename _FloatTp, typename _X>
  interval<_FloatTp>
  operator+(const interval<_FloatTp>&, const _X&);

template<typename _FloatTp, typename _X>
  interval<_FloatTp>
  operator+(const _X&, const interval<_FloatTp>&);

template<typename _FloatTp>
  interval<_FloatTp>
  operator+(const interval<_FloatTp>&, const interval<_FloatTp>&);

template<typename _FloatTp>
  interval<_FloatTp>
  operator+(const interval<_FloatTp>&);


template<typename _FloatTp, typename _X>
  interval<_FloatTp>
  operator-(const interval<_FloatTp>&, const _X&);

template<typename _FloatTp, typename _X>
  interval<_FloatTp>
  operator-(const _X&, const interval<_FloatTp>&);

template<typename _FloatTp>
  interval<_FloatTp>
  operator-(const interval<_FloatTp>&, const interval<_FloatTp>&);

template<typename _FloatTp>
  interval<_FloatTp>
  operator-(const interval<_FloatTp>&);


template<typename _FloatTp, typename _X>
  interval<_FloatTp>
  operator*(const interval<_FloatTp>&, const _X&);

template<typename _FloatTp, typename _X>
  interval<_FloatTp>
  operator*(const _X&, const interval<_FloatTp>&);

template<typename _FloatTp>
  interval<_FloatTp>
  operator*(const interval<_FloatTp>&, const interval<_FloatTp>&);


template<typename _FloatTp, typename _X>
  interval<_FloatTp>
  operator/(const interval<_FloatTp>&, const _X&);

template<typename _FloatTp, typename _X>
  interval<_FloatTp>
  operator/(const _X&, const interval<_FloatTp>&);

template<typename _FloatTp>
  interval<_FloatTp>
  operator/(const interval<_FloatTp>&, const interval<_FloatTp>&);

template<typename _FloatTp, typename _X>
  bool
  operator==(const interval<_FloatTp>&, const _X&);

template<typename _FloatTp, typename _X>
  bool
  operator==(const _X&, const interval<_FloatTp>&);

template<typename _FloatTp, typename _X>
  bool
  operator==(const interval<_FloatTp>&, const interval<_X>&);

template<typename _FloatTp, typename _X>
  bool
  operator!=(const interval<_FloatTp>&, const _X&);

template<typename _FloatTp, typename _X>
  bool
  operator!=(const _X&, const interval<_FloatTp>&);

template<typename _FloatTp, typename _X>
  bool
  operator!=(const interval<_FloatTp>&, const interval<_X>&);


template<typename _FloatTp>
  interval<_FloatTp> abs(const interval<_FloatTp>&);

template<typename _Tp>
  interval<_Tp> sqrt(const interval<_Tp>&);

template<typename _Tp>
  interval<_Tp> cbrt(const interval<_Tp>&);

template<typename _Tp>
  interval<_Tp> log(const interval<_Tp>&);

template<typename _Tp>
  interval<_Tp> log10(const interval<_Tp>&);

template<typename _Tp>
  interval<_Tp> log2(const interval<_Tp>&);

template<typename _Tp>
  interval<_Tp> exp(const interval<float>&, const _Tp);

template<typename _Tp>
  interval<_Tp> exp10(const interval<float>&, const _Tp);

template<typename _Tp>
  interval<_Tp> exp2(const interval<float>&, const _Tp);

template<typename _Tp>
  interval<_Tp> pow(const interval<float>&, const _Tp);

template<typename _Tp>
  interval<_Tp> sin(const interval<_Tp>&);

template<typename _Tp>
  interval<_Tp> cos(const interval<_Tp>&);

template<typename _Tp>
  interval<_Tp> tan(const interval<_Tp>&);

template<typename _Tp>
  interval<_Tp> asin(const interval<_Tp>&);

template<typename _Tp>
  interval<_Tp> acos(const interval<_Tp>&);

template<typename _Tp>
  interval<_Tp> atan(const interval<_Tp>&);

template<typename _Tp>
  interval<_Tp> sinh(const interval<_Tp>&);

template<typename _Tp>
  interval<_Tp> cosh(const interval<_Tp>&);

template<typename _Tp>
  interval<_Tp> tanh(const interval<_Tp>&);

template<typename _Tp>
  interval<_Tp> asinh(const interval<_Tp>&);

template<typename _Tp>
  interval<_Tp> acosh(const interval<_Tp>&);

template<typename _Tp>
  interval<_Tp> atanh(const interval<_Tp>&);


template<typename _Tp, typename _CharT,
	 typename _Traits = std::char_traits<_CharT>>
  std::basic_ostream<_CharT, _Traits>&
  operator<<(std::basic_ostream<_CharT, _Traits>& __os, const interval<_Tp>& __ivl)
  {
    std::basic_ostringstream<_CharT, _Traits> __s;
    __s.flags(__os.flags());
    __s.imbue(__os.getloc());
    __s.precision(__os.precision());
    __s << '[' << __ivl.upper() << ',' << __ivl.lower() << ']';
    return __os << __s.str();
  }

template<typename _Tp, typename _CharT,
	 typename _Traits = std::char_traits<_CharT>>
  std::basic_istream<_CharT, _Traits>&
  operator>>(std::basic_istream<_CharT, _Traits>& __is, interval<_Tp>& __ivl)
  {
    bool __fail = true;
    _CharT __ch;
    if (__is >> __ch)
      {
	if (_Traits::eq(__ch, __is.widen('[')))
	  {
	    _Tp __u;
	    if (__is >> __u >> __ch)
	      {
		const _CharT __rbrace = __is.widen(']');
		if (_Traits::eq(__ch, __rbrace))
		  {
		    __ivl = __u;
		    __fail = false;
		  }
		else if (_Traits::eq(__ch, __is.widen(',')))
		  {
		    _Tp __v;
		    if (__is >> __v >> __ch)
		      {
			if (_Traits::eq(__ch, __rbrace))
			  {
			    __ivl = interval<_Tp>(__u, __v);
			    __fail = false;
			  }
			else
			  __is.putback(__ch);
		      }
		  }
		else
		  __is.putback(__ch);
	      }
	  }
	else
	  {
	    __is.putback(__ch);
	    _Tp __u;
	    if (__is >> __u)
	      {
		__ivl = __u;
		__fail = false;
	      }
	  }
      }
    if (__fail)
      __is.setstate(std::ios_base::failbit);
    return __is;
  }

template<typename _FloatTp>
  inline interval<_FloatTp>&
  interval<_FloatTp>::operator+=(const interval<_FloatTp>& __a)
  {
    fpdown();
    this->_M_lower += __a.lower();
    fpup();
    this->_M_upper += __a.upper();
    fpnear();
    return *this;
  }

template<typename _FloatTp>
  inline interval<_FloatTp>&
  interval<_FloatTp>::operator-=(const interval<_FloatTp>& __a)
  {
    fpdown();
    this->_M_lower -= __a.upper();
    fpup();
    this->_M_upper -= __a.lower();
    fpnear();
    return *this;
  }

// Works all other classes.
// Please note that this is for all interger classes. interval<int>, interval<long>,
// were there is no loss of precision
// Instead of doing
//   lo = min(lo*a.up, lo*a.lo, up*a.lo, up*a.up)
//   up = max(lo*a.up, lo*a.lo, up*a.lo, up*a.up)
// requiring a total of 8 multiplications
// do the logic instead:
//   lo, up, a.lo, a.up    result
//    +      +	      +        +       +  +  [ lo*a.lo, up*a.up ]
//    +      +	      -        +       -  +  [ up*a.lo, up*a.up ]
//    +      +	      -        -       -  -  [ up*a.lo, lo*a.up ]
//    -      +	      +        +       -  +  [ lo*a.up, up*a.up ]
//    -      +	      -        +       -  +  [ min(lo*a.up, up*a.lo),
//                                             max(lo*a.lo, up*a.up) ]
//    -      +	      -        -       -  -  [ up*a.lo, lo*a.lo ]
//    -      -	      +        +       -  -  [ lo*a.up, up*a.lo ]
//    -      -	      -        +       -  -  [ lo*a.up, lo*a.lo ]
//    -      -	      -        -       +  +  [ up*a.up, lo*a.lo ]
//
template<typename _FloatTp>
  inline interval<_FloatTp>&
  interval<_FloatTp>::operator*=(const interval<_FloatTp>& __a)
  {
    _FloatTp __lo, __up;

    if (this->_M_lower >= 0)
      { // both lower and upper >= 0
	if (__a.lower() >= 0)
	  { // a.lower >=0, a.upper >= 0
	    fpdown();
	    __lo = this->_M_lower * __a.lower();
	    fpup();
	    __up = this->_M_upper * __a.upper();
	  }
	else if (__a.upper() >= 0)
	  { // a.lower < 0, a.upper >= 0
	    fpdown();
	    __lo = this->_M_upper * __a.lower();
	    fpup();
	    __up = this->_M_upper * __a.upper();
	  }
	else
	  { // a.lower and a.upper < 0
	    fpdown();
	    __lo = this->_M_upper * __a.lower();
	    fpup();
	    __up = this->_M_lower * __a.upper();
	  }
      }
    else if (this->_M_upper >= 0)
      { // lower < 0, upper >= 0
	if (__a.lower() >= 0)
	  { // a.lower >=0, a.upper >= 0
	    fpdown();
	    __lo = this->_M_lower * __a.upper();
	    fpup();
	    __up = this->_M_upper * __a.upper();
	  }
	else if (__a.upper() >= 0)
	  { // a.lower < 0, a.upper >= 0
	    fpdown();
	    __lo = this->_M_lower * __a.upper();
	    if (auto __t = this->_M_upper * __a.lower(); __lo > __t)
	      __lo = __t;
	    fpup();
	    __up = this->_M_upper * __a.upper();
	    if (auto __t = this->_M_lower * __a.lower(); __up < __t)
	      __up = __t;
	  }
	else
	  { // a.lower and a.upper < 0
	    fpdown();
	    __lo = this->_M_upper * __a.lower();
	    fpup();
	    __up = this->_M_lower * __a.lower();
	  }
      }
    else
      { // lower and upper are < 0
	if (__a.lower() >= 0)
	  { // a.lower >=0, a.upper >= 0
	    fpdown();
	    __lo = this->_M_lower * __a.upper();
	    fpup();
	    __up = this->_M_upper * __a.lower();
	  }
	else if (__a.upper() >= 0)
	  { // a.lower < 0, a.upper >= 0
	    fpdown();
	    __lo = this->_M_lower * __a.upper();
	    fpup();
	    __up = this->_M_lower * __a.lower();
	  }
	else
	  { // a.lower and a.upper < 0
	    fpdown();
	    __lo = this->_M_upper * __a.upper();
	    fpup();
	    __up = this->_M_lower * __a.lower();
	  }
      }

    this->_M_lower = __lo;
    this->_M_upper = __up;

    fpnear();

    return *this;
  }

// Works for all other classes
// Please note that this is for all interger classes. interval<int>, interval<long>
// were there is no loss of precision
// Actually there is specialization for both <int>
template<typename _FloatTp>
  inline interval<_FloatTp>&
  interval<_FloatTp>::operator/=(const interval<_FloatTp>& __b)
  {
    interval<_FloatTp> __c;

    fpdown();
    __c._M_lower = _FloatTp{1} / __b.upper();
    fpup();
    __c._M_upper = _FloatTp{1} / __b.lower();
    fpnear();
    auto __a = interval(this->_M_lower, this->_M_upper);
    __c *= __a;

    this->_M_lower = __c.lower();
    this->_M_upper = __c.upper();

    return *this;
  }

// Specialization for int and /=
//
template<>
  inline interval<int>&
  interval<int>::operator/=(const interval<int>& __b)
  {
    long double tlow, thigh;
    interval<int> __a;
    interval<long double> __c;

    tlow = 1 / static_cast<long double>(__b.upper());
    thigh = 1 / static_cast<long double>(__b.lower());

    __a = interval(this->_M_lower, this->_M_upper);
    __c = interval<long double>(tlow, thigh);
    __c *= __a;

    this->_M_lower = int(std::floor(__c.lower()));
    this->_M_upper = int(std::ceil(__c.upper()));

    return *this;
  }

// Return the intersection
template<typename _FloatTp>
  inline interval<_FloatTp>&
  interval<_FloatTp>::operator&=(const interval<_FloatTp>& __a)
  {
    if (__a.lower() > this->_M_lower)
      this->_M_lower = __a.lower();
    if (__a.upper() < this->_M_upper)
      this->_M_upper = __a.upper();
    if (this->_M_lower > this->_M_upper) // Empty set
      {
	this->_M_lower = 0;
	this->_M_upper = 0;
      }

    return *this;
  }

// Return the union
template<typename _FloatTp>
  inline interval<_FloatTp>&
  interval<_FloatTp>::operator|=(const interval<_FloatTp>& __a)
  {
    if (this->_M_lower > __a.upper() || this->_M_upper < __a.lower())
      {
	if (__a.upper() - __a.lower() > this->_M_upper - this->_M_lower)
	  { // return the largest set
	    this->_M_lower = __a.lower();
	    this->_M_upper = __a.upper();
	  }
      }
    else
      { // non empty intersection
	if (__a.lower() < this->_M_lower)
	  this->_M_lower = __a.lower();
	if (__a.upper() > this->_M_upper)
	  this->_M_upper = __a.upper();
      }

    return *this;
  }

	
// Return the set minus
template<typename _FloatTp>
  inline interval<_FloatTp>&
  interval<_FloatTp>::operator^=(const interval<_FloatTp>& __a)
  {
    if (__a.lower() < this->_M_upper && __a.upper() > this->_M_lower)
      { // intersection is not empty
	if (__a.upper() <= this->_M_lower)
	  this->_M_lower = __a.upper();
	else if (__a.upper() >= this->_M_upper)
	  this->_M_upper = __a.lower();
      }

    return *this;
  }

template<typename _FloatTp,class _X>
  inline interval<_FloatTp>
  operator+(const interval<_FloatTp>& __a, const _X& __b)
  {
    interval<_FloatTp> __c(__a);

    __c += interval<_FloatTp>(_FloatTp(__b));
    return __c;
  }

template<typename _FloatTp,class _X>
  inline interval<_FloatTp>
  operator+(const _X& __a, const interval<_FloatTp>& __b)
  {
    interval<_FloatTp> __c(__b);
    return __c += interval<_FloatTp>(_FloatTp(__a));
  }

template<typename _FloatTp>
  inline interval<_FloatTp>
  operator+(const interval<_FloatTp>& __a, const interval<_FloatTp>& __b)
  {
    interval<_FloatTp> __c(__a);
    return __c += __b;
  }

template<typename _FloatTp>
   inline interval<_FloatTp>
   operator+(const interval<_FloatTp>& __a)
   { return __a; }

template<typename _FloatTp, typename _X>
  inline interval<_FloatTp>
  operator-(const interval<_FloatTp>& __a, const _X& __b)
  {
    interval<_FloatTp> __c(__a);
    return __c -= interval<_FloatTp>(_FloatTp(__b));
  }

template<typename _FloatTp, typename _X>
  inline interval<_FloatTp>
  operator-(const _X& __a, const interval<_FloatTp>& __b)
  {
    interval<_FloatTp> __c(__a);
    return __c -= __b;
  }

template<typename _FloatTp>
  inline interval<_FloatTp>
  operator-(const interval<_FloatTp>& __a, const interval<_FloatTp>& __b)
  {
    interval<_FloatTp> __c(__a);
    return __c -= __b;
  }

template<typename _FloatTp> inline interval<_FloatTp>
  operator-(const interval<_FloatTp>& __a)
  {
    interval<_FloatTp> __c(0);
    return __c -= __a;
  }

template<typename _FloatTp, typename _X>
  inline interval<_FloatTp>
  operator*(const interval<_FloatTp>& __a, const _X& __b)
  {
    interval<_FloatTp> __c(__a);
    return __c *= interval<_FloatTp>(_FloatTp(__b));
  }

template<typename _FloatTp, typename _X>
  inline interval<_FloatTp>
  operator*(const _X& __a, const interval<_FloatTp>& __b)
  {
    interval<_FloatTp> __c(__b);
    return __c *= interval<_FloatTp>(_FloatTp(__a));
  }

template<typename _FloatTp>
  inline interval<_FloatTp>
  operator*(const interval<_FloatTp>& __a, const interval<_FloatTp>& __b)
  {
    interval<_FloatTp> __c(__a);
    return __c *= __b;
  }

template<typename _FloatTp, typename _X>
  inline interval<_FloatTp>
  operator/(const interval<_FloatTp>& __a, const _X& __b)
  {
    interval<_FloatTp> __c(__a);
    return __c /= interval<_FloatTp>(_FloatTp(__b));
  }

template<typename _FloatTp, typename _X>
  inline interval<_FloatTp>
  operator/(const _X& __a, const interval<_FloatTp>& __b)
  {
    interval<_FloatTp> __c(__a);
    return __c /= __b;
  }

template<typename _FloatTp>
  inline interval<_FloatTp>
  operator/(const interval<_FloatTp>& __a, const interval<_FloatTp>& __b)
  {
    interval<_FloatTp> __c(__a);

    if (__c == __b && __b.is_class() != ZERO)
      __c = interval<_FloatTp>(1,1);
    else
      __c /= __b;

    return __c;
  }

template<typename _FloatTp>
  inline interval<_FloatTp>
  operator&(const interval<_FloatTp>& __a, const interval<_FloatTp>& __b)
  {
    interval<_FloatTp> __c(__a);
    return __c &= __b;
  }

template<typename _FloatTp>
  inline interval<_FloatTp>
  operator|(const interval<_FloatTp>& __a, const interval<_FloatTp>& __b)
  {
    interval<_FloatTp> __c(__a);
    return __c |= __b;
  }

template<typename _FloatTp>
  inline interval<_FloatTp>
  operator^(const interval<_FloatTp>& __a, const interval<_FloatTp>& __b)
  {
    interval<_FloatTp> __c(__a);
    return __c ^= __b;
  }


template<typename _FloatTp, typename _X>
  inline bool
  operator==(const interval<_FloatTp>& __a, const _X& __b)
  {
    interval<_FloatTp> __c(__b);
    return __c.lower() == __a.lower() && __c.upper() == __a.upper();
  }

template<typename _FloatTp, typename _X>
  inline bool
  operator==(const _X& __a, const interval<_FloatTp>& __b)
  {
    interval<_FloatTp> __c(__a);
    return __c.lower() == __b.lower() && __c.upper() == __b.upper();
  }

template<typename _FloatTp1, typename _FloatTp2>
  inline bool
  operator==(const interval<_FloatTp1>& __a, const interval<_FloatTp2>& __b)
  {
    return __a.lower() == __b.lower() && __a.upper() == __b.upper();
  }


template<typename _FloatTp, typename _X>
  inline bool
  operator!=(const interval<_FloatTp>& __a, const _X& __b)
  {
    interval<_FloatTp> __c(__b);
    return __c.lower() != __a.lower() || __c.upper() != __a.upper();
  }

template<typename _FloatTp, typename _X>
  inline bool
  operator!=(const _X& __a, const interval<_FloatTp>& __b)
  {
    interval<_FloatTp> __c(__a);
    return __c.lower() != __b.lower() || __c.upper() != __b.upper();
  }

template<typename _FloatTp1, typename _FloatTp2>
  inline bool
  operator!=(const interval<_FloatTp1>& __a, const interval<_FloatTp2>& __b)
  { return __a.lower() != __b.lower() || __a.upper() != __b.upper(); }


template<typename _FloatTp>
  inline interval<_FloatTp>
  abs(const interval<_FloatTp>& __a)
  {
    if (__a.lower() >= _FloatTp{0})
      return __a;
    else if (__a.upper() <= _FloatTp{0})
      return -__a;
    else
      return interval<_FloatTp>(_FloatTp{0}, (__a.upper() > -__a.lower() ? __a.upper() : -__a.lower()));
  }


inline double
ln2double(fpround __rm)
{
  long double __res = 2;

  round_sentinel __rs(__rm);

  //FIXME!
  __res = std::log(__res);

  return __res;
}

// Log(10) for double
inline double
ln10double(fpround __rm)
{
  long double __res = 10;

  round_sentinel __rs(__rm);

  //FIXME!
  __res = std::log(__res);

  return __res;
}

// PI for double
inline double
pidouble(fpround __rm)
{
  long double __res = 1;

  round_sentinel __rs(__rm);

  //FIXME!
  __res = 4 * std::atan(__res);

  return __res;
}

template<typename _FloatTp>
  inline interval<_FloatTp>
  sqrt(const interval<_FloatTp>& x)
  {
    auto __lo = sqrt(x.lower(), fpround::downward);
    auto __up = sqrt(x.upper(), fpround::upward);
    return interval<_FloatTp>(__lo, __up);
  }


template<typename _FloatTp>
  inline interval<_FloatTp>
  log(const interval<_FloatTp>& x)
  {
    auto __lo = log(x.lower(), fpround::downward);
    auto __up = log(x.upper(), fpround::upward);
    return interval<_FloatTp>(__lo, __up);
  }

template<typename _FloatTp>
  inline interval<_FloatTp>
  log10(const interval<_FloatTp>& x)
  {
    auto __lo = log10(x.lower(), fpround::downward);
    auto __up = log10(x.upper(), fpround::upward);
    return interval<_FloatTp>(__lo, __up);
  }


template<typename _FloatTp>
  inline interval<_FloatTp>
  exp(const interval<_FloatTp>& x)
  {
    auto __lo = log10(x.lower(), fpround::downward);
    auto __up = log10(x.upper(), fpround::upward);
    return interval<_FloatTp>(__lo, __up);
  }

template<typename _FloatTp>
  inline interval<_FloatTp>
  pow(const interval<_FloatTp>& x, const _FloatTp y)
  {
    interval<_FloatTp> __c;

    // FIXME! This blows.
    __c = std::log(x);
    __c *= interval<_FloatTp>(y);
    __c = std::exp(__c);

    return __c;
  }

template<typename _Float>
  inline interval<_Float>
  sin(const interval<_Float>& x)
  {
    auto __lo = sin(x.lower(), fpround::downward);
    auto __up = sin(x.upper(), fpround::upward);
    return interval<float>(__lo, __up);
  }

template<typename _Float>
  inline interval<_Float>
  cos(const interval<_Float>& x)
  {
    auto __lo = cos(x.lower(), fpround::downward);
    auto __up = cos(x.upper(), fpround::upward);
    return interval<float>(__lo, __up);
  }

template<typename _Float>
  inline interval<_Float>
  tan(const interval<_Float>& x)
  {
    auto __lo = tan(x.lower(), fpround::downward);
    auto __up = tan(x.upper(), fpround::upward);
    return interval<float>(__lo, __up);
  }

template<typename _Float>
  inline interval<_Float>
  atan(const interval<_Float>& x)
  {
    auto __lo = atan(x.lower(), fpround::downward);
    auto __up = atan(x.upper(), fpround::upward);
    return interval<float>(__lo, __up);
  }

///   Use a Taylor series until their is no more change in the result
///   asin(x) == x + x^3/(2*3)+(1*3)x^5/(2*4*5)+(1*3*5)x^7/(2*4*6*7)....
///   Use argument reduction via the identity arcsin(x)=2arcsin(x)/(sqrt(2)+sqrt(1-x*x))
//	  This function replace the other function using Newton iteration. Taylor series is significant
//    faster e.g 50% for 10 digits, 3x for 100 digits and 5x for 1000 digits.
//
inline interval<double>
asin(const interval<double>& x)
{
  int __k, __sign;
  interval<double> __r, __u, __v, __v2, sqrt2;
  const double c1(1), c2(2);

  if (x.lower() >= c1 || x.upper() <= -c1)
    throw std::domain_error("asin");

  __v = x;
  if (__v.lower() < -c1)
    __v.lower(-c1);
  if (__v.upper() > c1)
    __v.upper(c1);

  __sign = __v.is_class();
  if (__sign == NEGATIVE)
    __v = -__v;

  // Now use the identity arcsin(x)=2arcsin(x)/(sqrt(2)+sqrt(1-x*x))
  // until argument is less than dlimit
  // Reduce the argument to below 0.5 to make the Newton run faster
  sqrt2 = interval<double>(c2);  // Ensure correct number of digits
  sqrt2 = sqrt(sqrt2);	// Now calculate sqrt2 with precision digits
  for (__k = 0; __v.lower() > 0.5; ++__k)
    __v /= sqrt2 * sqrt(interval<double>(c1)
			+ sqrt(interval<double>(c1) - __v * __v));

  __v2 = __v * __v;
  __r = __v;
  __u = __v;
  // Now iterate using Taylor expansion
  for (unsigned int __j = 3; ; __j += 2)
    {
      auto __uc = interval<double>((__j - 2) * (__j - 2));
      auto __lc = interval<double>(__j * __j - __j);
      __v = __uc * __v2 / __lc;
      __r *= __v;
      if (__u.lower() + __r.lower() == __u.lower()
	  || __u.upper() + __r.upper() == __u.upper())
	break;
      __u += __r;
    }

  if (__k > 0)
    __u *= interval<double>(1 << __k);

  if (__sign == NEGATIVE)
    __u = -__u;

  return __u;
}

inline interval<float>
asin(const interval<float>& x)
{
  interval<double> asin(const interval<double>&);
  interval<double> fx(x);

  fx = asin(fx);
  auto __lo = to_float(fx.lower(), fpround::downward);
  auto __up = to_float(fx.upper(), fpround::upward);
  return interval<float>(__lo, __up);
}

inline interval<double>
acos(const interval<double>& x)
{
  interval<double> pi, __res;
  const double c1(1);

  if (x.lower() >= c1 || x.upper() <= -c1)
    throw std::domain_error("acos");

  pi.lower(pidouble(fpround::downward));
  pi.upper(pidouble(fpround::upward));
  __res = pi * interval<double>(0.5) - asin(x);
  return __res;
}


inline interval<float>
acos(const interval<float>& x)
{
  interval<double> acos(const interval<double>&);
  interval<double> fx(x);

  fx = acos(fx);
  auto __lo = to_float(fx.lower(), fpround::downward);
  auto __up = to_float(fx.upper(), fpround::upward);
  return interval<float>(__lo, __up);
}


template<typename _Float>
  inline interval<_Float>
  sinh(const interval<_Float>& x)
  {
    auto __lo = sinh(x.lower(), fpround::downward);
    auto __up = sinh(x.upper(), fpround::upward);
    return interval<float>(__lo, __up);
  }

template<typename _Float>
  inline interval<_Float>
  cosh(const interval<_Float>& x)
  {
    auto __lo = cosh(x.lower(), fpround::downward);
    auto __up = cosh(x.upper(), fpround::upward);
    return interval<float>(__lo, __up);
  }

template<typename _Float>
  inline interval<_Float>
  tanh(const interval<_Float>& x)
  {
    auto __lo = tanh(x.lower(), fpround::downward);
    auto __up = tanh(x.upper(), fpround::upward);
    return interval<float>(__lo, __up);
  }

#endif // INTERVAL
