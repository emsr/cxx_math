#ifndef INTERVAL
#define INTERVAL 1

#include <cfloat>
#include <algorithm>

/*
TODO: RAII sentinel for rounding direction.  dtor reverts no nearest.
TODO: Try to use fenv and other standard things.

*/

// By default HARDWARE_SUPPORT controlled if IEEE754 floating point control can be used for interval arithmetic.
// The intervaldouble.h requires this to be defined.
#define HARDWARE_SUPPORT

/// The four different interval classification
/// # ZERO	a=0 && b=0
/// # POSITIVE	a>=0 && b>0
/// # NEGATIVE	a<0 && b<=0
/// # MIXED	a<0 && b>0
enum int_class { NO_CLASS, ZERO, POSITIVE, NEGATIVE, MIXED };

/// The four different ronding modes
/// # ROUND_NEAR  Rounded result is the closest to the infinitely precise result.
/// # ROUND_DOWN  Rounded result is close to but no greater than the infinitely precise result.
/// # ROUND_UP    Rounded result is close to but no less than the infinitely precise result.
/// # ROUND ZERO  Rounded result is close to but no greater in absolute value than the infinitely precise result.
enum round_mode { ROUND_NEAR, ROUND_UP, ROUND_DOWN, ROUND_ZERO };

//
// Interval class
//
template<typename _FloatTp>
  class interval
  {
    _FloatTp _M_lower;
    _FloatTp _M_upper;

  public:

    typedef _FloatTp value_type;

    // constructor. zero, one or two arguments for type _FloatTp
    interval()
    : _M_lower{0}, _M_upper = _FloatTp(0);
    { }

    interval(const _FloatTp& d)
    { _M_lower = _FloatTp(d); _M_upper = _FloatTp(d); }

    interval(const _FloatTp& l, const _FloatTp& h)
    {
      if (l < h)
	{
	  _M_lower = l;
	  _M_upper = h;
	}
      else
	{
	  _M_lower = h;
	  _M_upper = l;
	}
    }

    // Constrcutor for mixed type _FloatTp != _X (base types).
    // Allows auto construction of e.g. interval<float_precision> x(float)
    template<typename _X>
      interval(const _X& x)
      { _M_lower = _FloatTp(x); _M_upper = _FloatTp(x); }

    // constructor for any other type to _FloatTp. Both up and down conversion possible
    template<typename X>
      interval(const interval<X>& a)
      {
	if (a.lower() < a.upper())
          {
	    fpdown();
	    _M_lower = _FloatTp(a.lower());
	    fpup();
	    _M_upper = _FloatTp(a.upper());
	    fpnear();
	  }
	else
	  {
	    fpdown();
	    _M_lower = _FloatTp(a.upper());
	    fpup();
	    _M_upper = _FloatTp(a.lower());
	    fpnear();
	  }
      }
	
    // Coordinate functions
    _FloatTp upper() const
    { return _M_upper; }

    _FloatTp lower() const
    { return _M_lower; }

    _FloatTp
    upper(const _FloatTp& u)
    { return (_M_upper = u); }

    _FloatTp
    lower(const _FloatTp& l)
    { return (_M_lower = l); }


    _FloatTp
    center() const
    { return (_M_upper + _M_lower) / _FloatTp(2); }

    _FloatTp
    radius() const
    {
      auto r = (_M_upper - _M_lower) / _FloatTp(2);
      if (r < _FloatTp(0))
        r = -r;
      return r;
    }

    _FloatTp
    width() const
    { _FloatTp r; r = _M_upper - _M_lower; if (r < _FloatTp(0)) r = -r; return r; }
	
    bool
    contain_zero() const
    { return _M_lower <= _FloatTp(0) && _FloatTp(0) <= _M_upper; }  // Obsolete. use contains() instead.
    bool
    contain(const _FloatTp& f=_FloatTp(0))
    { return _M_lower <= f && f <= _M_upper;  }
    bool contain(const interval<_FloatTp>& i) { return _M_lower <= i.lower() && i.upper() <= _M_upper; }
    bool is_empty() const				{ return _M_upper < _M_lower; }
	
    enum int_class is_class() const	{
										if (_M_lower == _FloatTp(0) && _M_upper == _FloatTp(0)) return ZERO;
										if (_M_lower >= _FloatTp(0) && _M_upper > _FloatTp(0)) return POSITIVE;
										if (_M_lower < _FloatTp(0) && _M_upper <= _FloatTp(0)) return NEGATIVE;
										if (_M_lower < _FloatTp(0) && _M_upper > _FloatTp(0)) return MIXED;
										return NO_CLASS;
										}

    // Operators
    operator short() const
    { return (short)((_M_upper + _M_lower) / _FloatTp(2)); }				// Conversion to short 	
    operator int() const
    { return (int)center() /*((_M_upper + _M_lower) / _FloatTp(2))*/; }			// Conversion to int
    operator long() const
    { return (long)((_M_upper + _M_lower) / _FloatTp(2)); }				// Conversion to long
    operator unsigned short() const
    { return (unsigned short)((_M_upper + _M_lower) / _FloatTp(2)); }		// Conversion to unsigned short 	
    operator unsigned int() const
    { return (unsigned int)((_M_upper + _M_lower) / _FloatTp(2)); }		// Conversion to unsigned int
    operator unsigned long() const
    { return (unsigned long)((_M_upper + _M_lower) / _FloatTp(2)); }		// Conversion to unsigned long
    operator double() const
    { return (double)((_M_upper + _M_lower) / _FloatTp(2)); }			// Conversion to double
    operator float() const
    { return _M_upper == _M_lower? (float)_M_lower : (float)((_M_upper + _M_lower) / _FloatTp(2)); }				// Conversion to float

    _FloatTp*
    ref_lower()
    { return &_M_lower; }

    _FloatTp*
    ref_upper()
    { return &_M_upper; }

    // Essential operators
    interval<_FloatTp>& operator= (const interval<_FloatTp>&);
    interval<_FloatTp>& operator+=(const interval<_FloatTp>&);
    interval<_FloatTp>& operator-=(const interval<_FloatTp>&);
    interval<_FloatTp>& operator*=(const interval<_FloatTp>&);
    interval<_FloatTp>& operator/=(const interval<_FloatTp>&);
    interval<_FloatTp>& operator&=(const interval<_FloatTp>&);
    interval<_FloatTp>& operator|=(const interval<_FloatTp>&);
    interval<_FloatTp>& operator^=(const interval<_FloatTp>&);
	
	  // Exception class. No used
	  class bad_int_syntax {};
	  class bad_float_syntax {};
	  class out_of_range   {};
	  class divide_by_zero {};
	  class domain_error   {};
	  class base_error		{};
   };


// Unary and Binary arithmetic
// Arithmetic + Binary and Unary
template<typename _FloatTp, typename _X> interval<_FloatTp> operator+(const interval<_FloatTp>&, const _X&);
template<typename _FloatTp, typename _X> interval<_FloatTp> operator+(const _X&, const interval<_FloatTp>&);
template<typename _FloatTp> interval<_FloatTp> operator+(const interval<_FloatTp>&, const interval<_FloatTp>&);
template<typename _FloatTp> interval<_FloatTp> operator+(const interval<_FloatTp>&);									// Unary

// Arithmetic - Binary and Unary
template<typename _FloatTp, typename _X> interval<_FloatTp> operator-(const interval<_FloatTp>&, const _X&);
template<typename _FloatTp, typename _X> interval<_FloatTp> operator-(const _X&, const interval<_FloatTp>&);
template<typename _FloatTp> interval<_FloatTp> operator-(const interval<_FloatTp>&, const interval<_FloatTp>&);
template<typename _FloatTp> interval<_FloatTp> operator-(const interval<_FloatTp>&);									// Unary

// Arithmetic * Binary
template<typename _FloatTp, typename _X> interval<_FloatTp> operator*(const interval<_FloatTp>&, const _X&);
template<typename _FloatTp, typename _X> interval<_FloatTp> operator*(const _X&, const interval<_FloatTp>&);
template<typename _FloatTp> interval<_FloatTp> operator*(const interval<_FloatTp>&, const interval<_FloatTp>&);

// Arithmetic / Binary
template<typename _FloatTp, typename _X> interval<_FloatTp> operator/(const interval<_FloatTp>&, const _X&);
template<typename _FloatTp, typename _X> interval<_FloatTp> operator/(const _X&, const interval<_FloatTp>&);
template<typename _FloatTp> interval<_FloatTp> operator/(const interval<_FloatTp>&, const interval<_FloatTp>&);

// Boolean Comparison Operators
template<typename _FloatTp, typename _X> bool operator==(const interval<_FloatTp>&, const _X&);
template<typename _FloatTp, typename _X> bool operator==(const _X&, const interval<_FloatTp>&);
template<typename _FloatTp, typename _X> bool operator==(const interval<_FloatTp>&, const interval<_X>&);
//template<typename _FloatTp> bool operator==(const interval<_FloatTp>&, const interval<_FloatTp>&);

template<typename _FloatTp, typename _X> bool operator!=(const interval<_FloatTp>&, const _X&);
template<typename _FloatTp, typename _X> bool operator!=(const _X&, const interval<_FloatTp>&);
template<typename _FloatTp, typename _X> bool operator!=(const interval<_FloatTp>&, const interval<_X>&);
//template<typename _FloatTp> bool operator!=(const interval<_FloatTp>&, const interval<_FloatTp>&);

// Other functions
template<typename _FloatTp> interval<_FloatTp> abs(const interval<_FloatTp>&);

// Manifest Constants like PI, LN2 and LN10
inline interval<float> int_pifloat();
inline interval<double> int_pidouble();
inline interval<float> int_ln2float();
inline interval<double> int_ln2double();
inline interval<float> int_ln10float();
inline interval<double> int_ln10double();

// Elementary functions
inline interval<float> sqrt(const interval<float>&);
inline interval<double> sqrt(const interval<double>&);
inline interval<float> log(const interval<float>&);
inline interval<double> log(const interval<double>&);
inline interval<float> log10(const interval<float>&);
inline interval<double> log10(const interval<double>&);
inline interval<float> exp(const interval<float>&, const float);
inline interval<double> exp(const interval<double>&, const double);
inline interval<float> pow(const interval<float>&, const float);
inline interval<double> pow(const interval<double>&, const double);

// Trigonometric functions
inline interval<float> sin(const interval<float>&);
inline interval<double> sin(const interval<double>&);
inline interval<float> cos(const interval<float>&);
inline interval<double> cos(const interval<double>&);
inline interval<float> tan(const interval<float>&);
inline interval<double> tan(const interval<double>&);
inline interval<float> asin(const interval<float>&);
inline interval<double> asin(const interval<double>&);
inline interval<float> acos(const interval<float>&);
inline interval<double> acos(const interval<double>&);
inline interval<float> atan(const interval<float>&);
inline interval<double> atan(const interval<double>&);

/////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
//	Floating point control for the IEEE754 hardware. Only fo non managed application
//	Enable by defined #define HARDWARE_SUPPORT
//  Currently it only works with HARDWARE_SUPPORT defined.
//
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifdef HARDWARE_SUPPORT
inline void
fpnear()
{
  unsigned int f87_cw, sse2_cw;
  int cc;
  //_controlfp_s(&currentControl, _RC_NEAR, _MCW_RC);
  cc=__control87_2(_RC_NEAR, _MCW_RC, &f87_cw, &sse2_cw);
}

inline void
fpdown()
{
  unsigned int f87_cw, sse2_cw;
  int cc;
  //_controlfp_s(&currentControl, _RC_DOWN, _MCW_RC);
  cc=__control87_2(_RC_DOWN, _MCW_RC, &f87_cw, &sse2_cw);
}

inline void
fpup()
{
  unsigned int f87_cw, sse2_cw;
  int cc;
  //_controlfp_s(&currentControl, _RC_UP, _MCW_RC);
  cc=__control87_2(_RC_UP, _MCW_RC, &f87_cw, &sse2_cw);
}
#else
inline void fpnear()	{}
inline void fpdown()	{}
inline void fpup()		{}
#endif


template<typename _Ty> inline std::ostream& operator<<(std::ostream& strm, interval<_Ty>& a)
{ return strm << "[" << a.lower() << "," << a.upper() << "]"; }

template<typename _Ty> inline std::istream& operator>>(std::istream& strm, interval<_Ty>& c)
   {
   _Ty l, u; char ch;
   if(strm >> ch && ch != '[')
      strm.putback(ch), strm >> l, u = l;
	else
      if(strm >> l >> ch && ch != ',')
	      if(ch == ']')
	         u = l;
	      else
            strm.putback(ch); // strm.setstate(std::ios::failbit);
	   else
         if(strm >> u >> ch && ch != ']')
	         strm.putback(ch); //, strm.setstate(ios_base::failbit);
	
   if(!strm.fail())
	   c = interval<_Ty>(l, u);

   return strm;
   }

template<typename _FloatTp>
  inline interval<_FloatTp>&
  interval<_FloatTp>::operator=(const interval<_FloatTp>& a)
  {
    _M_lower = a.lower();
    _M_upper = a.upper();
    return *this;
  }

template<typename _FloatTp>
  inline interval<_FloatTp>&
  interval<_FloatTp>::operator+=(const interval<_FloatTp>& a)
  {
    fpdown();
    _M_lower += a.lower();
    fpup();
    _M_upper += a.upper();
    fpnear();
    return *this;
  }

template<typename _FloatTp>
  inline interval<_FloatTp>&
  interval<_FloatTp>::operator-=(const interval<_FloatTp>& a)
  {
    fpdown();
    _M_lower -= a.upper;
    fpup();
    _M_upper -= a.lower;
    fpnear();
    return *this;
  }

// Works all other classes.
// Please note that this is for all interger classes. interval<int>, interval<long>,
// were there is no loss of precision
// Instead of doing the mindless lower = MIN(lower*a.upper, lower*a.lower,upper*a.lower,upper*a.upper) and
// upper = MAX(lower*a.upper, lower*a.lower,upper*a.lower,upper*a.upper) requiring a total of 8 multiplication
//
//   lower, upper, a.lower, a.upper    result
//    +      +	      +        +       +  +  [ lower*a.lower, upper*a.upper ]
//    +      +	      -        +       -  +  [ upper*a.lower, upper*a.upper ]
//    +      +	      -        -       -  -  [ upper*a.lower, lower*a.upper ]
//    -      +	      +        +       -  +  [ lower*a.upper, upper*a.upper ]
//    -      +	      -        +       -  +  [ MIN(lower*a.upper,upper*a.lower), MAX(lower*a.lower,upper*a.upper) ]
//    -      +	      -        -       -  -  [ upper*a.lower, lower*a.lower ]
//    -      -	      +        +       -  -  [ lower*a.upper, upper*a.lower ]
//    -      -	      -        +       -  -  [ lower*a.upper, lower*a.lower ]
//    -      -	      -        -       +  +  [ upper*a.upper, lower*a.lower ]
//
template<typename _FloatTp>
  inline interval<_FloatTp>&
  interval<_FloatTp>::operator*=(const interval<_FloatTp>& a)
  {
    _FloatTp l, h, t;

    if (_M_lower >= 0)
      { // both lower and upper >= 0
	if (a.lower() >= 0)
	  { // a.lower >=0, a.upper >= 0
	    fpdown();
	    l = _M_lower * a.lower();
	    fpup();
	    h = _M_upper * a.upper();
	  }
	else if (a.upper() >= 0)
	  { //  a.lower < 0, a.upper >= 0
	    fpdown();
	    l = _M_upper * a.lower();
	    fpup();
	    h = _M_upper * a.upper();
	  }
	else
	  { // a.lower and a.upper < 0
	    fpdown();
	    l = _M_upper * a.lower();
	    fpup();
	    h = _M_lower * a.upper();
	  }
      }
    else if (upper >= 0)
      { // lower < 0, upper >= 0
	if (a.lower() >= 0)
	  { // a.lower >=0, a.upper >= 0
	    fpdown();
	    l = _M_lower * a.upper();
	    fpup();
	    h = _M_upper * a.upper();
	  }
	else if (a.upper() >= 0)
	  { // a.lower < 0, a.upper >= 0
	    fpdown();
	    l = _M_lower * a.upper(); if (l > (t = _M_upper * a.lower())) l = t;
	    fpup();
	    h = _M_upper * a.upper(); if (h < (t = _M_lower * a.lower())) h = t;
	  }
	else
	  { // a.lower and a.upper < 0
	    fpdown();
	    l = _M_upper * a.lower();
	    fpup();
	    h = _M_lower * a.lower();
	  }
      }
    else
      { // lower and upper are < 0
	if (a.lower() >= 0)
	  { // a.lower >=0, a.upper >= 0
	    fpdown();
	    l = _M_lower * a.upper();
	    fpup();
	    h = _M_upper * a.lower();
	  }
	else if (a.upper() >= 0)
	  { // a.lower < 0, a.upper >= 0
	    fpdown();
	    l = _M_lower * a.upper();
	    fpup();
	    h = _M_lower * a.lower();
	  }
	else
	  { // a.lower and a.upper < 0
	    fpdown();
	    l = _M_upper * a.upper();
	    fpup();
	    h = _M_lower * a.lower();
	  }
      }

    _M_lower = l;
    _M_upper = h;
    fpnear();

    return *this;
  }

// Works for all other classes
// Please note that this is for all interger classes. interval<int>, interval<long>
// were there is no loss of precision
// Actually there is specialization for both <int>
template<typename _FloatTp>
   inline interval<_FloatTp>&
   interval<_FloatTp>::operator/=(const interval<_FloatTp>& b)
   {
     interval<_FloatTp> a, c;

     fpdown();
     c._M_lower = (_FloatTp)1 / b.upper();
     fpup();
     c._M_upper = (_FloatTp)1 / b.lower();
     fpnear();
     a = interval(_M_lower, _M_upper);
     c *= a;

     _M_lower = c.lower();
     _M_upper = c.upper();

     return *this;
   }

// Specialization for int and /=
//
inline interval<int>&
interval<int>::operator/=(const interval<int>& b)
{
   double tlow, thigh;
   interval<int> a;
   interval<double> c;

   tlow = 1 / (double)b.upper();
   thigh = 1 / (double)b.lower();

   a = interval(_M_lower, _M_upper);
   c = interval<double>(tlow, thigh);
   c *= a;

   _M_lower = (int)floor(c.lower());
   _M_upper = (int)ceil(c.upper());

   return *this;
}

// Return the intersection
template<typename _FloatTp>
  inline interval<_FloatTp>&
  interval<_FloatTp>::operator&=(const interval<_FloatTp>& a)
  {
    if (a.lower() > _M_lower)
      _M_lower = a.lower();
    if (a.upper() < _M_upper)
      _M_upper = a.upper();
    if (_M_lower > _M_upper) // Empty set
      {
	_M_lower = 0;
	_M_upper = 0;
      }

    return *this;
  }

// Return the union
template<typename _FloatTp>
  inline interval<_FloatTp>&
  interval<_FloatTp>::operator|=(const interval<_FloatTp>& a)
  {
    if (_M_lower > a.upper() || _M_upper < a.lower())
      {
	if (a.upper() - a.lower() > _M_upper - _M_lower)
	  { // return the largest set
	    _M_lower = a.lower();
	    _M_upper = a.upper();
	  }
      }
    else
      { // non empty intersection
	if (a.lower() < _M_lower)
	  _M_lower = a.lower();
	if (a.upper() > _M_upper)
	  _M_upper = a.upper();
      }

   return *this;
  }

	
// Return the set minus
template<typename _FloatTp>
  inline interval<_FloatTp>&
  interval<_FloatTp>::operator^=(const interval<_FloatTp>& a)
  {
    if (a.lower() < _M_upper && a.upper() > _M_lower) // intersection is not empty
      {
	if (a.upper() <= _M_lower)
	  _M_lower = a.upper();
	else if (a.upper() >= _M_upper)
	  _M_upper = a.lower();
      }

    return *this;
  }

template<typename _FloatTp,class _X>
  inline interval<_FloatTp>
  operator+(const interval<_FloatTp>& a, const _X& b)
  {
    interval<_FloatTp> c(a);

    c += interval<_FloatTp>(_FloatTp(b));
    return c;
  }

template<typename _FloatTp,class _X>
  inline interval<_FloatTp>
  operator+(const _X& a, const interval<_FloatTp>& b)
  {
    interval<_FloatTp> c(b);
    return c += interval<_FloatTp>(_FloatTp(a));
  }

template<typename _FloatTp>
  inline interval<_FloatTp>
  operator+(const interval<_FloatTp>& a, const interval<_FloatTp>& b)
  {
    interval<_FloatTp> c(a);
    return c += b;
  }

template<typename _FloatTp>
   inline interval<_FloatTp>
   operator+(const interval<_FloatTp>& a)
   { return a; }

template<typename _FloatTp, typename _X>
  inline interval<_FloatTp>
  operator-(const interval<_FloatTp>& a, const _X& b)
  {
    interval<_FloatTp> c(a);
    return c -= interval<_FloatTp>(_FloatTp(b));
  }

template<typename _FloatTp, typename _X>
  inline interval<_FloatTp>
  operator-(const _X& a, const interval<_FloatTp>& b)
  {
    interval<_FloatTp> c(a);
    return c -= b;
  }

template<typename _FloatTp>
  inline interval<_FloatTp>
  operator-(const interval<_FloatTp>& a, const interval<_FloatTp>& b)
  {
    interval<_FloatTp> c(a);
    return c -= b;
  }

template<typename _FloatTp> inline interval<_FloatTp> operator-(const interval<_FloatTp>& a)
  {
    interval<_FloatTp> c(0);
    return c -= a;
  }

template<typename _FloatTp, typename _X>
  inline interval<_FloatTp>
  operator*(const interval<_FloatTp>& a, const _X& b)
  {
    interval<_FloatTp> c(a);
    return c *= interval<_FloatTp>(_FloatTp(b));
  }

template<typename _FloatTp, typename _X>
  inline interval<_FloatTp>
  operator*(const _X& a, const interval<_FloatTp>& b)
  {
    interval<_FloatTp> c(b);
    return c *= interval<_FloatTp>(_FloatTp(a));
  }

template<typename _FloatTp>
  inline interval<_FloatTp>
  operator*(const interval<_FloatTp>& a, const interval<_FloatTp>& b)
  {
    interval<_FloatTp> c(a);
    return c *= b;
  }

template<typename _FloatTp, typename _X>
  inline interval<_FloatTp>
  operator/(const interval<_FloatTp>& a, const _X& b)
  {
    interval<_FloatTp> c(a);
    return c /= interval<_FloatTp>(_FloatTp(b));
  }

template<typename _FloatTp, typename _X>
  inline interval<_FloatTp>
  operator/(const _X& a, const interval<_FloatTp>& b)
  {
    interval<_FloatTp> c(a);
    return c /= b;
  }

template<typename _FloatTp>
  inline interval<_FloatTp>
  operator/(const interval<_FloatTp>& a, const interval<_FloatTp>& b)
  {
    interval<_FloatTp> c(a);

    if (c == b && b.is_class() != ZERO)
      c = interval<_FloatTp>(1,1);
    else
      c /= b;

    return c;
  }

template<typename _FloatTp>
  inline interval<_FloatTp>
  operator&(const interval<_FloatTp>& a, const interval<_FloatTp>& b)
  {
    interval<_FloatTp> c(a);
    return c &= b;
  }

template<typename _FloatTp>
  inline interval<_FloatTp>
  operator|(const interval<_FloatTp>& a, const interval<_FloatTp>& b)
  {
    interval<_FloatTp> c(a);
    return c |= b;
  }

template<typename _FloatTp>
  inline interval<_FloatTp> operator^(const interval<_FloatTp>& a, const interval<_FloatTp>& b)
  {
    interval<_FloatTp> c(a);
    return c ^= b;
  }


template<typename _FloatTp, typename _X>
  inline bool
  operator==(const interval<_FloatTp>& a, const _X& b)
  {
    interval<_FloatTp> c(b);
    return c.lower() == a.lower() && c.upper() == a.upper();
  }

template<typename _FloatTp, typename _X>
  inline bool
  operator==(const _X& a, const interval<_FloatTp>& b)
  {
    interval<_FloatTp> c(a);
    return c.lower() == b.lower() && c.upper() == b.upper();
  }

template<typename _FloatTp1, typename _FloatTp2>
  inline bool
  operator==(const interval<_FloatTp1>& a, const interval<_FloatTp2>& b)
  {
    return a.lower() == b.lower() && a.upper() == b.upper();
  }


template<typename _FloatTp, typename _X>
  inline bool
  operator!=(const interval<_FloatTp>& a, const _X& b)
  {
    interval<_FloatTp> c(b);
    return c.lower() != a.lower() || c.upper() != a.upper();
  }

template<typename _FloatTp, typename _X>
  inline bool
  operator!=(const _X& a, const interval<_FloatTp>& b)
  {
    interval<_FloatTp> c(a);
    return c.lower() != b.lower() || c.upper() != b.upper();
  }

template<typename _FloatTp1, typename _FloatTp2>
  inline bool
  operator!=(const interval<_FloatTp1>& a, const interval<_FloatTp2>& b)
  { return a.lower() != b.lower() || a.upper() != b.upper(); }


template<typename _FloatTp>
  inline interval<_FloatTp>
  abs(const interval<_FloatTp>& a)
  {
    if (a.lower() >= _FloatTp(0))
      return a;
    else if (a.upper() <= _FloatTp(0))
      return -a;
    else
      return interval<_FloatTp>(_FloatTp(0), (a.upper() > -a.lower() ? a.upper() : -a.lower()));
  }

//////////////////////////////////////////////////////////////////////////////////////
///
/// END interval functions
///
//////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////
///
/// Interval sqrt(), log10(), log(), exp() and pow()
///
//////////////////////////////////////////////////////////////////////////////////////

// Support function for correctly converting and double number back to a float
// By default IEE754 round to nearest and that will create incorrect result for interval arithmetic
//

// Support function for correctly converting and double number back to a float
// By default IEE754 round to nearest and that will create incorrect result for interval arithmetic
//
inline float
tofloat(const double& d, enum round_mode rm)
{
  switch (rm)
    {
    case ROUND_DOWN:
      fpdown();
      break;
    case ROUND_UP:
      fpup();
      break;
    }

  auto fres = (float)d;
  fpnear();
  return fres;
}

// If H/W Support allows us to control the rounding mode then we can do it directly.
// Log(2) for double
inline double
ln2double(enum round_mode rm)
{
  double res;

  switch (rm)
    {
    case ROUND_DOWN:
      fpdown();
      break;
    case ROUND_UP:
      fpup();
      break;
    }

  asm
    {
      fldln2;			Load ln2
      fstp qword ptr[res];	Store result in res
    }

  fpnear();

  return res;
}

// Log(10) for double
inline double
ln10double(enum round_mode rm)
{
  double res;

  switch (rm)
    {
    case ROUND_DOWN:
      fpdown();
      break;
    case ROUND_UP:
      fpup();
      break;
    }

  asm
    {
      ; ln10 = FLDL2T * FLDLN2
      fldl2t;			Load log2(10)
      fldln2;			Load LN2
      fmulp st(1),st;		Calculate LN2 * lOG2(10)
      fstp qword ptr[res];	Store ln10 in result
    }

  fpnear();

  return res;
}

// PI for double
inline double
pidouble(enum round_mode rm)
{
  double res;

  switch (rm)
    {
    case ROUND_DOWN:
      fpdown();
      break;
    case ROUND_UP:
      fpup();
      break;
    }

  asm
    {
      fldpi;			Load PI
      fstp qword ptr[res];	Store result in res
    }

  fpnear();

  return res;
}

// Sqrt() for double
inline double
sqrt(double d, enum round_mode rm)
{
  double sq = d;

  switch(rm)
    {
    case ROUND_DOWN:
      fpdown();
      break;
    case ROUND_UP:
      fpup();
      break;
    }

  asm
    {
      fld qword ptr[sq];	Load lower into floating point stack
      fsqrt;			Calculate sqrt
      fstp qword ptr[sq];	Store result in sq
    }

  fpnear();

  return sq;
}

// Sqrt() for float
inline float
sqrt(float f, enum round_mode rm)
{
  double sq = f;
  sq = sqrt(sq, rm);
  auto fres = tofloat(sq, rm);
  return fres;
}

// log() for double
inline double
log(double d, enum round_mode rm)
{
  double lg = d;

  switch (rm)
    {
    case ROUND_DOWN:
      fpdown();
      break;
    case ROUND_UP:
      fpup();
      break;
    }

  asm
    {
      fld qword ptr[lg];      Load lower into floating point stack
      fldln2;                 Load loge2
      fxch st(1);             Exchange stack top
      fyl2x;                  Calculate y * ln2 x
      fstp qword ptr[lg];     Store result in lower
    }

  fpnear();

  return lg;
}

// log() for float
inline float
log(float f, enum round_mode rm)
{
  double lg = (double)f;
  lg = log(lg, rm);
  auto fres = tofloat(lg, rm);
  return fres;
}

// log10() for double
inline double log10(double d, enum round_mode rm)
{
  double lg = d;

  switch (rm)
    {
    case ROUND_DOWN:
      fpdown();
      break;
    case ROUND_UP:
      fpup();
      break;
    }

  asm
    {
      fld qword ptr[lg];      Load lower into floating point stack
      fldlg2;                 Load log10(2)
      fxch st(1);             Exchange stack top
      fyl2x;                  Calculate y * ln2 x
      fstp qword ptr[lg];     Store result in lg
    }

  fpnear();

  return lg;
}

// log10 for float
inline float
log10(float f, enum round_mode rm)
{
  double lg = (double)f;
  lg = log10(lg, rm);
  auto fres = tofloat(lg, rm);
  return fres;
}



// sqrt for float using managed code.
//
inline interval<float>
sqrt(const interval<float>& x)
{
  auto lower = sqrt(x.lower(), ROUND_DOWN);
  auto upper = sqrt(x.upper(), ROUND_UP);
  return interval<float>(lower, upper);
}

// sqrt for double using managed code.
//
inline interval<double>
sqrt(const interval<double>& x)
{
  auto lower = sqrt(x.lower(), ROUND_DOWN);
  auto upper = sqrt(x.upper(), ROUND_UP);
  return interval<double>(lower, upper);
}


// log for float using manged code.
//
inline interval<float>
log(const interval<float>& x)
{
  auto lower = log(x.lower(), ROUND_DOWN);
  auto upper = log(x.upper(), ROUND_UP);
  return interval<float>(lower, upper);
}

// log for double using managed code.
//
inline interval<double>
log(const interval<double>& x)
{
  auto lower = log(x.lower(), ROUND_DOWN);
  auto upper = log(x.upper(), ROUND_UP);
  return interval<double>(lower, upper);
}

// log10 for float using manged code.
//
inline interval<float>
log10(const interval<float>& x)
{
  auto lower = log10(x.lower(), ROUND_DOWN);
  auto upper = log10(x.upper(), ROUND_UP);
  return interval<float>(lower, upper);
}

// log10 for double using managed code.
//
inline interval<double>
log10(const interval<double>& x)
 {
   auto lower = log10(x.lower(), ROUND_DOWN);
   auto upper = log10(x.upper(), ROUND_UP);

   return interval<double>(lower, upper);
 }


// MSC exp() does not allow rounding control
// So we have to do it manually
// Use a taylor series until their is no more change in the result
// exp(x) == 1 + x + x^2/2!+x^3/3!+....
// Equivalent with the same standard C function call
// use argument reduction via exp(x)=(exp(x/2^k)2^k	
// And use Brent enhancement using the double formula:
// expm(x)=exp(x)-1 && expm(2x)=expm(x)(2+expm(x)) on the backend to preseve
// loss of significance digits
//
inline interval<double>
exp(const interval<double>& x)
{
  int  i, k = 0;
  interval<double> c, res, p0, old;
  const interval<double> c1(1), c2(2);

  c = x;
  if (x.is_class() == NEGATIVE)
    c = abs(c);

  // Determine Reduction factor
  k = int((log(2) + log(abs(c.center()))) / log(2));
  k = std::min(k, 10);
  if (k > 0)
    {
      i = 2 << (k - 1);
      c /= interval<double>((double)i);
    }

  p0 = c;
  old = c1;
  res = old + p0;
  for (i = 2; i < 100 && (res.lower() != old.lower() && res.upper() != old.upper()); i++)
    {
      old = res;
      p0 *= (c / interval<double>((double)i));
      res += p0;
    }

  // Brent enhancement avoid loss of significant digits when x is small.
  if (k>0)
    {
      res -= c1;
      for (; k > 0; k--)
	res = (c2 + res)*res;
      res += c1;
    }

  if (x.is_class() == NEGATIVE)
    res = c1 / res;

  return res;
}

// MSC exp() does not allow rounding control for the exp()
// Since we dont normally do it using float arithmetic (as for sqrt(), log() and log10()) we simply just call the interval<double> version
// of exp() and convert back to float preserving as much accuracy as possible
//
inline interval<float>
exp(const interval<float>& x)
{
  interval<double> exp(const interval<double>&);
  interval<double> fx(x);
  float lower, upper;

  fx = exp(fx);
  lower = tofloat(fx, ROUND_DOWN);
  upper = tofloat(fx, ROUND_UP);
  return interval<double>(lower, upper);
}


// MSC pow() does not allow rounding control
// So we have to do it manually
// x^y == exp(y * ln(x)));
// To avoid loss of precision we actually perform the operation using double and then
// convert the result back to float. This is consistent with the pow() that only takes double as an argument.
//
inline interval<float>
pow(const interval<float>& x, const float y)
{
  interval<double> c(x);
  float upper, lower;

  c = log(c);
  c *= interval<double>(y);
  c = exp(c);
  lower = (float)c.lower();
  upper = (float)c.upper();
  if (lower > c.lower())
    lower -= lower * 0.5f * FLT_EPSILON;
  if (upper < c.upper())
    upper += upper * 0.5f * FLT_EPSILON;

  return interval<float>(lower, upper);
}

inline interval<double>
pow(const interval<double>& x, const double y)
{
  interval<double> c;

  c = log(x);
  c *= interval<double>(y);
  c = exp(c);

  return c;
}

//////////////////////////////////////////////////////////////////////////////////////
///
/// END Interval sqrt(), log10(), log(), exp(), pow()
///
//////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////
///
/// Interval constants like PI, LN2 and LN10
///
//////////////////////////////////////////////////////////////////////////////////////

// Load manifest constant PI for double
//
inline interval<double>
int_pidouble()
{
  interval<double> pi;

  pi.lower(pidouble(ROUND_DOWN));
  pi.upper(pidouble(ROUND_UP));
  return pi;
}

// Load manifest constant PI for float
//
inline interval<float>
int_pifloat()
{
  interval<double> pid;
  interval<float> pif;

  pid = int_pidouble();
  pif.lower(tofloat(pid.lower(), ROUND_DOWN));
  pif.upper(tofloat(pid.upper(), ROUND_UP));
  return pif;
}



// Load manifest constant lN 2 for double
inline interval<double>
int_ln2double()
{
  interval<double> ln2;

  ln2.lower(ln2double(ROUND_DOWN));
  ln2.upper(ln2double(ROUND_UP));
  return ln2;
}

// Load manifest constant LN2 for float
inline interval<float>
int_ln2float()
{
  interval<double> ln2d;
  interval<float> ln2f;

  ln2d = int_ln2double();
  ln2f.lower(tofloat(ln2d.lower(), ROUND_DOWN));
  ln2f.upper(tofloat(ln2d.upper(), ROUND_UP));
  return ln2f;
}

// Load manifest constant ln10 for double
inline interval<double>
int_ln10double()
{
  interval<double> ln10;

  ln10.lower(ln10double(ROUND_DOWN));
  ln10.upper(ln10double(ROUND_UP));
  return ln10;
}

// Load manifest constant LN10 for float
//
inline interval<float>
int_ln10float()
{
  interval<double> ln10d;
  interval<float> ln10f;

  ln10d = int_ln10double();
  ln10f.lower(tofloat(ln10d.lower(), ROUND_DOWN));
  ln10f.upper(tofloat(ln10d.upper(), ROUND_UP));
  return ln10f;
}


inline double
sin(double d, enum round_mode rm)
{
  double res = d;

  switch (rm)
    {
    case ROUND_DOWN:
      fpdown();
      break;
    case ROUND_UP:
      fpup();
      break;
    }

  asm
    {
      fld qword ptr[res];	Load lower into floating point stack
      fsin;			Calculate sin
      fstp qword ptr[res];	Store result in lower
    }
  fpnear();

  return res;
}

inline float
sin(float f, enum round_mode rm)
{
  double res = f;
  res = sin(res, rm);
  auto fres = tofloat(res, rm);
  return fres;
}

inline double
cos(double d, enum round_mode rm)
{
  double res = d;

  switch (rm)
    {
    case ROUND_DOWN:
      fpdown();
      break;
    case ROUND_UP:
      fpup();
      break;
    }

  asm
    {
      fld qword ptr[res];	Load lower into floating point stack
      fcos;			Calculate cos
      fstp qword ptr[res];	Store result in lower
    }
  fpnear();

  return res;
}

inline float
cos(float f, enum round_mode rm)
{
  double res = f;
  float fres;

  res = cos(res, rm);
  fres = tofloat(res, rm);
  return fres;
}

// tan() for double interval
//
inline double
tan(double d, enum round_mode rm)
{
  double res = d;

  switch (rm)
    {
    case ROUND_DOWN:
      fpdown();
      break;
    case ROUND_UP:
      fpup();
      break;
    }

  asm
    {
      fld qword ptr[res];  Load lower into floating point stack
      fptan;               Calculate tan
      fstp qword ptr[res]; Pop ST(0) and ignore
      fstp qword ptr[res]; Store result
    }
  fpnear();

  return res;
}

// tan(x) for float interval
inline float
tan(float f, enum round_mode rm)
{
  double res = f;
  res = tan(res, rm);
  return tofloat(res, rm);
}

// atan() for double interval
inline double
atan(double d, enum round_mode rm)
{
  double res = d;

  switch (rm)
    {
    case ROUND_DOWN:
      fpdown();
      break;
    case ROUND_UP:
      fpup();
      break;
    }

  asm
    {
      fld qword ptr[res];	Load lower into floating point stack
      fld1;			Load 1.0 on top of stack
      fpatan;			Calculate tan
      fstp qword ptr[res];	Store result
    }
  fpnear();

  return res;
}

inline float
atan(float f, enum round_mode rm)
{
  double res = f;
  res = atan(res, rm);
  auto fres = tofloat(res, rm);
  return fres;  // or alternatively return tofloat(atan((double)f, rm), rm);
}

inline interval<float>
sin(const interval<float>& x)
{
  auto lower = sin(x.lower(), ROUND_DOWN);
  auto upper = sin(x.upper(), ROUND_UP);
  return interval<float>(lower, upper);
}

// Interval Sin(x) for double
//
inline interval<double>
sin(const interval<double>& x)
{
  auto lower = sin(x.lower(), ROUND_DOWN);
  auto upper = sin(x.upper(), ROUND_UP);
  return interval<double>(lower, upper);
}



// Interval cos(x) for float.
//
inline interval<float>
cos(const interval<float>& x)
{
  auto lower = cos(x.lower(), ROUND_DOWN);
  auto upper = cos(x.upper(), ROUND_UP);
  return interval<float>(lower, upper);
}

// Interval Cos(x) for double.
//
inline interval<double>
cos(const interval<double>& x)
{
  auto lower = cos(x.lower(), ROUND_DOWN);
  auto upper = cos(x.upper(), ROUND_UP);
  return interval<double>(lower, upper);
}

inline interval<float>
tan(const interval<float>& x)
{
  auto lower = tan(x.lower(), ROUND_DOWN);
  auto upper = tan(x.upper(), ROUND_UP);
  return interval<float>(lower, upper);
}

inline interval<double>
tan(const interval<double>& x)
{
  auto lower = tan(x.lower(), ROUND_DOWN);
  auto upper = tan(x.upper(), ROUND_UP);
  return interval<double>(lower, upper);
}

inline interval<float>
atan(const interval<float>& x)
{
  auto lower = atan(x.lower(), ROUND_DOWN);
  auto upper = atan(x.upper(), ROUND_UP);
  return interval<float>(lower, upper);
}

inline interval<double>
atan(const interval<double>& x)
{
  auto lower = atan(x.lower(), ROUND_DOWN);
  auto upper = atan(x.upper(), ROUND_UP);
  return interval<double>(lower, upper);
}

///   Use a taylor series until their is no more change in the result
///   asin(x) == x + x^3/(2*3)+(1*3)x^5/(2*4*5)+(1*3*5)x^7/(2*4*6*7)....
///   Use argument reduction via the identity arcsin(x)=2arcsin(x)/(sqrt(2)+sqrt(1-x*x))
//	  This function replace the other function using newton iteration. Taylor series is significant
//    faster e.g 50% for 10 digits, 3x for 100 digits and 5x for 1000 digits.
//
inline interval<double>
asin(const interval<double>& x)
{
  int k, sign;
  interval<double> r, u, v, v2, sqrt2, lc, uc;
  const double c1(1), c2(2);

  if (x.lower() >= c1 || x.upper() <= -c1)
    throw interval<double>::domain_error();

  v = x;
  if (v.lower() < -c1)
    v.lower(-c1);
  if (v.upper() > c1)
    v.upper(c1);

  sign = v.is_class();
  if (sign == NEGATIVE)
    v = -v;

  // Now use the identity arcsin(x)=2arcsin(x)/(sqrt(2)+sqrt(1-x*x))
  // until argument is less than dlimit
  // Reduce the argument to below 0.5 to make the newton run faster
  sqrt2 = interval<double>(c2);  // Ensure correct number of digits
  sqrt2 = sqrt(sqrt2);	// Now calculate sqrt2 with precision digits
  for (k = 0; v.lower() > 0.5; k++)
    v /= sqrt2 * sqrt(interval<double>(c1) + sqrt(interval<double>(c1) - v * v));

  v2 = v * v;
  r = v;
  u = v;
  // Now iterate using taylor expansion
  for (unsigned int j = 3; ; j += 2)
    {
      uc = interval<double>((j - 2) * (j - 2));
      lc = interval<double>(j * j - j);
      v = uc * v2 / lc;
      r *= v;
      if (u.lower() + r.lower() == u.lower() || u.upper() + r.upper() == u.upper())
	break;
      u += r;
    }

  if (k > 0)
    u *= interval<double>(1 << k);

  if (sign == NEGATIVE)
    u = -u;

  return u;
}

inline interval<double>
acos(const interval<double>& x)
{
  interval<double> pi, res;
  const double c1(1);

  if (x.lower() >= c1 || x.upper() <= -c1)
    throw interval<double>::domain_error();

  pi.lower(pidouble(ROUND_DOWN));
  pi.upper(pidouble(ROUND_UP));
  res = pi * interval<double>(0.5) - asin(x);
  return res;
}

inline interval<float>
asin(const interval<float>& x)
{
  interval<double> asin(const interval<double>&);
  interval<double> fx(x);

  fx = asin(fx);
  auto lower = tofloat(fx.lower(), ROUND_DOWN);
  auto upper = tofloat(fx.upper(), ROUND_UP);
  return interval<float>(lower, upper);
}


inline interval<float>
acos(const interval<float>& x)
{
  interval<double> acos(const interval<double>&);
  interval<double> fx(x);

  fx = acos(fx);
  auto lower = tofloat(fx.lower(), ROUND_DOWN);
  auto upper = tofloat(fx.upper(), ROUND_UP);
  return interval<float>(lower, upper);
}

#endif // INTERVAL
