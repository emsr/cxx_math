#include <complex>
#include <ext/cmath>
#include "numeric_limits.h"

/**
 *  @param[in]  t      The input argument.
 *
 *  @param[out]  _Ai    The Airy function of the first kind.
 *  @param[out]  _Aip   The derivative of the Airy function of the first kind.
 *  @param[out]  _Bi    The Airy function of the second kind.
 *  @param[out]  _Bip   The derivative of the Airy function of the second kind.
 *  @param[out]  __w1   The Fock-type Airy function of the first kind.
 *  @param[out]  __w1p  The derivative of the Fock-type Airy function of the first kind.
 *  @param[out]  __w2   The Fock-type Airy function of the second kind.
 *  @param[out]  __w2p  The derivative of the Fock-type Airy function of the second kind.
 */
template<typename _Tp>
  void
  airy(std::complex<_Tp> __t,
       std::complex<_Tp>& _Ai, std::complex<_Tp>& _Aip,
       std::complex<_Tp>& _Bi, std::complex<_Tp>& _Bip,
       std::complex<_Tp>& __w1, std::complex<_Tp>& __w1p,
       std::complex<_Tp>& __w2, std::complex<_Tp>& __w2p)
  {
    using __cmplx = std::complex<_Tp>;

    constexpr _Tp _S_pi = __gnu_cxx::__math_constants<_Tp>::__pi;
    constexpr _Tp _S_sqrt_pi = __gnu_cxx::__math_constants<_Tp>::__root_pi;
    constexpr _Tp _S_eps = __gnu_cxx::__epsilon(_Tp{});
    constexpr _Tp _S_log10min = __gnu_cxx::__log10_min(_Tp{});
    constexpr _Tp _S_Ai0{3.550280538878172392600631860041831763980e-1};
    constexpr _Tp _S_Aip0{2.588194037928067984051835601892039634793e-1};
    //constexpr _Tp _S_Bi0{6.149266274460007351509223690936135535960e-1};
    //constexpr _Tp _S_Bip0{8.868776642045783582807775119976424596506e-1};
    constexpr auto _S_i = __cmplx(_Tp{0}, _Tp{1});
    constexpr _Tp _S_big = _Tp{5.0}; // 3.5
    constexpr int _N_FG = 15;
    constexpr _Tp
    _F_k[_N_FG]
    {
      0.166666666666666666666666666666666659L,
      0.00555555555555555555555555555555555574L,
      7.71604938271604938271604938271604912e-05L,
      5.84549195660306771417882528993640087e-07L,
      2.78356759838241319722801204282685752e-09L,
      9.09662613850461829159481059747339155e-12L,
      2.16586336631062340276066918987461686e-14L,
      3.92366551867866558471135722803372616e-17L,
      5.58926712062487975030107867241271502e-20L,
      6.42444496623549396586330881886519055e-23L,
      6.08375470287452080100692122998597518e-26L,
      4.82837674831311174683088986506823439e-29L,
      3.25801400021127648234203094808922725e-32L,
      1.89199419292176334630779962142231545e-35L,
      9.55552622687759265812020010819351237e-39L
    };
    constexpr _Tp _S_slope_F{-2.660L}, _S_intercept_F{-0.778L};
    constexpr _Tp
    _Fp_k[_N_FG]
    {
      0.5L,
      0.0333333333333333333333333333333333329L,
      0.000694444444444444444444444444444444373L,
      7.01459034792368125701459034792368142e-06L,
      4.1753513975736197958420180642402865e-08L,
      1.63739270493083129248706590754521051e-10L,
      4.54831306925230914579740529873669525e-13L,
      9.41679724482879740330725734728094236e-16L,
      1.50910212256871753258129124155143309e-18L,
      1.92733348987064818975899264565955719e-21L,
      2.00763905194859186433228400589537173e-24L,
      1.7382156293927202288591203514245643e-27L,
      1.27062546008239782811339206975479857e-30L,
      7.9463756102714060544927584099737242e-34L,
      4.29998680209491669615409004868708044e-37L
    };
    constexpr _Tp _S_slope_Fp{-2.576L}, _S_intercept_Fp{-0.301L};
    constexpr _Tp
    _G_k[_N_FG]
    {
      0.0833333333333333333333333333333333293L,
      0.00198412698412698412698412698412698403L,
      2.20458553791887125220458553791887122e-05L,
      1.4131958576403020847465291909736355e-07L,
      5.88831607350125868644387162905681399e-10L,
      1.7217298460529996159192607102505305e-12L,
      3.72668797846969613835337816071543371e-15L,
      6.21114663078282689725563026785905655e-18L,
      8.21580242167040594875083368764425454e-21L,
      8.83419615233376983736648783617661744e-24L,
      7.87361510903188042546032783972960544e-27L,
      5.91112245422813845755279867847568008e-30L,
      3.78918106040265285740564017851005176e-33L,
      2.09810689944775905725672213649504515e-36L,
      1.01357821229360340930276431714736476e-39L
    };
    constexpr _Tp _S_slope_G{-2.708L}, _S_intercept_G{-1.079L};
    constexpr _Tp
    _Gp_k[_N_FG]
    {
      0.333333333333333333333333333333333317L,
      0.0138888888888888888888888888888888882L,
      0.000220458553791887125220458553791887128L,
      1.8371546149323927101704879482657262e-06L,
      9.42130571760201389831019460649090239e-09L,
      3.27128670750069927024659534947600771e-11L,
      8.19871355263333150437743195357395457e-14L,
      1.55278665769570672431390756696476412e-16L,
      2.30042467806771366565023343254039138e-19L,
      2.73860080722346864958361122921475124e-22L,
      2.67702913707083934465651146550806602e-25L,
      2.18711530806441122929453551103600168e-28L,
      1.51567242416106114296225607140402075e-31L,
      9.02185966762536394620390518692869428e-35L,
      4.66245977655057568279271585887787801e-38L
    };
    constexpr _Tp _S_slope_Gp{-2.632L}, _S_intercept_Gp{-0.477};

    constexpr int _N_cd = 50;
    constexpr _Tp
    _S_cn[_N_cd]
    {
     0.0694444444444444444444444444444444471L,
     0.0371334876543209876543209876543209876L,
     0.037993059127800640146319158664837679L,
     0.057649190412669721333130112279632168L,
     0.116099064025515411018109253896481456L,
     0.291591399230750511469093843698338833L,
     0.877666969510016916465506668433293675L,
     3.07945303017316699336248086268001127L,
     12.3415733323452387064233993833024529L,
     55.6227853659170827810332374983561958L,
     278.465080777602567205551498334573594L,
     1533.169432012795615968528330529591L,
     9207.20659972641469803322408750729846L,
     59892.5135658790686259958832755807077L,
     419524.87511655106866264708979608155L,
     3148257.41786682637898314591257562958L,
     25198919.8716023676755701638116858171L,
     214288036.963680319562082388401689385L,
     1929375549.18249305266532805405234501L,
     18335766937.8905676567534822359071795L,
     183418303528.832563365341546837365161L,
     1926471158970.44656357903239566492682L,
     21196999388647.6490549357181651030291L,
     243826826879716.041819998420120227443L,
     2926599219297925.04640059214816528695L,
     36590307012643128.0507509931772481271L,
     475768102036306763.240140357274331917L,
     6424049357901937699.48405786972449505L,
     89952074270583789520.9843869430724226L,
     1304513299317609817937.42403749617779L,
     19570621786581615032990.4318528492404L,
     303387108659433829918975.370871621708L,
     4854832179436167359995522.96965905838L,
     80114646876095936618357492.4041327536L,
     1362107954526321589052986810.33931303L,
     23839516727271056669517263368.4579391L,
     429156044928580354617131906667.093323L,
     7940171107576632357848623628433.81934L,
     150877389525272924757026001047843.109L,
     2942371035655192298256376857240313.0L,
     58852404403882394732570383311569920.0L,
     1.2065715991493045060301475046849856e+36L,
     2.53399521796792404026441281983599903e+37L,
     5.44848965474498364427686262780203958e+38L,
     1.19875180567437086136504985315700155e+40L,
     2.69737253375249059309270351167045845e+41L,
     6.2043553755819329283261454857533513e+42L,
     1.45811327534762781936220446324760688e+44L,
     3.49967850954113040986772639836784608e+45L,
     8.57469841483542799451063352688988237e+46L
    };
    constexpr _Tp
    _S_dn[_N_cd]
    {
      -0.0972222222222222222222222222222222356L,
      -0.043885030864197530864197530864197528L,
      -0.0424628307898948331047096479195244637L,
      -0.0626621634920323057968805568256871339L,
      -0.124105896027275094536599547268652587L,
      -0.308253764901079112124470634766815348L,
      -0.920479992412944570927238701039795836L,
      -3.21049358464862090797365026109192646L,
      -12.8072930807356250727035276619176409L,
      -57.5083035139142720278479235152496259L,
      -287.03323710922110773495308289871432L,
      -1576.35730333709971782679673420648082L,
      -9446.35482309593196291720393393606053L,
      -61335.7066638520582314415672099320452L,
      -428952.40040006907020562792327464519L,
      -3214536.52140086482906700161599827448L,
      -25697908.3839113254513240284416201894L,
      -218293420.832160325535205423698917208L,
      -1963523788.99103275271250200191167858L,
      -18643931088.1072158526653054667627612L,
      -186352996385.293884379187011586763004L,
      -1955882932389.84269432069701239263561L,
      -21506444635197.2497710661666054694949L,
      -247236992290621.161286012384037992843L,
      -2965882430295212.63091603633807354567L,
      -37062440006354652.2836639092182448793L,
      -481678264794521754.087843964196994417L,
      -6500984080751062701.87308850289484763L,
      -90991982643654122347.8165763875010015L,
      -1319088866907750709757.95391501010158L,
      -19782196076166281141455.1932782854492L,
      -306563937022359838609226.421875513042L,
      -4904119815775620835731518.12671143468L,
      -80903953741870280821494019.4228926748L,
      -1375142480406956245407560846.80189013L,
      -24061279673571252545512772795.1412697L,
      -433039810041056194930409118492.134888L,
      -8010128562268937488754778902693.14844L,
      -152172474413901876900863134104047.781L,
      -2966993387417997254727141517133537.5L,
      -59332832194934495914060753787582736.0L,
      -1.2161857154771874104606666083079735e+36L,
      -2.55371502511164329349604249158569533e+37L,
      -5.48992303614988846286451937782334751e+38L,
      -1.20766445850466358152389780745556654e+40L,
      -2.71698978854341779740610499175533423e+41L,
      -6.24851448857539864311850239312526105e+42L,
      -1.46827434346851721183162749086605705e+44L,
      -3.52356710004994358672689176627479368e+45L,
      -8.63205425707512985400568793175202219e+46L
    };

    if (std::abs(__t) <= _S_big)
      {
	const auto __log10t = std::log10(std::abs(__t));
	const auto __ttt = __t * __t * __t;

	auto __term = __cmplx{1};
	auto _F = __cmplx{1};
	auto _G = __t;
	for (int __n = 0; __n < _N_FG; ++__n)
	  {
	    if (std::abs(__t) < _S_eps)
	      break;
	    auto __xx = __log10t * (3 * (__n + 1) + 1)
		      + _S_slope_G * __n + _S_intercept_G);
	    if (__xx < _S_log10min)
	      break;
	    __term *= __ttt;
	    _F += _F_k[__n] * __term;
	    _G += _G_k[__n] * __term * __t;
	  }
	auto _UU = std::sqrt(_Tp{3} * _S_pi)
		* (_S_Ai0 * _F + _S_Aip0 * _G);
	auto _VV = _S_sqrt_pi * (_S_Ai0 * _F - _S_Aip0 * _G);
	_Bi = _UU / _S_sqrt_pi;
	_Ai = _VV / _S_sqrt_pi;
	__w1 = _UU - _S_i * _VV;
	__w2 = _UU + _S_i * _VV;

	__term = __cmplx{1};
	auto _Fp = __cmplx{0};
	auto _Gp = __cmplx{1};
	for (int __n = 0; __n < _N_FG; ++__n)
	  {
	    if (std::abs(__t) < _S_eps)
	      break;
	    auto __xx = __log10t * 3 * (__n + 1)
		      + _S_slope_Gp * __n + _S_intercept_Gp;
	    if (__xx < _S_log10min)
	      break;
	    __term *= __ttt;
	    _Fp += _Fp_k[__n] * __term / __t;
	    _Gp += _Gp_k[__n] * __term;
	  }
	auto _UUp = std::sqrt(_Tp{3} * _S_pi)
		  * (_S_Ai0 * _Fp + _S_Aip0 * _Gp);
	auto _VVp = _S_sqrt_pi * (_S_Ai0 * _Fp - _S_Aip0 * _Gp);
	_Bip = _UUp / _S_sqrt_pi;
	_Aip = _VVp / _S_sqrt_pi;
	__w1p = _UUp - _S_i * _VVp;
	__w2p = _UUp + _S_i * _VVp;

	return;
      }
    else // |t| > 3.5
      {
	if (std::real(__t) > _Tp{0})
	  {
	    auto __zeta0 = (_Tp{2} / _Tp{3}) * std::pow(__t, 1.5);
	    auto __mqrt0 = std::pow(__t, -0.25);
	    auto __pqrt0 = std::pow(__t, +0.25);
	    auto __ezeta0 = std::exp(-__zeta0);
	    _Ai = __cmplx{1};
	    _Aip = __cmplx{1};
	    auto __fact0 = -_Tp{1} / __zeta0;
	    auto __izeta0 = __cmplx{1};
	    auto __prev_Ai0 = _Tp{1};
	    auto __prev_Aip0 = _Tp{1};
	    for (int __n = 0; __n < _N_cd; ++__n)
	      {
		__izeta0 *= __fact0;
		if (std::abs(_S_cn[__n] * __izeta0) > __prev_Ai0
		 || std::abs(_S_dn[__n] * __izeta0) > __prev_Aip0)
		  break;
		__prev_Ai0 = std::abs(_S_cn[__n] * __izeta0);
		__prev_Aip0 = std::abs(_S_dn[__n] * __izeta0);
		_Ai += _S_cn[__n] * __izeta0;
		_Aip += _S_dn[__n] * __izeta0;
	      }
	    _Ai *= 0.5 * __mqrt0 * __ezeta0 / _S_sqrt_pi;
	    _Aip *= -0.5 * __pqrt0 * __ezeta0 / _S_sqrt_pi;

	    auto __t1 = __t * std::exp(+_Tp{2} * _S_pi * _S_i / _Tp{3});
	    auto __t2 = __t * std::exp(-_Tp{2} * _S_pi * _S_i / _Tp{3});
	    auto __zeta1 = (_Tp{2} / _Tp{3}) * std::pow(__t1, 1.5);
	    auto __zeta2 = (_Tp{2} / _Tp{3}) * std::pow(__t2, 1.5);
	    auto __mqrt1 = std::pow(__t1, -0.25);
	    auto __mqrt2 = std::pow(__t2, -0.25);
	    auto __pqrt1 = std::pow(__t1, +0.25);
	    auto __pqrt2 = std::pow(__t2, +0.25);
	    auto __ezeta1 = std::exp(-__zeta1);
	    auto __ezeta2 = std::exp(-__zeta2);
	    auto _Ai1 = __cmplx{1};
	    auto _Ai1p = __cmplx{1};
	    auto _Ai2 = _Ai1;
	    auto _Ai2p = _Ai1p;
	    auto __sign = 1;
	    auto __izeta1 = __cmplx{1};
	    auto __izeta2 = __cmplx{1};
	    auto __prev_Ai1 = _Tp{1};
	    auto __prev_Ai2 = _Tp{1};
	    auto __prev_Ai1p = _Tp{1};
	    auto __prev_Ai2p = _Tp{1};
	    for (int __n = 0; __n < _N_cd; ++__n)
	      {
		__sign *= -1;
		__izeta1 /= __zeta1;
		__izeta2 /= __zeta2;
		if (std::abs(_S_cn[__n] * __izeta1) > __prev_Ai1
		 || std::abs(_S_cn[__n] * __izeta2) > __prev_Ai2
		 || std::abs(_S_dn[__n] * __izeta1) > __prev_Ai1p
		 || std::abs(_S_dn[__n] * __izeta2) > __prev_Ai2p)
		  break;
		__prev_Ai1 = std::abs(_S_cn[__n] * __izeta1);
		__prev_Ai2 = std::abs(_S_cn[__n] * __izeta2);
		__prev_Ai1p = std::abs(_S_dn[__n] * __izeta1);
		__prev_Ai2p = std::abs(_S_dn[__n] * __izeta2);
		_Ai1 += __sign * _S_cn[__n] * __izeta1;
		_Ai2 += __sign * _S_cn[__n] * __izeta2;
		_Ai1p += __sign * _S_dn[__n] * __izeta1;
		_Ai2p += __sign * _S_dn[__n] * __izeta2;
	      }
	    _Ai1 *= 0.5 * __ezeta1 * __mqrt1 / _S_sqrt_pi;
	    _Ai2 *= 0.5 * __ezeta2 * __mqrt2 / _S_sqrt_pi;
	    _Ai1p *= -0.5 * __pqrt1 * __ezeta1 / _S_sqrt_pi;
	    _Ai2p *= -0.5 * __pqrt2 * __ezeta2 / _S_sqrt_pi;

	    _Bi = std::exp(+_S_i * _S_pi / _Tp{6}) * _Ai1
		+ std::exp(-_S_i * _S_pi / _Tp{6}) * _Ai2;
	    _Bip = std::exp(+_S_i * _Tp{5} * _S_pi / _Tp{6}) * _Ai1p
		 + std::exp(-_S_i * _Tp{5} * _S_pi / _Tp{6}) * _Ai2p;

	    __w1 = _S_sqrt_pi * (_Bi - _S_i * _Ai);
	    __w2 = _S_sqrt_pi * (_Bi + _S_i * _Ai);
	    __w1p = _S_sqrt_pi * (_Bip - _S_i * _Aip);
	    __w2p = _S_sqrt_pi * (_Bip + _S_i * _Aip);

	    return;
	  }
	else // Argument t is on or left of the imaginary axis.
	  {
	    auto __zeta = (_Tp{2} / _Tp{3}) * std::pow(-__t, 1.5);
	    auto __mqrt = std::pow(-__t, -0.25);
	    auto __pqrt = std::pow(-__t, +0.25);
	    auto __mezeta = std::exp(-_S_i * (__zeta + (_S_pi / _Tp{4})));
	    auto __pezeta = std::exp(+_S_i * (__zeta + (_S_pi / _Tp{4})));
	    __w1 = __cmplx{1};
	    __w2 = __cmplx{1};
	    __w1p = +_S_i;
	    __w2p = -_S_i;
	    auto __ipn = __cmplx{1};
	    auto __imn = __cmplx{1};
	    auto __ixn = __cmplx{1};
	    auto __prev_w1 = _Tp{1};
	    auto __prev_w2 = _Tp{1};
	    auto __prev_w1p = _Tp{1};
	    auto __prev_w2p = _Tp{1};
	    for (int __n = 0; __n < _N_cd; ++__n)
	      {
		__ipn *= +_S_i;
		__imn *= -_S_i;
		__ixn /= __zeta;
		if (std::abs(_S_cn[__n] * __ixn) > __prev_w1
		 || std::abs(_S_cn[__n] * __ixn) > __prev_w2
		 || std::abs(_S_dn[__n] * __ixn) > __prev_w1p
		 || std::abs(_S_dn[__n] * __ixn) > __prev_w2p)
		  break;
		__prev_w1 = std::abs(_S_cn[__n] * __ixn);
		__prev_w2 = std::abs(_S_cn[__n] * __ixn);
		__prev_w1p = std::abs(_S_dn[__n] * __ixn);
		__prev_w2p = std::abs(_S_dn[__n] * __ixn);
		__w1 += __ipn * _S_cn[__n] * __ixn;
		__w2 += __imn * _S_cn[__n] * __ixn;
		__w1p += +_S_i * __ipn * _S_dn[__n] * __ixn;
		__w2p += -_S_i * __imn * _S_dn[__n] * __ixn;
	      }
	    __w1 *= __mqrt * __mezeta;
	    __w2 *= __mqrt * __pezeta;
	    __w1p *= __pqrt * __mezeta;
	    __w2p *= __pqrt * __pezeta;

	    _Bi = (__w1 + __w2) / (_Tp{2} * _S_sqrt_pi);
	    _Ai = (__w2 - __w1) / (_Tp{2} * _S_i * _S_sqrt_pi);
	    _Bip = (__w1p + __w2p) / (_Tp{2} * _S_sqrt_pi);
	    _Aip = (__w2p - __w1p) / (_Tp{2} * _S_i * _S_sqrt_pi);

	    return;
	  }
      }
  }
