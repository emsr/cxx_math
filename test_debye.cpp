/*
$HOME/bin_tr29124/bin/g++ -std=gnu++17 -g -Wall -Wextra -I. -o test_debye test_debye.cpp wrap_boost.cpp -lquadmath
./test_debye > test_debye.txt

$HOME/bin/bin/g++ -std=gnu++17 -g -Wall -Wextra -I. -o test_debye test_debye.cpp wrap_boost.cpp -lquadmath
./test_debye > test_debye.txt

g++ -std=gnu++17 -g -Wall -Wextra -DNO_LOGBQ -I. -o test_debye test_debye.cpp wrap_boost.cpp -lquadmath
./test_debye > test_debye.txt
*/


template<typename _Tp>
  _Tp
  debyen(unsigned int n, _Tp x)
  {
    if (x <= _Tp{0})
      return _Tp{0};
    if (n < 1 || n > 20)
      return _Tp{-1};

    // for values up to 4.80 the list of zeta functions
    // and the sum up to k < K are huge enough to gain
    // numeric stability in the sum
    if (x >= _Tp{3})
      {
	double sum;
	// List of n! zeta(n+1)
	static constexpr long double
	nzetan[]
	{ 0.0L, // inf
	  1.644934066848226436472415166646025189221L,
	  2.404113806319188570799476323022899981535L,
	  6.493939402266829149096022179247007416657L,
	  2.488626612344087823195277167496882003334e+01L,
	  1.220811674381338967657421515749104633481e+02L,
	  7.260114797149844353246542358918536669129e+02L,
	  5.060549875237639470468573602083608424904e+03L,
	  4.040097839874763488532782365545085427880e+04L,
	  3.632409114223826268071435255657477648916e+05L,
	  3.630593311606628712990618842832054105454e+06L,
	  3.992662298773108670232707324047201489782e+07L,
	  4.790603798898314524268767644990636347182e+08L,
	  6.227402193410971764192853408947415910063e+09L,
	  8.718095783017206784519122031036435756615e+10L,
	  1.307694352218913820890099907485110170283e+12L,
	  2.092294967948151090663165568811151437906e+13L,
	  3.556887858592237159756123967161824480923e+14L,
	  6.402385922818921400735649453323975529936e+15L,
	  1.216452164536393966698766962740413842385e+17L,
	  2.432903168507861321737256818243197497087e+18L,
	  5.109095435437028567765027486047348085447e+19L,
	  1.124000861780891230602152949001944312688e+21L,
	  2.585201827987687776778026178504241061606e+22L,
	  6.204484202247755610769915204946357633986e+23L,
	  1.551121027447213289898317465714050200972e+25L,
	};

	// constrained to the list of nzetan[] given above
	if (n >= sizeof(nzetan)/sizeof(double))
	  return _Tp{-1};

	// n! zeta(n) is the integral for x=infinity , 27.1.3
	sum = nzetan[n];

	// the number of terms needed in the k-sum for x = 0, 1, 2, 3...
	// Reflects the n=1 case, because higher n need less terms.
	static int kLim[] = {0, 0, 0, 13, 10, 8, 7, 6, 5, 5, 4, 4, 4, 3};

	const int kmax = ((int) x < sizeof(kLim)/sizeof(int)) ? kLim[(int)x] : 3;
	// Abramowitz Stegun 27.1.2
	for(int k = 1; k <= kmax; ++k)
	   {
	     // do not use x(k+1) = xk + x to avoid loss of precision
	     const auto xk = x * k;
	     double ksum = _Tp{1} / xk;
	     double tmp = _Tp(n) * ksum / xk;  // n/(xk)^2

	     for (int s = 1; s <= n; ++s)
	       {
        	 ksum += tmp;
        	 tmp *= _Tp(n - s) / xk;
	       }
	     sum -= std::exp(-xk) * ksum * std::pow(x, _Tp(n + 1));
	   }
	return sum;
      }
    else
      {
	/*
	 * list of absolute values of Bernoulli numbers of index 2*k, multiplied  by
	 * (2*pi)^k/(2k)!, and 2 subtracted, k=0,1,2,3,4
	 * Digits := 60 :
	 * interface(prettyprint=0) :
	 * for k from 1 to 70 do
	 *  printf("%.30e,\n",evalf( abs((2*Pi)^(2*k)*bernoulli(2*k)/(2*k)!)-2 ));
	 * od;
	 */
	static constexpr long double
	koeff[]
	{ 0.,
	  1.289868133696452872944830333292e+00, 1.646464674222763830320073930823e-01,
	  3.468612396889827942903585958184e-02, 8.154712395888678757370477017305e-03,
	  1.989150255636170674291917800638e-03, 4.921731066160965972759960954793e-04,
	  1.224962701174096585170902102707e-04, 3.056451881730374346514297527344e-05,
	  7.634586529999679712923289243879e-06, 1.907924067745592226304077366899e-06,
	  4.769010054554659800072963735060e-07, 1.192163781025189592248804158716e-07,
	  2.980310965673008246931701326140e-08, 7.450668049576914109638408036805e-09,
	  1.862654864839336365743529470042e-09, 4.656623667353010984002911951881e-10,
	  1.164154417580540177848737197821e-10, 2.910384378208396847185926449064e-11,
	  7.275959094757302380474472711747e-12, 1.818989568052777856506623677390e-12,
	  4.547473691649305030453643155957e-13, 1.136868397525517121855436593505e-13,
	  2.842170965606321353966861428348e-14, 7.105427382674227346596939068119e-15,
	  1.776356842186163180619218277278e-15, 4.440892101596083967998640188409e-16,
	  1.110223024969096248744747318102e-16, 2.775557561945046552567818981300e-17,
	  6.938893904331845249488542992219e-18, 1.734723476023986745668411013469e-18,
	  4.336808689994439570027820336642e-19, 1.084202172491329082183740080878e-19,
	  2.710505431220232916297046799365e-20, 6.776263578041593636171406200902e-21,
	  1.694065894509399669649398521836e-21, 4.235164736272389463688418879636e-22,
	  1.058791184067974064762782460584e-22, 2.646977960169798160618902050189e-23,
	  6.617444900424343177893912768629e-24, 1.654361225106068880734221123349e-24,
	  4.135903062765153408791935838694e-25, 1.033975765691286264082026643327e-25,
	  2.584939414228213340076225223666e-26, 6.462348535570530772269628236053e-27,
	  1.615587133892632406631747637268e-27, 4.038967834731580698317525293132e-28,
	  1.009741958682895139216954234507e-28, 2.524354896707237808750799932127e-29,
	  6.310887241768094478219682436680e-30, 1.577721810442023614704107565240e-30,
	  3.944304526105059031370476640000e-31, 9.860761315262647572437533499000e-32,
	  2.465190328815661892443976898000e-32, 6.162975822039154730370601500000e-33,
	  1.540743955509788682510501190000e-33, 3.851859888774471706184973900000e-34,
	  9.629649721936179265360991000000e-35, 2.407412430484044816328953000000e-35,
	  6.018531076210112040809600000000e-36, 1.504632769052528010200750000000e-36,
	  3.761581922631320025497600000000e-37, 9.403954806578300063715000000000e-38,
	  2.350988701644575015901000000000e-38, 5.877471754111437539470000000000e-39,
	  1.469367938527859384580000000000e-39, 3.673419846319648458500000000000e-40,
	  9.183549615799121117000000000000e-41, 2.295887403949780249000000000000e-41,
	  5.739718509874450320000000000000e-42, 1.434929627468612270000000000000e-42
	};

	auto sum = _Tp{0};

	// Abramowitz-Stegun 27.1.1
	const double x2pi = x * M_1_2PI;
	for(int k = 1; k < sizeof(koeff)/sizeof(double) - 1; ++k)
	   {
	     const double sumold = sum;
	     // do not precompute x2pi^2 to avoid loss of precision */
	     sum += (_Tp{2} + koeff[k]) * std::pow(x2pi, _Tp(2 * k)) / _Tp(2 * k + n);
	     ++k;
	     sum -= (_Tp{2} + koeff[k]) * std::pow(x2pi, _Tp(2 * k)) / _Tp(2 * k + n);
	     if(sum == sumold)
               break;
	   }
	sum += _Tp{1} / _Tp(n) - x / _Tp(2 * (1 + n));
	return sum * std::pow(x, _Tp(n));
      }
  }

int
main()
{
  test_debye(1.0);

  return 0;
}

