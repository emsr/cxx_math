<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
  "http://www.w3.org/TR/REC-html40/transitional.dtd">
<HTML>
<HEAD>
  <TITLE>VecMat - Global Functions</TITLE>
  <META HTTP-EQUIV="Content-Type" CONTENT="text/html;charset=iso-8859-1">
  <META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">
  <META NAME="Author" CONTENT="Kevin Dolan">
  <LINK HREF="vecmat.css" REL="stylesheet" TYPE="text/css">
</HEAD>

<BODY>

<H1>4. Global Support Functions and Classes.</H1>

<P>The <EM>VecMat</EM> software provides many global support functions and
classes for use with vectors and matrices. They are provided in the header
files "vm_traits.h", "vm_tools.h", and "vm_io.h".</P>

<H2>4.1. Support Classes.</H2>

<H3>4.1.1. VMTraits&lt;T&gt;</H3>

<P>This is a numeric traits structure used to provide information about various
types. It's default definition is:</P>

<DIV CLASS=sc><CODE>
<P>template &lt;class T&gt;</P>
<P>struct VMTraits</P>
<P>{</P>
<P>     typedef T real_type;</P>
<P>     enum {is_specialized = false};</P>
<P>     enum {is_simple = false};</P>
<P>};</P>
</CODE></DIV>

<P>The <CODE>real_type</CODE> type is used for the complex constructors, and
for the <CODE>abs()</CODE> function, to determine the real base of a complex
type. The <CODE>is_specialized</CODE> flag should be <CODE>true</CODE> for any
type that has a specialization of this structure. The <CODE>is_simple</CODE>
flag should only be <CODE>true</CODE> for types without constructors and
destructors, or classes for which the default constructor and destructor don't
do anything. If this flag is set, then the <CODE>NoInit</CODE> vector and
matrix constructors will not initialize the values of their elements. If it is
not set, then they will initialize their elements with the default constructor
of type <CODE>T</CODE>. Note that this is still different that using the
<CODE>Vector&lt;T&gt;(size_t n)</CODE> and <CODE>Matrix&lt;T&gt;(size_t n,
size_t m)</CODE> constructors, because they initialize their elements with the
copy constructor, making each element a copy of a default constructed object.
For most classes this distinction is not important, though. If the
<CODE>is_simple</CODE> flag is set, then the elements will not be destroyed by
the vector or matrix destructors either. This improves the efficiency of
working with standard numeric types, where it is not necessary to go through
the trouble of looping through the data, and calling the destructor for each
element.</P>

<P>The following types have specializations of this structure:
<CODE>bool</CODE>, <CODE>char</CODE>, <CODE>signed char</CODE>, <CODE>unsigned
char</CODE>, <CODE>short</CODE>, <CODE>unsigned short</CODE>, <CODE>int</CODE>,
<CODE>unsigned int</CODE>, <CODE>long</CODE>, <CODE>unsigned long</CODE>,
<CODE>float</CODE>, <CODE>double</CODE>,
<CODE>std::complex&lt;float&gt;</CODE>, and
<CODE>std::complex&lt;double&gt;</CODE>.</P> 

<H3>4.1.2. Histogram</H3>

<P>This support class allows you to construct histograms of vectors. The
constructor allows you to set the minimum and maximum values of the histogram
to be produced, and the number of bins to be used.</P>

<H3>Constructors.</H3>

<H4><CODE>explicit Histogram(double low = 0, double high = 0, size_t bins =
	0)</CODE></H4>
<P>Initializes the histogram to a range, and sets the number of bins. If the
optional range parameters are not set, then the class will determine these
values from the vector that is histogrammed. If the number of bins is not set,
or is set to zero, then the number of bins is calculated according to</P>

<DIV CLASS=sc><CODE>
<P>n = exp(0.626 + 0.41 * log(m - 1)</P>
</CODE></DIV>

<P>where <CODE>m</CODE> is the number of elements in the histogrammed vector
falling in the closed interval <CODE>(low, high)</CODE>.</P>

<H4><CODE>Histogram(const Histogram& hist)</CODE></H4>
<P>The copy constructor copies the parameters that are set for
<CODE>hist</CODE>.</P>

<H3>Member functions and operators.</H3>

<H4><CODE>Histogram& operator=(const Histogram& hist)</CODE></H4>
<P>The assignment operator copies the parameters from one histogram to
another.</P>

<H4><CODE>void set_range(double low, double high)</CODE></H4>
<P>Use this function to set, or reset the range of an already constructed
histogram object. If <CODE>low</CODE> is not less than <CODE>high</CODE>, then
this sets the object to determine the values from the vector to be
histogrammed.</P>

<H4><CODE>void set_bins(size_t bins)</CODE></H4>
<P>Use this to set, or reset the number of bins to be used for histogramming.
If <CODE>bins</CODE> is zero, then this sets the object to determine the
number of bins from the vector to be histogrammed.

<H4><CODE>double low() const</CODE></H4>
<P>Returns the low edge of the range.</P>

<H4><CODE>double high() const</CODE></H4>
<P>Returns the high edge of the range.</P>

<H4><CODE>size_t bins() const</CODE></H4>
<P>Returns the number of bins the object is set to.</P>

<H4><CODE>template &lt;class T&gt; Vector&lt;int&gt; make_hist(const
    Vector&lt;T&gt;&amp; x) const</CODE></H4>
<P>This returns a vector of integers indicating the number of elements found in
each bin of the histogram. The range corresponding to each bin is simply
<CODE>(high - low) / bins</CODE>. Thus bin <CODE>n</CODE> corresponds to the
range:</P>

<DIV CLASS=sc><CODE>
<P>low + n * (high - low) / bins</P>
</CODE></DIV>

<P>through</P>

<DIV CLASS=sc><CODE>
<P>low + (n + 1) * (high - low) / bins</P>
</CODE></DIV>

<H3>4.1.3. IndirectComp&lt;T&gt;</H3>

<P>This function object compares two integers by comparing the elements of a
vector with indices given by those integers. This function object is used by
the support function <CODE>Index()</CODE> to create a vector of integers sorted
according to the ordering that would sort the vector passed to the
function.</P>

<H3>Constructors.</H3>

<H4><CODE>IndirectComp&lt;T&gt;()</CODE></H4>
<P>The default constructor just creates the object. A vector can be attached
later using the <CODE>attach()</CODE> member function.</P>

<H4><CODE>IndirectComp&lt;T&gt;(const IndirectComp&lt;T&gt;&amp;
    icomp)</CODE></H4>
<P>The copy constructor attaches the vector attached to <CODE>icomp</CODE> to
the new object.</P>

<H4><CODE>IndirectComp&lt;T&gt;(const Vector&lt;T&gt;&amp; x)</CODE></H4>
<P>This constructor attaches the vector <CODE>x</CODE> to the function object.
This means that the <CODE>IndirectComp</CODE> object contains an iterator to
the beginning of the vector. If this function object is explicitely used, keep
in mind that the internal iterator will be invalidated if anything happens to
the attached vector that would cause its view to be changed.</P>

<H3>Member functions and operators.</H3>

<H4><CODE>void attach(const Vector&lt;T&gt;&amp; x)</CODE></H4>
<P>This attaches a vector to the function object, by storing an iterator to the
beginning of the vector.</P>

<H4><CODE>bool operator()(int a, int b) const</CODE></H4>
<P>The function call operator takes two integers, <CODE>a</CODE> and
<CODE>b</CODE>, and returns <CODE>true</CODE> if <CODE>x[a] &lt; x[b]</CODE>,
or <CODE>false</CODE> otherwise. Note that if either <CODE>a</CODE> or
<CODE>b</CODE> is negative, or greater than the size of the attached vector,
then this will result in the vector being indexed out of bounds.</P>

<H2>4.2. Support functions.</H2>

<H4><CODE>template &lt;class T&gt; T Zero()</CODE></H4>
<P>This function returns an object of type T. For each instantiation of this
function, a static object of the appropriate type is created. The function
returns a copy of this object. The static object is decared in the function
without an explicit initialization. This means that the memory occupied by the
object is first initialized with zeros, and then the default constructor is
called (assuming it is a class with a constructor). This means that any
standard types, including pointers and complex numbers, will be set to zero.
Any classes or structures without constructors will have all their data members
set to zero, and any classes with constructors will be constructed with their
default constructor. This function is used by the <CODE>Vector&lt;T&gt;</CODE>
and <CODE>Matrix&lt;T&gt;</CODE> classes for initialization when no specific
value is indicated.</P>

<P>Note that this template function has no arguments, so the template parameter
must be specified when the function is called. For example:</P>

<DIV CLASS=sc><CODE>
string s = Zero&lt;string&gt;();
</CODE></DIV>
  
<H4><CODE>void ReadBinary(const string&amp; filename, Vector&lt;T&gt;&amp;
    array, size_t skip)</CODE></H4>
<P>This reads a binary file into a vector. Like the <CODE>read()</CODE> member
function, this function reshapes the vector to the appropriate size. The file
should not be open when the function is called. The parameter
<CODE>skip</CODE>, indicates the number of bytes that should be skipped before
reading begins.</P>

<H4><CODE>void WriteBinary(const string&amp; filename, const
    Vector&lt;T&gt;&amp; array)</CODE></H4>
<P>This outputs a vector to a binary file. The file should not be open when the
function is called.</P>

<H4><CODE>void ReadBinary(const string&amp; filename, Matrix&lt;T&gt;&amp;
    array, size_t skip)</CODE></H4>
<P>This reads a binary file into a matrix. Like the <CODE>read()</CODE> member
function, this function reshapes the matrix to a single row of the appropriate
size. The file should not be open when the function is called. The parameter
<CODE>skip</CODE>, indicates the number of bytes that should be skipped before
reading begins.</P>

<H4><CODE>void WriteBinary(const string&amp; filename, const
    Matrix&lt;T&gt;&amp; array)</CODE></H4>
<P>This outputs a matrix to a binary file. The data is output in row major
format, meaning that the zeroth row is output sequentially, followed by the
first row, etc... The file should not be open when the function is called.</P>

<H4><CODE>void Stat(const Vector&lt;T&gt;&amp; x, double&amp; m, double&amp;
    var)</CODE></H4>
<P>Calculates the mean and variance of the vector <CODE>x</CODE>.
<CODE>T</CODE> must be a real type promotable to <CODE>double</CODE>. The mean
and variance are stored in <CODE>m</CODE> and <CODE>var</CODE>,
respectively.</P>

<H4><CODE>Vector&lt;T&gt; Sort(const Vector&lt;T&gt;&amp; x)</CODE></H4>
<P>This uses the <CODE>std::sort()</CODE> routine to do an out-of-place sort on
<CODE>x</CODE>. This will often be faster than doing an in-place sort with the
<CODE>sort()</CODE> member function, because this guarantees that standard
pointers will be used instead of iterators.</P>

<H4><CODE>Vector&lt;int&gt; Index(const Vector&lt;T&gt;&amp; x)</CODE></H4>
<P>This returns a vector of integers <CODE>indx</CODE>, such that
<CODE>x[indx[I]]</CODE> gives the vector <CODE>x</CODE> in sorted order. This
function uses the <CODE>std::sort()</CODE> routine, along with the support
function object <CODE>IndirectComp&lt;T&gt;</CODE> to do the sorting. The
sorting is done with standard pointers.</P>

<H4><CODE>Matrix&lt;T&gt; MatMult(const Matrix&lt;T&gt;&amp; x, const
    Matrix&lt;T&gt;&amp; y)</CODE></H4>
<P>This performs standard matrix multiplication. The result is an <CODE>n X
m</CODE> matrix, where <CODE>n</CODE> is the number of rows in </CODE>x</CODE>,
and <CODE>m</CODE> is the number of columns in <CODE>y</CODE>.</P>

<H4><CODE>Vector&lt;T&gt; MatMult(const Vector&lt;T&gt;&amp; x, const
    Matrix&lt;T&gt;&amp; y)</CODE></H4>
<P>This performs matrix multiplication between a vector and a matrix. The
vector is treated as a matrix with one row. The result is a vector whose size
is equal to the number of columns in <CODE>y</CODE>.</P>

<H4><CODE>Vector&lt;T&gt; MatMult(const Matrix&lt;T&gt;&amp; x, const
    Vector&lt;T&gt;&amp; y)</CODE></H4>
<P>This performs matrix multiplication between a matrix and a vector. The
vector is treated as a matrix with one column. The result is a vector whose
size is equal to the number of rows in <CODE>x</CODE>.</P>

<H4><CODE>Matrix&lt;T&gt; MatMult(const Vector&lt;T&gt;&amp; x, const
    Vector&lt;T&gt;&amp; y)</CODE></H4>
<P>This calculates the direct product of two vectors. The result is an <CODE>n
X m</CODE> matrix, where <CODE>n</CODE> is the size of <CODE>x</CODE>, and
<CODE>m</CODE> is the size of <CODE>y</CODE>.</P>

<H4><CODE>T DotProduct(const Vector&lt;T&gt;&amp; x, const Vector&lt;T&gt;&amp;
    y)</CODE></H4>
<P>This calculates the scalar product of two vectors. Both vectors must be the
same size.</P>

<P><A HREF="VM_Types.htm">Next Section</A></P>
<P><A HREF="VecMat.htm">Back to Index</A></P>

</BODY>
</HTML>