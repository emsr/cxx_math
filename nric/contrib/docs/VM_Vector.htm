<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
  "http://www.w3.org/TR/REC-html40/transitional.dtd">
<HTML>
<HEAD>
  <TITLE>VecMat - Vector&lt;T&gt;</TITLE>
  <META HTTP-EQUIV="Content-Type" CONTENT="text/html;charset=iso-8859-1">
  <META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">
  <META NAME="Author" CONTENT="Kevin Dolan">
  <LINK HREF="vecmat.css" REL="stylesheet" TYPE="text/css">
</HEAD>

<BODY>

<H2>3.1. Vector&lt;T&gt;</H2>

<P>This is a templatized class for viewing data as a vector.
 A vector, in general, does not have its own data. Instead, it views a block of
data in a certain way. It is therefore possible to have multiple vectors that
view the same data, or even to have a mixture of vectors and matrices that all
view the same data. Class <CODE>T</CODE> must have a public default
constructor, copy constructor, destructor, and assignment operator. Many of the
operators and member functions will only work properly for types that behave
like standard numeric types.</P>

<H3>3.1.1. Constructors.</H3>

<H4><CODE>Vector&lt;T&gt;()</CODE></H4>
<P>This creates an empty vector.</P>

<H4><CODE>Vector&lt;T&gt;(size_t n)</CODE></H4>
<P>This constructor creates a vector of <CODE>n</CODE> elements. If
<CODE>T</CODE> is a standard numeric type, pointer, or any type without a
constructor, including <CODE>std::complex&lt;T&gt;</CODE>, then the vector will
be initialized to zero. If not, then the elements are initialized with a
default constructed object. This constructor uses the
<CODE>Zero&lt;T&gt;()</CODE> function to obtain the value to initialize to. Use
of this contructor is therefore equivelent to <CODE>Vector&lt;T&gt;
x(Zero&lt;T&gt;(), n)</CODE>.</P>

<H4><CODE>Vector&lt;T&gt;(const T&amp; a, size_t n)</CODE></H4>
<P>This creates a vector of size <CODE>n</CODE>, with each element initialized
to the value <CODE>a</CODE>. This initialization is done through the copy
constructor of class <CODE>T</CODE>.</P>

<H4><CODE>Vector&lt;T&gt;(NoInit, size_t n)</CODE></H4>
<P>This creates a vector of size <CODE>n</CODE>, with each element initialized
with the default constructor of class <CODE>T</CODE>. If class <CODE>T</CODE>
has a specialized version of the <CODE>VMTraits&lt;T&gt;</CODE> structure, with
the flag <CODE>is_simple</CODE> set to <CODE>true</CODE>, then the elements
will not be initialized at all. This flag is set for all the standard numeric
types, including <CODE>std::complex&lt;float&gt;</CODE> and
<CODE>std::complex&lt;double&gt;</CODE>.</P>

<H4><CODE>Vector&lt;T&gt;(const T* a, size_t n, ptrdiff_t s = 1)</CODE></H4>
<P>This creates a vector of size <CODE>n</CODE> from a C-style array given by
the pointer <CODE>a</CODE>. The data is copied with the copy constructor of
type <CODE>T</CODE>, and it is up to the user to make sure the array actually
has <CODE>n</CODE> elements. The optional parameter <CODE>s</CODE> allows for
copying from arrays with strides other than one.</P>

<H4><CODE>Vector&lt;T&gt;(const T&amp; start, const T&amp; incr,
    size_t n)</CODE></H4>
<P>This creates a vector of length <CODE>n</CODE>, such that the zeroth element
is set to <CODE>start</CODE>, and each element after is incremented by
<CODE>incr</CODE>. Copying of these values is done with the copy constructor of
type <CODE>T</CODE>.</P>

<H4><CODE>Vector&lt;T&gt;(const Vector&lt;T&gt;&amp; rhs)</CODE></H4>
<P>The copy constructor makes a shallow copy of the vector <CODE>rhs</CODE>.
This means that it views the same data as <CODE>rhs</CODE>, in exactly the same
way. The primary purpose of this constructor is for making permanent versions
of returned temporary vectors, for example:</P>

<DIV CLASS=sc><CODE>
<P>Vec_DP x(4.5, 10), y(2.5, 10);</P>
<P>Vec_DP z(x + y);</P>
</CODE></DIV>

<H4><CODE>Vector&lt;complex&lt;T&gt; &gt;(const Vector&lt;T&gt;&amp; re, const
    Vector&lt;T&gt;&amp; im)</CODE></H4>
<P>This creates a complex vector from two real vectors. It will only work
properly for the following types: <CODE>float</CODE> and
<CODE>double</CODE>.</P>
 
<H4><CODE>Vector&lt;complex&lt;T&gt; &gt;(const Vector&lt;T&gt;&amp; re, const
    T&amp; im)</CODE></H4>
<P>This creates a complex vector from a real vector, and a scalar. It also only
works for the types listed above.</P>

<H3>3.1.2. Member functions.</H3>

<H4><CODE>Vector&lt;T&gt;&amp; apply(T (*fn)(T x))</CODE></H4>
<P>This function applies the function <CODE>fn</CODE> to each element of the
vector it is called for. The function must take one argument of type
<CODE>T</CODE>, and return a value that can be cast to type <CODE>T</CODE>.
This member function returns itself by reference, allowing for cascading.</P>

<H4><CODE>Vector&lt;T&gt;&amp; apply(T (*fn)(const T&amp; x))</CODE></H4>
<P>This function applies the function <CODE>fn</CODE> to each element of the
vector it is called for. The function must take one argument of type
<CODE>T&amp;</CODE>, and return a value that can be cast to type
<CODE>T</CODE>.This member function returns itself by reference, allowing for
cascading.</P>

<H4><CODE>Vector&lt;T&gt; copy()</CODE></H4>
<P>This function returns a deep copy of the vector it is called for. This means
that the returned vector will be the only object referencing its data, and that
its stride will be one. Copying is done with the copy constructor of type
<CODE>T</CODE>.</P>

<H4><CODE>bool isdeap() const</CODE></H4>
<P>Returns <CODE>true</CODE> if the following criteria are met:</P>

<UL>
  <LI>The vector must be the only object referencing its data.</LI>
  <LI>The vector must have a stride of one.</LI>
  <LI>The vector must start at the beginning of its data object, and have
      the same size as the data object.</LI></UL>

<P>If any of these criteria are not met, <CODE>false</CODE> is returned.</P>

<H4><CODE>void makedeep()</CODE></H4>
<P>This function causes a vector to become a deep copy of itself. It now
references its own data, and has a stride of one. Its original data is not
changed, although it is deallocated if the vector it is called for is the only
object referencing it. If new memory is allocated, then copying is done with
the copy constructor of type <CODE>T</CODE>.</P>

<H4><CODE>void reference(const Vector&lt;T&gt;&amp; x)</CODE></H4>
<P>This causes the vector it is called for to become a shallow copy of
<CODE>x</CODE>. This is very useful for setting a vector to a returned
temporary, for example:</P>

<DIV CLASS=sc><CODE>
<P>Vec_INT x(2, 10), y;</P>
<P>y.reference(x + 2);</P>
</CODE></DIV>

<H4><CODE>void free()</CODE></H4>
<P>This makes a vector size zero, deallocating any memory it is using if it is
the only object referencing its data.</P>

<H4><CODE>void reshape(size_t n)</CODE></H4>
<P>This changes the size of the vector to <CODE>n</CODE>. The vector no longer
views its old data. Instead, it has new data of its own. The new values are
initialized with the <CODE>Zero&lt;T&gt;()</CODE> function, using the copy
constructor of type <CODE>T</CODE>.</P>

<H4><CODE>void resize(size_t n)</CODE></H4>
<P>The same as <CODE>reshape()</CODE>, except that the data is copied. If the
vector is made shorter, then the copied data is truncated. If it is made
longer, then the new values will be initialized with the
<CODE>Zero&lt;T&gt;()</CODE> function. Copying is done with the copy
constructor of type <CODE>T</CODE>.</P>

<H4><CODE>Vector&lt;T&gt; slice(size_t b, size_t n, ptrdiff_t s)
    const</CODE></H4>
<P>This returns a new view of the data that is a slice of the current view.
<CODE>b</CODE> is the element that the slice should start with, <CODE>n</CODE>
is the number of elements in the new slice, and <CODE>s</CODE> is the stride of
the slice, that is, the number of elements that should be incremented by to get
to the next element of the slice. Note that <CODE>s</CODE> can be negative. For
example, the following views a vector in reverse order:</P>

<DIV CLASS=sc><CODE>
<P>Vec_DP x(0.0, 0.5, 10);</P>
<P>Vec_DP y = x.slice(9, 10, -1);</P>
</CODE></DIV>

<H4><CODE>Vector&lt;T&gt; real() const</CODE></H4>
<P>This returns the real part of a <CODE>complex&lt;T&gt;</CODE> vector. Note
that this returns a deep copy. It is not possible to view the real and
imaginary parts of complex vectors as real vectors. This function is only
defined for <CODE>complex&lt;float&gt;</CODE> and
<CODE>complex&lt;double&gt;</CODE>. Attempting to use it with other complex
types, or with non-complex types, will almost certainly result in compiler
errors.</P>

<H4><CODE>Vector&lt;T&gt; imag() const</CODE></H4>
<P>This returns the imaginary part of a <CODE>complex&lt;T&gt;</CODE> vector.
The same limitations apply as for <CODE>real()</CODE>.</P>

<H4><CODE>size_t size() const</CODE></H4>
<P>This returns the size of the vector.</P>

<H4><CODE>ptrdiff_t stride() const</CODE></H4>
<P>This returns the stride of the vector.</P>

<H4><CODE>T* data()</CODE></H4>
<P>This returns a pointer to the beginning of the vector's data. It is up to
the user to keep track of the stride.</P>

<H4><CODE>const T* data() const</CODE></H4>
<P>The constant version of this member function returns a constant pointer.</P>

<H4><CODE>T sum() const</CODE></H4>
<P>This returns the sum of the elements of the vector using the <CODE>+=</CODE>
operator of type <CODE>T</CODE>. The vector must not be empty.</P>

<H4><CODE>T min() const</CODE></H4>
<P>This returns the smallest element in the vector, using the <CODE>&lt;</CODE>
operator of type <CODE>T</CODE>. The vector must not be empty.</P>

<H4><CODE>T max() const</CODE></H4>
<P>This returns the largest element in the vector, using the <CODE>&lt;</CODE>
operator of type <CODE>T</CODE>. The vector must not be empty.</P>

<H4><CODE>Vector&lt;T&gt; rotate(ptrdiff_t n) const</CODE></H4>
<P>This returns a copy of the original vector rotated by <CODE>n</CODE> points.
This means that <CODE>R[i] = V[(i + n) % V.size()]</CODE>, where <CODE>V</CODE>
is the original vector, and <CODE>R</CODE> is the rotated vector.</P> 

<H4><CODE>Vector&lt;T&gt; delta() const</CODE></H4>
<P>This returns a vector such that <CODE>D[i] = V[i + 1] - V[i]</CODE>. The
last point is given by <CODE>D[n - 1] = V[0] - V[n - 1]</CODE>, as though the
vecter were periodic.</P>

<H4><CODE>Vector&lt;T&gt; cumsum() const</CODE></H4>
<P>This returns the cumulitive sum of the vector. Each element of the new
vector is the sum of all elements of the original vector up to, and including,
that element.</P>

<H4><CODE>Matrix&lt;T&gt; rowmat() const</CODE></H4>
<P>This creates a matrix view of the vector's data. The data is represented as
a matrix with one row, and <CODE>n</CODE> columns, where <CODE>n</CODE> is the
size of the vector.</P>

<H4><CODE>Matrix&lt;T&gt; colmat() const</CODE></H4>
<P>This creates a matrix view of the vector's data. The data is represented as
a matrix with one column and <CODE>n</CODE> rows, where <CODE>n</CODE> is the
size of the vector.</P>

<H4><CODE>Matrix&lt;T&gt; matrix(size_t b, size_t n, size_t m, ptrdiff_t rs,
    ptrdiff_t cs) const</CODE></H4>
<P>This creates a matrix view of the vector's data. The data is represented as
a matrix with <CODE>n</CODE> rows and <CODE>m</CODE> columns, where
<CODE>b</CODE> is the index of element <CODE>(0, 0)</CODE> of the created
matrix, <CODE>rs</CODE> is the number of elements between adjacent rows, and
<CODE>cs</CODE> is the number of elements between adjacent columns.</P>

<H4><CODE>void sort()</CODE></H4>
<P>This sorts the elements of the vector using the
<CODE>Vector&lt;T&gt;::iterator</CODE> class, and the <EM>Standard Template
Library</EM> function <CODE>std::sort(Vector&lt;T&gt;::iterator a,
Vector&lt;T&gt;::iterator b)</CODE>. <CODE>T</CODE> must have an available
<CODE>operator&lt;()</CODE>.</P>

<H4><CODE>Vector&lt;T&gt;::iterator begin()</CODE></H4>
<P>This returns an iterator to the beginning of the vector.</P>

<H4><CODE>Vector&lt;T&gt;::iterator end()</CODE></H4>
<P>This returns an iterator to the end of the vector.</P>

<H4><CODE>Vector&lt;T&gt;::const_iterator begin() const</CODE></H4>
<P>This returns a constant iterator to the beginning of the vector.</P>

<H4><CODE>Vector&lt;T&gt;::const_iterator end() const</CODE></H4>
<P>This returns a constant iterator to the end of the vector.</P>

<H4><CODE>void read(istream&amp; in)</CODE></H4>
<P>This reads the contents of a stream into the vector. The vector is reshaped
to a base size of 1024, and if this is insufficient for reading in the entire
stream, the vector is resized by a factor of two, and so on. When the full
stream is read in, the vector is resized, if necessary, to the number of
elements read. This results in the stream being read to the end, so you may
need to use the <CODE>clear()</CODE> member function if you wish to continue
using the stream.</P>

<H4><CODE>void read(istream&amp; in, size_t ncount)</CODE></H4>
<P>This reads the contents of a stream into the vector. The vector is reshaped
to size <CODE>ncount</CODE>, and the stream is read in until either the end of
the stream is reached, or until <CODE>ncount</CODE> elements have been read.
When the full stream is read in, the vector is resized, if necessary, to the
number of elements read. This function may result in the stream being read to
the end, so you may need to use the <CODE>clear()</CODE> member function if you
wish to continue using the stream.</P>

<H4><CODE>void write(ostream&amp; out) const</CODE></H4>
<P>This outputs the contents of the vector to a stream. The elements are
separated with a carriage return delimiter.</P>

<H4><CODE>template &lt;class G&gt; Vector&lt;T&gt;&amp; fill(const G&amp;
    gen)</CODE></H4>
<P>This function fills the vector with values from the generator
<CODE>gen</CODE>. Class <CODE>G</CODE> must have a function call operator which
takes no arguments, and returns a value that can be cast to type
<CODE>T</CODE>. This includes the four random number generator classes
<CODE>BaseGen</CODE>, <CODE>IntGen</CODE>, <CODE>UniformGen</CODE>, and
<CODE>NormalGen</CODE>. Ordinary function pointers can be passed as well, but
note that the compiler will not be able to resolve the function if it is
overloaded. This member function returns itself by reference, allowing for
cascading.</P>

<H4><CODE>template &lt;class G&gt; Vector&lt;T&gt;&amp; fill2(const F&amp;
    fn)</CODE></H4>
<P>This function applies the function object <CODE>fn</CODE> to each element of
the vector it is called for. Class <CODE>F</CODE> must have a function call
operator which takes one argument of type <CODE>T</CODE>, and returns a value
that can be cast to type <CODE>T</CODE>. Ordinary function pointers can be
passed as well, but note that the compiler will not be able to resolve the
function if it is overloaded. This member function returns itself by reference,
allowing for cascading.</P>

<H4><CODE>template &lt;class U&gt; Vector&lt;U&gt; convert(const U&amp; a)
    const</CODE></H4>
<P>This creates a vector of type <CODE>U</CODE> from a vector of type
<CODE>T</CODE>. It must be possible to explicitly cast type <CODE>T</CODE> to
type <CODE>U</CODE>, where <CODE>T</CODE> is the type of the original vector.
<CODE>a</CODE> is a dummy value that is used simply to tell the compiler what
type to convert to. Example:</P>

<DIV CLASS=sc><CODE>
<P>Vec_DP x(4.5, 10);</P>
<P>Vec_SP y = x.convert(float());</P>
</CODE></DIV>

<H4><CODE>template &lt;class U&gt; Vector&lt;U&gt; shallow_cast(const U&amp; a)
    const</CODE></H4>
<P>This creates a shallow copy of the vector it is called for, but of type
<CODE>Vector&lt;U&gt;</CODE>. This is done using pointer casting, which means
the new vector views the same data as the original, but views it as data of
type <CODE>U</CODE> instead of as type <CODE>T</CODE>. For example, the
internal representation if <CODE>int</CODE> and <CODE>long</CODE> is the same
on many platforms. This function allows you to view a vector of type
<CODE>int</CODE> as a vector of type <CODE>long</CODE>, without making a
seperate copy of the data. If used for non-standard types with non-trivial
constructors, this function has the potential to cause some serious bugs, since
the wrong destructor may be called to destroy the vector elements. Types
<CODE>T</CODE> and <CODE>U</CODE> must have the same size.</P>

<H3>3.1.3. Overloaded operators.</H3>

<H4><CODE>Vector&lt;T&gt;&amp; operator=(const Vector&lt;T&gt;&amp;
    rhs)</CODE></H4>
<P>This uses the assignment operator of type <CODE>T</CODE> to do an
element-by-element copy of <CODE>rhs</CODE> to the vector it is called for,
which is the left hand side of the expression. The vectors must be the same
size.</P>

<H4><CODE>Vector&lt;T&gt;&amp; operator=(const T&amp; rhs)</CODE></H4>
<P>This uses the assignment operator of type <CODE>T</CODE> to copy
<CODE>rhs</CODE> to each element of the vector it is called for.</P>

<CODE><STRONG>
<P>Vector&lt;T&gt;&amp; operator+=(const Vector&lt;T&gt;&amp; rhs)</P>
<P>Vector&lt;T&gt;&amp; operator-=(const Vector&lt;T&gt;&amp; rhs)</P>
<P>Vector&lt;T&gt;&amp; operator*=(const Vector&lt;T&gt;&amp; rhs)</P>
<P>Vector&lt;T&gt;&amp; operator/=(const Vector&lt;T&gt;&amp; rhs)</P>
<P>Vector&lt;T&gt;&amp; operator%=(const Vector&lt;T&gt;&amp; rhs)</P>
<P>Vector&lt;T&gt;&amp; operator&amp;=(const Vector&lt;T&gt;&amp; rhs)</P>
<P>Vector&lt;T&gt;&amp; operator^=(const Vector&lt;T&gt;&amp; rhs)</P>
<P>Vector&lt;T&gt;&amp; operator|=(const Vector&lt;T&gt;&amp; rhs)</P>
<P>Vector&lt;T&gt;&amp; operator&gt;&gt;=(const Vector&lt;T&gt;&amp; rhs)</P>
<P>Vector&lt;T&gt;&amp; operator&lt;&lt;=(const Vector&lt;T&gt;&amp; rhs)</P>
</STRONG></CODE>
<P>These operators use the arithmetic assignment operators of type
<CODE>T</CODE> to do element-by-element arithmetic assignment. The vectors must
be the same size.</P>

<CODE><STRONG>
<P>Vector&lt;T&gt;&amp; operator+=(const T&amp; rhs)</P>
<P>Vector&lt;T&gt;&amp; operator-=(const T&amp; rhs)</P>
<P>Vector&lt;T&gt;&amp; operator*=(const T&amp; rhs)</P>
<P>Vector&lt;T&gt;&amp; operator/=(const T&amp; rhs)</P>
<P>Vector&lt;T&gt;&amp; operator%=(const T&amp; rhs)</P>
<P>Vector&lt;T&gt;&amp; operator&amp;=(const T&amp; rhs)</P>
<P>Vector&lt;T&gt;&amp; operator^=(const T&amp; rhs)</P>
<P>Vector&lt;T&gt;&amp; operator|=(const T&amp; rhs)</P>
<P>Vector&lt;T&gt;&amp; operator&gt;&gt;=(const T&amp; rhs)</P>
<P>Vector&lt;T&gt;&amp; operator&lt;&lt;=(const T&amp; rhs)</P>
</STRONG></CODE>

<P>These operators use the arithmetic assignment operators of type
<CODE>T</CODE> to perform the corresponding operation on each element of the
vector.</P>

<H4><CODE>Vector&lt;T&gt; operator+() const</CODE></H4>
<P>This returns a vector such that each element is the result of applying the
unary <CODE>+</CODE> operator to each element of the original vector. This
operator must be available for type </CODE>T</CODE>.</P>

<H4><CODE>Vector&lt;T&gt; operator-() const</CODE></H4>
<P>This returns a vector such that each element is the negation of the original
value. The unary <CODE>-</CODE> operator must be available for type
</CODE>T</CODE>.</P>

<H4><CODE>Vector&lt;bool&gt; operator!() const</CODE></H4>
<P>This returns a vector of <CODE>bool</CODE> values such that <CODE>B[i] =
!V[i]</CODE>, where <CODE>B</CODE> is the returned vector, and <CODE>V</CODE>
is the original vector. This operator must be available for type
</CODE>T</CODE>.</P>

<H4><CODE>Vector&lt;T&gt; operator~() const</CODE></H4>
<P>This returns a vector by applying the <CODE>~</CODE> operator to each
element. This operator must be available for type </CODE>T</CODE>.</P>

<H4><CODE>T&amp; operator[](size_t i)</CODE></H4>
<P>This returns a reference to the <CODE>i</CODE>th element of the vector.</P>

<H4><CODE>const T&amp; operator[](size_t i) const</CODE></H4>
<P>The constant version of this operator returns a constant reference.</P>

<H3>3.1.4. Global Functions.</H3>

<P>These functions mimic the Standard Library functions of the same name,
performing the associated operation on every element of the vector.</P>

<CODE><STRONG>
<P>Vector&lt;T&gt abs(const Vector&lt;T&gt;&amp x)</P>
<P>Vector&lt;T&gt; abs(const Vector&lt;complex&lt;T&gt; &gt;&amp; x)</P>
<P>Vector&lt;T&gt; acos(const Vector&lt;T&gt;&amp; x)</P>
<P>Vector&lt;T&gt; asin(const Vector&lt;T&gt;&amp; x)</P>
<P>Vector&lt;T&gt; atan(const Vector&lt;T&gt;&amp; x)</P>
<P>Vector&lt;T&gt; atan2(const Vector&lt;T&gt;&amp; x, const
Vector&lt;T&gt;&amp; y)</P>
<P>Vector&lt;T&gt; atan2(const Vector&lt;T&gt;&amp; x, const T&amp; y)</P>
<P>Vector&lt;T&gt; atan2(const T&amp; x, const Vector&lt;T&gt;&amp; y)</P>
<P>Vector&ltT&gt; cos(const Vector&lt;T&gt;&amp; x)</P>
<P>Vector&lt;T&gt; cosh(const Vector&lt;T&gt;&amp; x)</P>
<P>Vector&lt;T&gt; exp(const Vector&lt;T&gt;&amp; x)</P>
<P>Vector&lt;T&gt; log(const Vector&lt;T&gt;&amp; x)</P>
<P>Vector&lt;T&gt; log10(const Vector&lt;T&gt;&amp; x)</P>
<P>Vector&lt;T&gt; pow(const Vector&lt;T&gt;&amp; x, const Vector&lt;T&gt;&amp;
y)</P>
<P>Vector&lt;T&gt; pow(const Vector&lt;T&gt;&amp; x, const T&amp; y)</P>
<P>Vector&lt;T&gt; pow(const T&amp; x, const Vector&lt;T&gt;&amp; y)</P>
<P>Vector&lt;T&gt; sin(const Vector&lt;T&gt;&amp; x)</P>
<P>Vector&lt;T&gt; sinh(const Vector&lt;T&gt;&amp; x)</P>
<P>Vector&lt;T&gt; sqrt(const Vector&lt;T&gt;&amp; x)</P>
<P>Vector&lt;T&gt; tan(const Vector&lt;T&gt;&amp; x)</P>
<P>Vector&lt;T&gt; tanh(const Vector&lt;T&gt;&amp; x)</P>
<P>Vector&lt;T&gt; arg(const Vector&lt;complex&lt;T&gt; &gt;&amp; x)</P>
<P>Vector&lt;T&gt; norm(const Vector&lt;complex&lt;T&gt; &gt;&amp; x)</P>
<P>Vector&lt;complex&lt;T&gt; &gt; polar(const Vector&lt;T&gt;&amp; rho, const
Vector&lt;T&gt;&amp; theta)</P>
<P>Vector&lt;complex&lt;T&gt; &gt; polar(const Vector&lt;T&gt;&amp; rho, const
T&amp; theta)</P>
<P>Vector&lt;complex&lt;T&gt; &gt; polar(const T&amp; rho, const
Vector&lt;T&gt;&amp; theta)</P>
<P>Vector&lt;complex&lt;T&gt; &gt; conj(const Vector&lt;complex&lt;T&gt;
&gt;&amp; x)</P>
<P>Vector&lt;T&gt; real(const Vector&lt;complex&lt;T&gt; &gt;&amp; x)</P>
<P>Vector&lt;T&gt; imag(const Vector&lt;complex&lt;T&gt; &gt;&amp; x)</P>
</STRONG></CODE>

<P>Note that the <CODE>real()</CODE> and <CODE>imag()</CODE> functions only
work for complex types with a specialization of the
<CODE>VMTraits&lt;T&gt;</CODE> structure. Similarly, the complex version of the
<CODE>abs()</CODE> function only works for these types. Attempting to use these
functions for other types will probably result in compiler errors.</P>

<H3>3.1.5. Global Operators.</H3>

<H3>Binary Operators For Two Vectors.</H3>

<P>These operators perform the associated operation element by element. The two
vectors must have the same size. The result is a new vector with the
appropriate values.</P>

<CODE><STRONG>
<P>Vector&lt;T&gt; operator+(const Vector&lt;T&gt;&amp; lhs, const
Vector&lt;T&gt;&amp; rhs)</P>
<P>Vector&lt;T&gt; operator-(const Vector&lt;T&gt;&amp; lhs, const
Vector&lt;T&gt;&amp; rhs)</P>
<P>Vector&lt;T&gt; operator*(const Vector&lt;T&gt;&amp; lhs, const
Vector&lt;T&gt;&amp; rhs)</P>
<P>Vector&lt;T&gt; operator/(const Vector&lt;T&gt;&amp; lhs, const
Vector&lt;T&gt;&amp; rhs)</P>
<P>Vector&lt;T&gt; operator%(const Vector&lt;T&gt;&amp; lhs, const
Vector&lt;T&gt;&amp; rhs)</P>
<P>Vector&lt;T&gt; operator&amp;(const Vector&lt;T&gt;&amp; lhs, const
Vector&lt;T&gt;&amp; rhs)</P>
<P>Vector&lt;T&gt; operator^(const Vector&lt;T&gt;&amp; lhs, const
Vector&lt;T&gt;&amp; rhs)</P>
<P>Vector&lt;T&gt; operator|(const Vector&lt;T&gt;&amp; lhs, const
Vector&lt;T&gt;&amp; rhs)</P>
<P>Vector&lt;T&gt; operator&lt;&lt;(const Vector&lt;T&gt;&amp; lhs, const
Vector&lt;T&gt;&amp; rhs)</P>
<P>Vector&lt;T&gt; operator&gt;&gt;(const Vector&lt;T&gt;&amp; lhs, const
Vector&lt;T&gt;&amp; rhs)</P>
<P>Vector&lt;bool&gt; operator==(const Vector&lt;T&gt;&amp; lhs, const
Vector&lt;T&gt;&amp; rhs)</P>
<P>Vector&lt;bool&gt; operator!=(const Vector&lt;T&gt;&amp; lhs, const
Vector&lt;T&gt;&amp; rhs)</P>
<P>Vector&lt;bool&gt; operator&lt;(const Vector&lt;T&gt;&amp; lhs, const
Vector&lt;T&gt;&amp; rhs)</P>
<P>Vector&lt;bool&gt; operator&gt;(const Vector&lt;T&gt;&amp; lhs, const
Vector&lt;T&gt;&amp; rhs)</P>
<P>Vector&lt;bool&gt; operator&lt;=(const Vector&lt;T&gt;&amp; lhs, const
Vector&lt;T&gt;&amp; rhs)</P>
<P>Vector&lt;bool&gt; operator&gt;=(const Vector&lt;T&gt;&amp; lhs, const
Vector&lt;T&gt;&amp; rhs)</P>
<P>Vector&lt;bool&gt; operator&amp;&amp;(const Vector&lt;T&gt;&amp; lhs, const
Vector&lt;T&gt;&amp; rhs)</P>
<P>Vector&lt;bool&gt; operator||(const Vector&lt;T&gt;&amp; lhs, const
Vector&lt;T&gt;&amp; rhs)</P>
</STRONG></CODE>

<H3>Binary Operators for Vectors and Scalers.</H3>

<P>These operators perform the associated operation element-by-element with a
scalar. The result is a new vector with the appropriate values.</P>

<CODE><STRONG>
<P>Vector&lt;T&gt; operator+(const Vector&lt;T&gt;&amp; lhs, const T&amp;
a)</P>
<P>Vector&lt;T&gt; operator+(const T&amp; a, const Vector&lt;T&gt;&amp;
rhs)</P>
<P>Vector&lt;T&gt; operator-(const Vector&lt;T&gt;&amp; lhs, const T&amp;
a)</P>
<P>Vector&lt;T&gt; operator-(const T&amp; a, const Vector&lt;T&gt;&amp;
rhs)</P>
<P>Vector&lt;T&gt; operator*(const Vector&lt;T&gt;&amp; lhs, const T&amp;
a)</P>
<P>Vector&lt;T&gt; operator*(const T&amp; a, const Vector&lt;T&gt;&amp;
rhs)</P>
<P>Vector&lt;T&gt; operator/(const Vector&lt;T&gt;&amp; lhs, const T&amp;
a)</P>
<P>Vector&lt;T&gt; operator/(const T&amp; a, const Vector&lt;T&gt;&amp;
rhs)</P>
<P>Vector&lt;T&gt; operator%(const Vector&lt;T&gt;&amp; lhs, const T&amp;
a)</P>
<P>Vector&lt;T&gt; operator%(const T&amp; a, const Vector&lt;T&gt;&amp;
rhs)</P>
<P>Vector&lt;T&gt; operator&amp;(const Vector&lt;T&gt;&amp; lhs, const T&amp;
a)</P>
<P>Vector&lt;T&gt; operator&amp;(const T&amp; a, const Vector&lt;T&gt;&amp;
rhs)</P>
<P>Vector&lt;T&gt; operator^(const Vector&lt;T&gt;&amp; lhs, const T&amp;
a)</P>
<P>Vector&lt;T&gt; operator^(const T&amp; a, const Vector&lt;T&gt;&amp;
rhs)</P>
<P>Vector&lt;T&gt; operator|(const Vector&lt;T&gt;&amp; lhs, const T&amp;
a)</P>
<P>Vector&lt;T&gt; operator|(const T&amp; a, const Vector&lt;T&gt;&amp;
rhs)</P>
<P>Vector&lt;T&gt; operator&lt;&lt;(const Vector&lt;T&gt;&amp; lhs, const
T&amp; a)</P>
<P>Vector&lt;T&gt; operator&lt;&lt;(const T&amp; a, const Vector&lt;T&gt;&amp;
rhs)</P>
<P>Vector&lt;T&gt; operator&gt;&gt;(const Vector&lt;T&gt;&amp; lhs, const
T&amp; a)</P>
<P>Vector&lt;T&gt; operator&gt;&gt;(const T&amp; a, const Vector&lt;T&gt;&amp;
rhs)</P>
<P>Vector&lt;bool&gt; operator==(const Vector&lt;T&gt;&amp; lhs, const T&amp;
a)</P>
<P>Vector&lt;bool&gt; operator==(const T&amp; a, const Vector&lt;T&gt;&amp;
rhs)</P>
<P>Vector&lt;bool&gt; operator!=(const Vector&lt;T&gt;&amp; lhs, const T&amp;
a)</P>
<P>Vector&lt;bool&gt; operator!=(const T&amp; a, const Vector&lt;T&gt;&amp;
rhs)</P>
<P>Vector&lt;bool&gt; operator&lt;(const Vector&lt;T&gt;&amp; lhs, const T&amp;
a)</P>
<P>Vector&lt;bool&gt; operator&lt;(const T&amp; a, const Vector&lt;T&gt;&amp;
rhs)</P>
<P>Vector&lt;bool&gt; operator&gt;(const Vector&lt;T&gt;&amp; lhs, const T&amp;
a)</P>
<P>Vector&lt;bool&gt; operator&gt;(const T&amp; a, const Vector&lt;T&gt;&amp;
 rhs)</P>
<P>Vector&lt;bool&gt; operator&lt;=(const Vector&lt;T&gt;&amp; lhs, const
T&amp; a)</P>
<P>Vector&lt;bool&gt; operator&lt;=(const T&amp; a, const Vector&lt;T&gt;&amp;
rhs)</P>
<P>Vector&lt;bool&gt; operator&gt;=(const Vector&lt;T&gt;&amp; lhs, const
T&amp; a)</P>
<P>Vector&lt;bool&gt; operator&gt;=(const T&amp; a, const Vector&lt;T&gt;&amp;
rhs)</P>
<P>Vector&lt;bool&gt; operator&amp;&amp;(const Vector&lt;T&gt;&amp; lhs, const
T&amp; a)</P>
<P>Vector&lt;bool&gt; operator&amp;&amp;(const T&amp; a, const
Vector&lt;T&gt;&amp; rhs)</P>
<P>Vector&lt;bool&gt; operator||(const Vector&lt;T&gt;&amp; lhs, const T&amp;
a)</P>
<P>Vector&lt;bool&gt; operator||(const T&amp; a, const Vector&lt;T&gt;&amp;
rhs)</P>
</STRONG></CODE>

<H3>Streaming IO Operators.</H3>

<P>These operators provide insertion and extraction operators for using vectors
with iostreams. The corresponding operators must exist for type
<CODE>T</CODE>.</P>

<H4><CODE>ostream&amp; operator&lt;&lt;(ostream&amp; out, const
    Vector&lt;T&gt;&amp; x)</CODE></H4>
<P>This functions identically to the <CODE>write()</CODE> member function,
except that it returns a reference to the stream, for cascading.</P>

<H4><CODE>istream&amp; operator&gt;&gt;(istream&amp; in, Vector&lt;T&gt;&amp;
    x)</CODE></H4>
<P>This reads a stream into a vector. Unlike the <CODE>read()</CODE> member
function, this does not reshape the vector. It simply reads in from the stream
until either the stream ends, or the end of the vector is reached.</P>

<P><A HREF="VM_Iterator.htm">Next Section</A></P>
<P><A HREF="VM_Classes.htm">Back to Classes</A></P>

</BODY>
</HTML>
