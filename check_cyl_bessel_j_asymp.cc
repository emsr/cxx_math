// { dg-options "-D__STDCPP_WANT_MATH_SPEC_FUNCS__" }
//
// Copyright (C) 2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING3.  If not see
// <http://www.gnu.org/licenses/>.

//  cyl_bessel_j_asymp
//  Compare against values generated by the GNU Scientific Library.
//  The GSL can be found on the web: http://www.gnu.org/software/gsl/
#include <limits>
#include <cmath>
#if defined(__TEST_DEBUG)
#  include <iostream>
#  define VERIFY(A) \
  if (!(A)) \
    { \
      std::cout << "line " << __LINE__ \
	<< "  max_abs_frac = " << max_abs_frac \
	<< std::endl; \
    }
#else
#  include <testsuite_hooks.h>
#endif
#include "../testcase.h"


// Test data for nu=0.0000000000000000.
testcase_cyl_bessel_j_asymp<double> data001[] = {
  { 0.024786686152420179, 0.0000000000000000, 1000.0000000000000 },
  { -0.0022235884953953483, 0.0000000000000000, 1900.0000000000000 },
  { -0.015055381407614771, 0.0000000000000000, 2800.0000000000000 },
  { -0.00014142036411977067, 0.0000000000000000, 3700.0000000000000 },
  { 0.011729244816310696, 0.0000000000000000, 4600.0000000000000 },
  { 0.0015370963286978037, 0.0000000000000000, 5500.0000000000000 },
  { -0.0097551678080702569, 0.0000000000000000, 6400.0000000000000 },
  { -0.0025443501697928000, 0.0000000000000000, 7300.0000000000000 },
  { 0.0083001623731810519, 0.0000000000000000, 8200.0000000000000 },
  { 0.0033227528091732878, 0.0000000000000000, 9100.0000000000000 },
  { -0.0070961603533868413, 0.0000000000000000, 10000.000000000000 },
};

// Test function for nu=0.0000000000000000.
template<typename Tp>
  void
  test001()
  {
    bool test [[gnu::unused]] = true;
    const Tp eps = std::numeric_limits<Tp>::epsilon();
    Tp max_abs_diff = -Tp(1);
    Tp max_abs_frac = -Tp(1);
    unsigned int num_datum = sizeof(data001)
			   / sizeof(testcase_cyl_bessel_j_asymp<double>);
    for (unsigned int i = 0; i < num_datum; ++i)
      {
	const Tp f = std::cyl_bessel_j_asymp(Tp(data001[i].nu), Tp(data001[i].x));
	const Tp f0 = data001[i].f0;
	const Tp diff = f - f0;
	if (std::abs(diff) > max_abs_diff)
	  max_abs_diff = std::abs(diff);
	if (std::abs(f0) > Tp(10) * eps
	 && std::abs(f) > Tp(10) * eps)
	  {
	    const Tp frac = diff / f0;
	    if (std::abs(frac) > max_abs_frac)
	      max_abs_frac = std::abs(frac);
	  }
      }
    VERIFY(max_abs_frac < Tp(0.025000000000000001));
  }

// Test data for nu=0.33333333333333331.
testcase_cyl_bessel_j_asymp<double> data002[] = {
  { 0.023824321121563609, 0.33333333333333331, 1000.0000000000000 },
  { 0.0071584075370268053, 0.33333333333333331, 1900.0000000000000 },
  { -0.013456715603520349, 0.33333333333333331, 2800.0000000000000 },
  { -0.0066804936179858899, 0.33333333333333331, 3700.0000000000000 },
  { 0.0097050196742592288, 0.33333333333333331, 4600.0000000000000 },
  { 0.0066552312262806897, 0.33333333333333331, 5500.0000000000000 },
  { -0.0074104299238116952, 0.33333333333333331, 6400.0000000000000 },
  { -0.0066960404607512005, 0.33333333333333331, 7300.0000000000000 },
  { 0.0057096958373805276, 0.33333333333333331, 8200.0000000000000 },
  { 0.0067154456842519663, 0.33333333333333331, 9100.0000000000000 },
  { -0.0043215896190661211, 0.33333333333333331, 10000.000000000000 },
};

// Test function for nu=0.33333333333333331.
template<typename Tp>
  void
  test002()
  {
    bool test [[gnu::unused]] = true;
    const Tp eps = std::numeric_limits<Tp>::epsilon();
    Tp max_abs_diff = -Tp(1);
    Tp max_abs_frac = -Tp(1);
    unsigned int num_datum = sizeof(data002)
			   / sizeof(testcase_cyl_bessel_j_asymp<double>);
    for (unsigned int i = 0; i < num_datum; ++i)
      {
	const Tp f = std::cyl_bessel_j_asymp(Tp(data002[i].nu), Tp(data002[i].x));
	const Tp f0 = data002[i].f0;
	const Tp diff = f - f0;
	if (std::abs(diff) > max_abs_diff)
	  max_abs_diff = std::abs(diff);
	if (std::abs(f0) > Tp(10) * eps
	 && std::abs(f) > Tp(10) * eps)
	  {
	    const Tp frac = diff / f0;
	    if (std::abs(frac) > max_abs_frac)
	      max_abs_frac = std::abs(frac);
	  }
      }
    VERIFY(max_abs_frac < Tp(0.025000000000000001));
  }

// Test data for nu=0.50000000000000000.
testcase_cyl_bessel_j_asymp<double> data003[] = {
  { 0.020863266605093810, 0.50000000000000000, 1000.0000000000000 },
  { 0.011274279183294303, 0.50000000000000000, 1900.0000000000000 },
  { -0.011237688800362026, 0.50000000000000000, 2800.0000000000000 },
  { -0.0093743698775864606, 0.50000000000000000, 3700.0000000000000 },
  { 0.0076535957781434386, 0.50000000000000000, 4600.0000000000000 },
  { 0.0086162329908231906, 0.50000000000000000, 5500.0000000000000 },
  { -0.0054303655146041791, 0.50000000000000000, 6400.0000000000000 },
  { -0.0081525707456279340, 0.50000000000000000, 7300.0000000000000 },
  { 0.0037783061327061056, 0.50000000000000000, 8200.0000000000000 },
  { 0.0077770917152596031, 0.50000000000000000, 9100.0000000000000 },
  { -0.0024384500245370464, 0.50000000000000000, 10000.000000000000 },
};

// Test function for nu=0.50000000000000000.
template<typename Tp>
  void
  test003()
  {
    bool test [[gnu::unused]] = true;
    const Tp eps = std::numeric_limits<Tp>::epsilon();
    Tp max_abs_diff = -Tp(1);
    Tp max_abs_frac = -Tp(1);
    unsigned int num_datum = sizeof(data003)
			   / sizeof(testcase_cyl_bessel_j_asymp<double>);
    for (unsigned int i = 0; i < num_datum; ++i)
      {
	const Tp f = std::cyl_bessel_j_asymp(Tp(data003[i].nu), Tp(data003[i].x));
	const Tp f0 = data003[i].f0;
	const Tp diff = f - f0;
	if (std::abs(diff) > max_abs_diff)
	  max_abs_diff = std::abs(diff);
	if (std::abs(f0) > Tp(10) * eps
	 && std::abs(f) > Tp(10) * eps)
	  {
	    const Tp frac = diff / f0;
	    if (std::abs(frac) > max_abs_frac)
	      max_abs_frac = std::abs(frac);
	  }
      }
    VERIFY(max_abs_frac < Tp(0.025000000000000001));
  }

// Test data for nu=0.66666666666666663.
testcase_cyl_bessel_j_asymp<double> data004[] = {
  { 0.016481695478352210, 0.66666666666666663, 1000.0000000000000 },
  { 0.014621879760010828, 0.66666666666666663, 1900.0000000000000 },
  { -0.0082531015270839985, 0.66666666666666663, 2800.0000000000000 },
  { -0.011429441097367061, 0.66666666666666663, 3700.0000000000000 },
  { 0.0050807158545810400, 0.66666666666666663, 4600.0000000000000 },
  { 0.0099900888688827499, 0.66666666666666663, 5500.0000000000000 },
  { -0.0030803023391088452, 0.66666666666666663, 6400.0000000000000 },
  { -0.0090535482439156427, 0.66666666666666663, 7300.0000000000000 },
  { 0.0015894770287083252, 0.66666666666666663, 8200.0000000000000 },
  { 0.0083087695891568489, 0.66666666666666663, 9100.0000000000000 },
  { -0.00038916499172841337, 0.66666666666666663, 10000.000000000000 },
};

// Test function for nu=0.66666666666666663.
template<typename Tp>
  void
  test004()
  {
    bool test [[gnu::unused]] = true;
    const Tp eps = std::numeric_limits<Tp>::epsilon();
    Tp max_abs_diff = -Tp(1);
    Tp max_abs_frac = -Tp(1);
    unsigned int num_datum = sizeof(data004)
			   / sizeof(testcase_cyl_bessel_j_asymp<double>);
    for (unsigned int i = 0; i < num_datum; ++i)
      {
	const Tp f = std::cyl_bessel_j_asymp(Tp(data004[i].nu), Tp(data004[i].x));
	const Tp f0 = data004[i].f0;
	const Tp diff = f - f0;
	if (std::abs(diff) > max_abs_diff)
	  max_abs_diff = std::abs(diff);
	if (std::abs(f0) > Tp(10) * eps
	 && std::abs(f) > Tp(10) * eps)
	  {
	    const Tp frac = diff / f0;
	    if (std::abs(frac) > max_abs_frac)
	      max_abs_frac = std::abs(frac);
	  }
      }
    VERIFY(max_abs_frac < Tp(0.025000000000000001));
  }

// Test data for nu=1.0000000000000000.
testcase_cyl_bessel_j_asymp<double> data005[] = {
  { 0.0047283119070895179, 1.0000000000000000, 1000.0000000000000 },
  { 0.018168583883707675, 1.0000000000000000, 1900.0000000000000 },
  { -0.00083916409441230468, 1.0000000000000000, 2800.0000000000000 },
  { -0.013116398176305432, 1.0000000000000000, 3700.0000000000000 },
  { -0.00090449432412359791, 1.0000000000000000, 4600.0000000000000 },
  { 0.010648444054390990, 1.0000000000000000, 5500.0000000000000 },
  { 0.0020749402144563038, 1.0000000000000000, 6400.0000000000000 },
  { -0.0089854105158233780, 1.0000000000000000, 7300.0000000000000 },
  { -0.0029564961030191751, 1.0000000000000000, 8200.0000000000000 },
  { 0.0076759581378006633, 1.0000000000000000, 9100.0000000000000 },
  { 0.0036474507555281110, 1.0000000000000000, 10000.000000000000 },
};

// Test function for nu=1.0000000000000000.
template<typename Tp>
  void
  test005()
  {
    bool test [[gnu::unused]] = true;
    const Tp eps = std::numeric_limits<Tp>::epsilon();
    Tp max_abs_diff = -Tp(1);
    Tp max_abs_frac = -Tp(1);
    unsigned int num_datum = sizeof(data005)
			   / sizeof(testcase_cyl_bessel_j_asymp<double>);
    for (unsigned int i = 0; i < num_datum; ++i)
      {
	const Tp f = std::cyl_bessel_j_asymp(Tp(data005[i].nu), Tp(data005[i].x));
	const Tp f0 = data005[i].f0;
	const Tp diff = f - f0;
	if (std::abs(diff) > max_abs_diff)
	  max_abs_diff = std::abs(diff);
	if (std::abs(f0) > Tp(10) * eps
	 && std::abs(f) > Tp(10) * eps)
	  {
	    const Tp frac = diff / f0;
	    if (std::abs(frac) > max_abs_frac)
	      max_abs_frac = std::abs(frac);
	  }
      }
    VERIFY(max_abs_frac < Tp(0.010000000000000000));
  }

// Test data for nu=2.0000000000000000.
testcase_cyl_bessel_j_asymp<double> data006[] = {
  { -0.024777229528606001, 2.0000000000000000, 1000.0000000000000 },
  { 0.0022427133205383545, 2.0000000000000000, 1900.0000000000000 },
  { 0.015054782004690088, 2.0000000000000000, 2800.0000000000000 },
  { 0.00013433041915797300, 2.0000000000000000, 3700.0000000000000 },
  { -0.011729638074712190, 2.0000000000000000, 4600.0000000000000 },
  { -0.0015332241672269963, 2.0000000000000000, 5500.0000000000000 },
  { 0.0097558162268865899, 2.0000000000000000, 6400.0000000000000 },
  { 0.0025418884134900633, 2.0000000000000000, 7300.0000000000000 },
  { -0.0083008834697905712, 2.0000000000000000, 8200.0000000000000 },
  { -0.0033210657854092743, 2.0000000000000000, 9100.0000000000000 },
  { 0.0070968898435367434, 2.0000000000000000, 10000.000000000000 },
};

// Test function for nu=2.0000000000000000.
template<typename Tp>
  void
  test006()
  {
    bool test [[gnu::unused]] = true;
    const Tp eps = std::numeric_limits<Tp>::epsilon();
    Tp max_abs_diff = -Tp(1);
    Tp max_abs_frac = -Tp(1);
    unsigned int num_datum = sizeof(data006)
			   / sizeof(testcase_cyl_bessel_j_asymp<double>);
    for (unsigned int i = 0; i < num_datum; ++i)
      {
	const Tp f = std::cyl_bessel_j_asymp(Tp(data006[i].nu), Tp(data006[i].x));
	const Tp f0 = data006[i].f0;
	const Tp diff = f - f0;
	if (std::abs(diff) > max_abs_diff)
	  max_abs_diff = std::abs(diff);
	if (std::abs(f0) > Tp(10) * eps
	 && std::abs(f) > Tp(10) * eps)
	  {
	    const Tp frac = diff / f0;
	    if (std::abs(frac) > max_abs_frac)
	      max_abs_frac = std::abs(frac);
	  }
      }
    VERIFY(max_abs_frac < Tp(0.025000000000000001));
  }

// Test data for nu=5.0000000000000000.
testcase_cyl_bessel_j_asymp<double> data007[] = {
  { 0.0050254069452332281, 5.0000000000000000, 1000.0000000000000 },
  { 0.018154177864565635, 5.0000000000000000, 1900.0000000000000 },
  { -0.00090367931930118944, 5.0000000000000000, 2800.0000000000000 },
  { -0.013116787853188344, 5.0000000000000000, 3700.0000000000000 },
  { -0.00087389323963858788, 5.0000000000000000, 4600.0000000000000 },
  { 0.010651772372280859, 5.0000000000000000, 5500.0000000000000 },
  { 0.0020566456346121469, 5.0000000000000000, 6400.0000000000000 },
  { -0.0089895808678288700, 5.0000000000000000, 7300.0000000000000 },
  { -0.0029443463610425301, 5.0000000000000000, 8200.0000000000000 },
  { 0.0076803331150681808, 5.0000000000000000, 9100.0000000000000 },
  { 0.0036389327383067934, 5.0000000000000000, 10000.000000000000 },
};

// Test function for nu=5.0000000000000000.
template<typename Tp>
  void
  test007()
  {
    bool test [[gnu::unused]] = true;
    const Tp eps = std::numeric_limits<Tp>::epsilon();
    Tp max_abs_diff = -Tp(1);
    Tp max_abs_frac = -Tp(1);
    unsigned int num_datum = sizeof(data007)
			   / sizeof(testcase_cyl_bessel_j_asymp<double>);
    for (unsigned int i = 0; i < num_datum; ++i)
      {
	const Tp f = std::cyl_bessel_j_asymp(Tp(data007[i].nu), Tp(data007[i].x));
	const Tp f0 = data007[i].f0;
	const Tp diff = f - f0;
	if (std::abs(diff) > max_abs_diff)
	  max_abs_diff = std::abs(diff);
	if (std::abs(f0) > Tp(10) * eps
	 && std::abs(f) > Tp(10) * eps)
	  {
	    const Tp frac = diff / f0;
	    if (std::abs(frac) > max_abs_frac)
	      max_abs_frac = std::abs(frac);
	  }
      }
    VERIFY(max_abs_frac < Tp(0.050000000000000003));
  }

// Test data for nu=10.000000000000000.
testcase_cyl_bessel_j_asymp<double> data008[] = {
  { -0.024520622306036535, 10.000000000000000, 1000.0000000000000 },
  { 0.0027009191583060189, 10.000000000000000, 1900.0000000000000 },
  { 0.015038092722720869, 10.000000000000000, 2800.0000000000000 },
  { -3.5835684234346650e-05, 10.000000000000000, 3700.0000000000000 },
  { -0.011738410928656649, 10.000000000000000, 4600.0000000000000 },
  { -0.0014402325453117841, 10.000000000000000, 5500.0000000000000 },
  { 0.0097710923317616983, 10.000000000000000, 6400.0000000000000 },
  { 0.0024827494113826552, 10.000000000000000, 7300.0000000000000 },
  { -0.0083180415568484024, 10.000000000000000, 8200.0000000000000 },
  { -0.0032805292606564924, 10.000000000000000, 9100.0000000000000 },
  { 0.0071143123833529382, 10.000000000000000, 10000.000000000000 },
};

// Test function for nu=10.000000000000000.
template<typename Tp>
  void
  test008()
  {
    bool test [[gnu::unused]] = true;
    const Tp eps = std::numeric_limits<Tp>::epsilon();
    Tp max_abs_diff = -Tp(1);
    Tp max_abs_frac = -Tp(1);
    unsigned int num_datum = sizeof(data008)
			   / sizeof(testcase_cyl_bessel_j_asymp<double>);
    for (unsigned int i = 0; i < num_datum; ++i)
      {
	const Tp f = std::cyl_bessel_j_asymp(Tp(data008[i].nu), Tp(data008[i].x));
	const Tp f0 = data008[i].f0;
	const Tp diff = f - f0;
	if (std::abs(diff) > max_abs_diff)
	  max_abs_diff = std::abs(diff);
	if (std::abs(f0) > Tp(10) * eps
	 && std::abs(f) > Tp(10) * eps)
	  {
	    const Tp frac = diff / f0;
	    if (std::abs(frac) > max_abs_frac)
	      max_abs_frac = std::abs(frac);
	  }
      }
    VERIFY(max_abs_frac < Tp(0.050000000000000003));
  }

// Test data for nu=20.000000000000000.
testcase_cyl_bessel_j_asymp<double> data009[] = {
  { 0.023357967932679333, 20.000000000000000, 1000.0000000000000 },
  { -0.0041204260759481037, 20.000000000000000, 1900.0000000000000 },
  { -0.014957483901302460, 20.000000000000000, 2800.0000000000000 },
  { 0.00056744027717915821, 20.000000000000000, 3700.0000000000000 },
  { 0.011757584776908865, 20.000000000000000, 4600.0000000000000 },
  { 0.0011489578208100672, 20.000000000000000, 5500.0000000000000 },
  { -0.0098152840784015739, 20.000000000000000, 6400.0000000000000 },
  { -0.0022972594203947328, 20.000000000000000, 7300.0000000000000 },
  { 0.0083698210136523565, 20.000000000000000, 8200.0000000000000 },
  { 0.0031532692984502751, 20.000000000000000, 9100.0000000000000 },
  { -0.0071676996068590626, 20.000000000000000, 10000.000000000000 },
};

// Test function for nu=20.000000000000000.
template<typename Tp>
  void
  test009()
  {
    bool test [[gnu::unused]] = true;
    const Tp eps = std::numeric_limits<Tp>::epsilon();
    Tp max_abs_diff = -Tp(1);
    Tp max_abs_frac = -Tp(1);
    unsigned int num_datum = sizeof(data009)
			   / sizeof(testcase_cyl_bessel_j_asymp<double>);
    for (unsigned int i = 0; i < num_datum; ++i)
      {
	const Tp f = std::cyl_bessel_j_asymp(Tp(data009[i].nu), Tp(data009[i].x));
	const Tp f0 = data009[i].f0;
	const Tp diff = f - f0;
	if (std::abs(diff) > max_abs_diff)
	  max_abs_diff = std::abs(diff);
	if (std::abs(f0) > Tp(10) * eps
	 && std::abs(f) > Tp(10) * eps)
	  {
	    const Tp frac = diff / f0;
	    if (std::abs(frac) > max_abs_frac)
	      max_abs_frac = std::abs(frac);
	  }
      }
    VERIFY(max_abs_frac < Tp(0.050000000000000003));
  }

// Test data for nu=50.000000000000000.
testcase_cyl_bessel_j_asymp<double> data010[] = {
  { -0.0033360489606152066, 50.000000000000000, 1000.0000000000000 },
  { 0.012871786774181049, 50.000000000000000, 1900.0000000000000 },
  { 0.013219698215483683, 50.000000000000000, 2800.0000000000000 },
  { -0.0042142263356710914, 50.000000000000000, 3700.0000000000000 },
  { -0.011542296536729203, 50.000000000000000, 4600.0000000000000 },
  { 0.00090175516017689428, 50.000000000000000, 5500.0000000000000 },
  { 0.0099726837897942799, 50.000000000000000, 6400.0000000000000 },
  { 0.00097608519290427276, 50.000000000000000, 7300.0000000000000 },
  { -0.0086530108142473267, 50.000000000000000, 8200.0000000000000 },
  { -0.0022404163409067276, 50.000000000000000, 9100.0000000000000 },
  { 0.0074956304928524850, 50.000000000000000, 10000.000000000000 },
};

// Test function for nu=50.000000000000000.
template<typename Tp>
  void
  test010()
  {
    bool test [[gnu::unused]] = true;
    const Tp eps = std::numeric_limits<Tp>::epsilon();
    Tp max_abs_diff = -Tp(1);
    Tp max_abs_frac = -Tp(1);
    unsigned int num_datum = sizeof(data010)
			   / sizeof(testcase_cyl_bessel_j_asymp<double>);
    for (unsigned int i = 0; i < num_datum; ++i)
      {
	const Tp f = std::cyl_bessel_j_asymp(Tp(data010[i].nu), Tp(data010[i].x));
	const Tp f0 = data010[i].f0;
	const Tp diff = f - f0;
	if (std::abs(diff) > max_abs_diff)
	  max_abs_diff = std::abs(diff);
	if (std::abs(f0) > Tp(10) * eps
	 && std::abs(f) > Tp(10) * eps)
	  {
	    const Tp frac = diff / f0;
	    if (std::abs(frac) > max_abs_frac)
	      max_abs_frac = std::abs(frac);
	  }
      }
    VERIFY(max_abs_frac < Tp(0.050000000000000003));
  }

// Test data for nu=100.00000000000000.
testcase_cyl_bessel_j_asymp<double> data011[] = {
  { 0.011676135007789573, 100.00000000000000, 1000.0000000000000 },
  { -0.0069238868725645785, 100.00000000000000, 1900.0000000000000 },
  { 0.0040320953231285607, 100.00000000000000, 2800.0000000000000 },
  { 0.012773621341833607, 100.00000000000000, 3700.0000000000000 },
  { 0.0062583435252356358, 100.00000000000000, 4600.0000000000000 },
  { -0.0074572526754139480, 100.00000000000000, 5500.0000000000000 },
  { -0.0083885681627232315, 100.00000000000000, 6400.0000000000000 },
  { 0.0037140023299432928, 100.00000000000000, 7300.0000000000000 },
  { 0.0084980486968605530, 100.00000000000000, 8200.0000000000000 },
  { -0.0011748329060925829, 100.00000000000000, 9100.0000000000000 },
  { -0.0079765163113953898, 100.00000000000000, 10000.000000000000 },
};

// Test function for nu=100.00000000000000.
template<typename Tp>
  void
  test011()
  {
    bool test [[gnu::unused]] = true;
    const Tp eps = std::numeric_limits<Tp>::epsilon();
    Tp max_abs_diff = -Tp(1);
    Tp max_abs_frac = -Tp(1);
    unsigned int num_datum = sizeof(data011)
			   / sizeof(testcase_cyl_bessel_j_asymp<double>);
    for (unsigned int i = 0; i < num_datum; ++i)
      {
	const Tp f = std::cyl_bessel_j_asymp(Tp(data011[i].nu), Tp(data011[i].x));
	const Tp f0 = data011[i].f0;
	const Tp diff = f - f0;
	if (std::abs(diff) > max_abs_diff)
	  max_abs_diff = std::abs(diff);
	if (std::abs(f0) > Tp(10) * eps
	 && std::abs(f) > Tp(10) * eps)
	  {
	    const Tp frac = diff / f0;
	    if (std::abs(frac) > max_abs_frac)
	      max_abs_frac = std::abs(frac);
	  }
      }
    VERIFY(max_abs_frac < Tp(0.050000000000000003));
  }

int
main()
{
  test001<double>();
  test002<double>();
  test003<double>();
  test004<double>();
  test005<double>();
  test006<double>();
  test007<double>();
  test008<double>();
  test009<double>();
  test010<double>();
  test011<double>();
  return 0;
}
