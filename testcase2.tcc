#ifndef TESTCASE2_TCC
#define TESTCASE2_TCC 1

#include <complex>
#include <sstream>
#include <experimental/type_traits>
#include <experimental/string_view>
#include "complex_compare.h" // For the Statistics min/max (maybe rethink that there)

const std::experimental::string_view boilerplate = 
R"(// { dg-options "-D__STDCPP_WANT_MATH_SPEC_FUNCS__" }
//
// Copyright (C) 2016 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING3.  If not see
// <http://www.gnu.org/licenses/>.
)";

const std::experimental::string_view header = 
R"(//  Compare against values generated by the GNU Scientific Library.
//  The GSL can be found on the web: http://www.gnu.org/software/gsl/
#include <limits>
#include <cmath>
#if defined(__TEST_DEBUG)
#  include <iostream>
#  define VERIFY(A) \
  if (!(A)) \
    { \
      std::cout << "line " << __LINE__ \
	<< "  max_abs_frac = " << max_abs_frac \
	<< std::endl; \
    }
#else
#  include <testsuite_hooks.h>
#endif
#include <specfun_testcase.h>
)";

const std::experimental::string_view riemann_limits = 
R"(// This can take long on simulators, timing out the test.
// { dg-options "-DMAX_ITERATIONS=5" { target simulator } }

#ifndef MAX_ITERATIONS
#define MAX_ITERATIONS (sizeof(data001) / sizeof(testcase_riemann_zeta<double>))
#endif
)";

/**
 * Introspection class to detect if a type is std::complex.
 */
template<typename _Tp>
  struct is_complex : public std::false_type
  { };

/**
 * Introspection class to detect if a type is std::complex.
 */
template<>
  template<typename _Tp>
    struct is_complex<std::complex<_Tp>> : public std::true_type
    { };

/**
 * Introspection type to detect if a type is std::complex.
 */
template<typename _Tp>
  using is_complex_t = typename is_complex<_Tp>::type;

/**
 * Introspection variable template to detect if a type is std::complex.
 */
template<typename _Tp>
  constexpr bool is_complex_v = is_complex<_Tp>::value;

/**
 *  Incremental computation of statistics.
 */
template<typename _Tp>
  struct _Statistics
  {
    _Statistics&
    operator<<(_Tp __diff)
    {
      ++_M_count;
      auto __old_mean = _M_mean;
      _M_mean = (_M_type(__diff) + _M_type(_M_count - 1) * _M_mean) / _M_type(_M_count);
      auto __del_mean = _M_mean - __old_mean;
      auto __del_diff = _M_type(__diff) - _M_mean;
      if (_M_count > 1)
	_M_variance = (_M_type(_M_count - 2) * _M_variance * _M_variance
		    + _M_type(_M_count - 1) * __del_mean * __del_mean
		    + __del_diff * __del_diff) / _M_type(_M_count - 1);
      if (__diff < _M_min)
	_M_min = __diff;
      if (__diff > _M_max)
	_M_max = __diff;

      return *this;
    }

    static constexpr bool _M_is_complex = is_complex_v<_Tp>;

    using _M_type = std::conditional_t<is_complex_v<_Tp>,
				       std::complex<long double>, long double>;

    _Tp
    count() const
    { return _Tp(_M_count); }

    _Tp
    mean() const
    { return _Tp(_M_mean); }

    _Tp
    variance() const
    { return _Tp(_M_variance); }

    _Tp
    std_deviation() const
    { return _Tp(std::sqrt(_M_variance)); }

    _Tp
    min() const
    { return _Tp(_M_min); }

    _Tp
    max() const
    { return _Tp(_M_max); }

    std::size_t _M_count = 0;
    _M_type _M_mean = 0;
    _M_type _M_variance = 0;
    _M_type _M_min = std::numeric_limits<long double>::max();
    _M_type _M_max = std::numeric_limits<long double>::lowest();
  };


/// A class to abstract the scalar data type in a generic way.
template<typename Tp>
  struct __num_traits
  {
    using __value_type = Tp;
  };

template<>
  template<typename Tp>
    struct __num_traits<std::complex<Tp>>
    {
      using __value_type = typename std::complex<Tp>::value_type;
    };

template<typename Tp>
  using __num_traits_t = typename __num_traits<Tp>::__value_type;

template<typename Tp>
  struct type_strings
  {
    static const std::experimental::string_view
    type()
    { return std::experimental::string_view(""); }

    static const std::experimental::string_view
    suffix()
    { return std::experimental::string_view(""); }
  };

template<>
  struct type_strings<float>
  {
    static const std::experimental::string_view
    type()
    { return std::string("float"); }

    static const std::experimental::string_view
    suffix()
    { return std::experimental::string_view("F"); }
  };

template<>
  struct type_strings<double>
  {
    static const std::experimental::string_view
    type()
    { return std::experimental::string_view("double"); }

    static const std::experimental::string_view
    suffix()
    { return std::experimental::string_view(""); }
  };

template<>
  struct type_strings<long double>
  {
    static const std::experimental::string_view
    type()
    { return std::experimental::string_view("long double"); }

    static const std::experimental::string_view
    suffix()
    { return std::experimental::string_view("L"); }
  };

template<>
  struct type_strings<__float128>
  {
    static const std::experimental::string_view
    type()
    { return std::experimental::string_view("__float128"); }

    static const std::experimental::string_view
    suffix()
    { return std::experimental::string_view("Q"); }
  };

// Fuck me.  I'm too stupid to do this right.
template<>
  struct type_strings<std::complex<float>>
  {
    static const std::experimental::string_view
    type()
    { return std::experimental::string_view("std::complex<float>"); }

    static const std::experimental::string_view
    suffix()
    { return std::experimental::string_view(""); }
  };

template<>
  struct type_strings<std::complex<double>>
  {
    static const std::experimental::string_view
    type()
    { return std::experimental::string_view("std::complex<double>"); }

    static const std::experimental::string_view
    suffix()
    { return std::experimental::string_view(""); }
  };

template<>
  struct type_strings<std::complex<long double>>
  {
    static const std::experimental::string_view
    type()
    { return std::experimental::string_view("std::complex<long double>"); }

    static const std::experimental::string_view
    suffix()
    { return std::experimental::string_view(""); }
  };

template<>
  struct type_strings<std::complex<__float128>>
  {
    static const std::experimental::string_view
    type()
    { return std::experimental::string_view("std::complex<__float128>"); }

    static const std::experimental::string_view
    suffix()
    { return std::experimental::string_view(""); }
  };


  /**
   *  @brief  Returns the value clamped between lo and hi.
   *  @ingroup sorting_algorithms
   *  @param  __val  A value of arbitrary type.
   *  @param  __lo   A lower limit of arbitrary type.
   *  @param  __hi   An upper limit of arbitrary type.
   *  @return max(__val, __lo) if __val < __hi or min(__val, __hi) otherwise.
   */
  template<typename _Tp>
    constexpr const _Tp&
    clamp(const _Tp& __val, const _Tp& __lo, const _Tp& __hi)
    {
      if (__val < __hi)
	return ::std::max(__val, __lo);
      else
	return ::std::min(__val, __hi);
    }

  /**
   *  @brief  Returns the value clamped between lo and hi.
   *  @ingroup sorting_algorithms
   *  @param  __val   A value of arbitrary type.
   *  @param  __lo    A lower limit of arbitrary type.
   *  @param  __hi    An upper limit of arbitrary type.
   *  @param  __comp  A comparison functor.
   *  @return max(__val, __lo, __comp) if __comp(__val, __hi)
   *          or min(__val, __hi, __comp) otherwise.
   */
  template<typename _Tp, typename _Compare>
    constexpr const _Tp&
    clamp(const _Tp& __val, const _Tp& __lo, const _Tp& __hi, _Compare __comp)
    {
      if (__comp(__val, __hi))
	return ::std::max(__val, __lo, __comp);
      else
	return ::std::min(__val, __hi, __comp);
    }


///
///  @brief  Append two testcase vectors.
///
template<typename Tp>
  std::vector<Tp>
  fill_argument(std::vector<Tp>&& arg, std::vector<Tp>&& more)
  {
    std::vector<Tp> ret;
    ret.reserve(arg.size() + more.size());
    ret.insert(ret.end(), arg.begin(), arg.end());
    ret.insert(ret.end(), more.begin(), more.end());
    return ret;
  }

///
///  @brief  Fill an array with evenly spaced values between two limits.
///
template<typename Tp>
  std::vector<Tp>
  fill_argument(const std::pair<Tp,Tp> & _M_range,
		const std::pair<bool,bool> & inclusive,
		unsigned int num_points)
  {
    std::vector<Tp> argument;

    if (num_points == 1)
      {
	argument.push_back(_M_range.first);
	return argument;
      }

    auto delta = (_M_range.second - _M_range.first) / (num_points - 1);
    auto min = std::min(_M_range.first, _M_range.second);
    auto max = std::max(_M_range.first, _M_range.second);
    auto clamp = [min, max](Tp x)
		 -> Tp
		 {
		   if (x < min)
		     return min;
		   else if (x > max)
		     return max;
		   else
		     return x;
		 };
    for (unsigned int i = 0; i < num_points; ++i)
      {
	if (i == 0 && ! inclusive.first)
	  continue;
	if (i == num_points - 1 && ! inclusive.second)
	  continue;

	argument.push_back(clamp(_M_range.first + i * delta));
      }

    return argument;
  }


///
///  @brief  Find a nice round number limit.
///
template<typename Tp>
  Tp
  get_tolerance(Tp delta, Tp min_tol, bool & ok)
  {
    using Val = __num_traits_t<Tp>;

    const auto abs_delta = std::abs(delta);
    //  Make this some number larger because you lose some accuracy writing and reading.
    const auto eps = Tp{10} * std::numeric_limits<Val>::epsilon();
    Tp tol = min_tol;
    while (tol > std::abs(delta)
	&& tol > eps)
      {
	if (Tp(0.5L) * tol > abs_delta
	 && Tp(0.5L) * tol > eps)
	  {
	    if (Tp(0.2L) * tol > abs_delta
	     && Tp(0.2L) * tol > eps)
	      {
		if (Tp(0.1L) * tol > abs_delta
		 && Tp(0.1L) * tol > eps)
		  {
		    tol *= Tp(0.1L);
		  }
		else
		  {
		    tol *= Tp(0.2L);
		    break;
		  }
	      }
	    else
	      {
		tol *= Tp(0.5L);
		break;
	      }
	  }
	else
	  break;
      }
    ok = true;
    if (tol < min_tol && tol <= abs_delta)
      {
	ok = false;
	std::cerr << "**** Error in get_tolerance:"
		  << " abs(delta)=" << abs_delta
		  << " tol=" << tol
		  << '\n';
      }
    if (tol == min_tol && tol < abs_delta)
      {
	ok = false;
	std::cerr << "Note in get_tolerance:"
		  << " delta=" << delta
		  << " tol=" << tol
		  << '\n';
      }

    //  Somehow, we seem to need extra space to get the tests to pass.
    //  TODO: Figure this out.
    return Tp(50.0L) * tol;
  }

/**
 * A class for function arguments.
 */
template<typename Arg>
  class argument
  {

  public:

    argument(const std::string & arg,
	     const std::vector<Arg> & val)
    : name(arg),
      value(val)
    {}

    std::string name;
    std::vector<Arg> value;
    std::vector<Arg> error;

  private:

  };

/**
 * A class for test function - the function to be tested.
 */
template<typename Ret, typename... Arg>
  class test_function
  {

  public:

    test_function(const std::string & name,
		  Ret func(Arg...))
    : funcname(name),
      function(func)
    {}

    std::string funcname;
    Ret (*function)(Arg...);

  private:
  
  };


/**
 * A class for baseline function - the function that is a baseline.
 */
template<typename Ret, typename... Arg>
  class baseline_function
  {

  public:

    baseline_function(const std::string & src,
		      const std::string & name,
		      Ret func(Arg...))
    : source(src),
      funcname(name),
      function(func)
    {}

    std::string source;
    std::string funcname;
    Ret (*function)(Arg...);

  private:
  
  };


/**
 * A class for testcases.
 */
template<typename MaskFun, typename Ret, typename... Arg>
  class testcase
  {

  public:

    testcase(test_function<Ret, Arg...> test,
	     baseline_function<Ret, Arg...> base,
	     MaskFun mask,
	     const std::string & structname,
	     argument<Arg>... arg)
    : _M_testfun(test),
      _M_basefun(base),
      _M_maskfun(mask),
      _M_function1(_M_testfun.function),
      _M_function2(_M_basefun.function),
      _M_structname(structname),
      _M_range(arg...)
    {
      funcall = get_funcall();

      // Some functions taking only integral arguments must have explicit template args.
      auto _M_all_integral = (std::experimental::is_floating_point_v<Arg> && ...);
      if (_M_all_integral)
	_M_templparm += "<Tp>";
    }

    void
    operator()(std::ostream & output) const
    {
      // Some targets take too long for riemann zeta.
      bool riemann_zeta_limits
	= (_M_arity == 1 && _M_testfun.name == "riemann_zeta");

      output << boilerplate << '\n';
      output << "//  " << _M_testfun.name << '\n' << '\n';
      if (riemann_zeta_limits)
	output << riemann_limits << '\n';
      output << header;

      run_poo(output, std::tuple<Arg...>());

      write_main(output, riemann_zeta_limits, get_funcall().str());
    }


  private:

    std::ostringstream get_funcall();
    template<typename RetX, typename ArgX1, typename... ArgX>
      void get_funcall_help(std::ostringstream &);
    template<typename RetX, typename ArgX>
      void get_funcall_help(std::ostringstream &);

    template<std::size_t Index = 0>
      std::enable_if_t<Index == sizeof...(Arg), void>
      run_poo(std::ostream &);

    template<std::size_t Index = 0>
      std::enable_if_t<Index < sizeof...(Arg), void>
      run_poo(std::ostream &);

    std::string _M_structname;
    unsigned int _M_start_test = 1;
    test_function<Ret, Arg...> _M_testfun;
    baseline_function<Ret, Arg...> _M_basefun;
    MaskFun _M_maskfun;
    Ret (*_M_function1)(Arg...);
    Ret (*_M_function2)(Arg...);
    std::tuple<argument<Arg>...> _M_range;
    std::ostringstream funcall;
    std::string _M_templparm;
    const std::tuple_size<argument<Arg>...> _M_arity;
    bool _M_all_integral = true;
  };

template<typename MaskFun, typename Ret, typename... Arg>
  template<std::size_t Index>
    std::enable_if_t<Index == sizeof...(Arg), void>
    testcase<MaskFun, Ret, Arg...>::
    run_poo(std::ostream & output)
    {}

template<typename MaskFun, typename Ret, typename... Arg>
  template<std::size_t Index>
    std::enable_if_t<Index < sizeof...(Arg), void>
    testcase<MaskFun, Ret, Arg...>::
    run_poo(std::ostream & output)
    {
      using Val = __num_traits_t<Ret>;

      const int old_prec = output.precision(std::numeric_limits<Val>::max_digits10);
      output.flags(std::ios::showpoint);



      constexpr auto eps = std::numeric_limits<Val>::epsilon();
      constexpr auto inf = std::numeric_limits<Val>::infinity();
      constexpr auto NaN = std::numeric_limits<Val>::quiet_NaN();
      constexpr auto ret_complex = is_complex_v<Ret>;

      auto numname = type_strings<Val>::type().to_string();
      auto structname = _M_structname + '<' + numname + '>';
      run_poo<Index + 1>(output);
    }

/**
 * Build the function call string for the test suite.
 */
template<typename MaskFun, typename Ret, typename... Arg>
  std::ostringstream
  testcase<MaskFun, Ret, Arg...>::
  get_funcall()
  {
    std::ostringstream funcall;
    funcall /*<< nsname << "::"*/
	    << _M_testfun.name << _M_templparm << "(";
    get_funcall_help<Ret, Arg...>(funcall);
    return funcall;
  }

template<typename MaskFun, typename Ret, typename... Arg>
  template<typename RetX, typename ArgX1, typename... ArgX>
    void
    testcase<MaskFun, Ret, Arg...>::
    get_funcall_help(std::ostringstream & funcall)
    {
      funcall << "data[i]." << arg1 << ", "
	      << get_funcall_help<RetX, ArgX...>();
    }

template<typename MaskFun, typename Ret, typename... Arg>
  template<typename RetX, typename ArgX>
    void
    testcase<MaskFun, Ret, Arg...>::
    get_funcall_help(std::ostringstream & funcall)
    {
      funcall << "data[i]." << arg1 << ");\n";
    }

/**
 * Write the test case main function.
 */
template<typename MaskFun, typename Ret, typename... Arg>
  void
  testcase<MaskFun, Ret, Arg...>::
  write_main(std::ostream & output,
	     bool riemann_zeta_limits,
	     std::experimental::string_view funcall)
  {
    std::string structname = "testcase_";
    structname += funcname;
    structname += "<Tp>";

    std::string ret_tname = "Tp";
    if (ret_complex)
      ret_tname = "std::complex<Tp>";

    output << '\n';
    output << "template<typename Tp, unsigned int Num>\n";
    output.fill('0');
    output << "  void\n";
    output << "  test(const " << structname << " (&data)[Num], Tp toler)\n";
    output.fill(' ');
    output << "  {\n";
    output << "    bool test __attribute__((unused)) = true;\n";
    output << "    const Tp eps = std::numeric_limits<Tp>::epsilon();\n";
    output << "    Tp max_abs_diff = -Tp(1);\n";
    output << "    Tp max_abs_frac = -Tp(1);\n";
    if (riemann_zeta_limits)
      output << "    unsigned int num_datum = MAX_ITERATIONS;\n";
    else
      output << "    unsigned int num_datum = Num;\n";
    output << "    for (unsigned int i = 0; i < num_datum; ++i)\n";
    output << "      {\n";
    output << "\tconst " << ret_tname << " f = " << funcall << ";\n";
    output << "\tconst " << ret_tname << " f0 = data[i].f0;\n";
    output << "\tconst " << ret_tname << " diff = f - f0;\n";
    output << "\tif (std::abs(diff) > max_abs_diff)\n";
    output << "\t  max_abs_diff = std::abs(diff);\n";
    output << "\tif (std::abs(f0) > Tp(10) * eps\n";
    output << "\t && std::abs(f) > Tp(10) * eps)\n";
    output << "\t  {\n";
    output << "\t    const " << ret_tname << " frac = diff / f0;\n";
    output << "\t    if (std::abs(frac) > max_abs_frac)\n";
    output << "\t      max_abs_frac = std::abs(frac);\n";
    output << "\t  }\n";
    output << "      }\n";
    output << "    VERIFY(max_abs_frac < toler);\n";
    output << "  }\n";
    output << '\n';

    output << "int\n";
    output << "main()\n";
    output << "{\n";
    output.fill('0');
    for (unsigned int t = 1; t < _M_start_test; ++t)
      output << "  test(data" << std::setw(3) << t << ", toler" << std::setw(3) << t << ");\n";
    output.fill(' ');
    output << "  return 0;\n";
    output << "}\n";
  }




///
///  @brief  Difference two one-argument functions.
///
template<typename Tp, typename Tp1>
  unsigned int
  maketest(Tp _M_function1(Tp1),
	   Tp _M_function2(Tp1),
	   const std::string & nsname,
	   const std::string & funcname,
	   const std::string & arg1, const std::vector<Tp1> & argument1,
	   const std::string & baseline,
	   std::ostream & output,
	   bool write_header = true, bool write_main = true, unsigned int _M_start_test = 1)
  {
    using Val = __num_traits_t<Tp>;

    const int old_prec = output.precision(std::numeric_limits<Val>::max_digits10);
    output.flags(std::ios::showpoint);

    bool riemann_zeta_limits = (funcname == "riemann_zeta");

    std::string _M_templparm;
    if (!std::experimental::is_floating_point_v<Tp1>)
      _M_templparm += "<Tp>";

    if (write_header)
      output << boilerplate << '\n';
    output << "//  " << funcname << '\n' << '\n';
    if (riemann_zeta_limits)
      output << riemann_limits << '\n';
    if (write_header)
      output << header;

    constexpr auto eps = std::numeric_limits<Val>::epsilon();
    constexpr auto inf = std::numeric_limits<Val>::infinity();
    constexpr auto NaN = std::numeric_limits<Val>::quiet_NaN();
    constexpr auto ret_complex = is_complex_v<Tp>;

    auto numname = type_strings<Val>::type().to_string();

    std::string structname = "testcase_";
    structname += funcname;
    structname += '<' + numname + '>';

    std::vector<std::tuple<Tp, Tp1>> crud;
    _Statistics<Tp> raw_stats;
    _Statistics<decltype(std::abs(Tp{}))> abs_stats;
    auto max_abs_frac = Val{-1};
    auto num_divergences = 0;
    std::tuple<Tp, Tp, Tp1> last_divergence;
    for (unsigned int i = 0; i < argument1.size(); ++i)
      {
	const auto x = argument1[i];

	try
	  {
	    const auto f1 = _M_function1(x);
	    const auto f2 = _M_function2(x);

	    if (std::abs(f1) == inf || std::abs(f2) == inf)
	      {
		++num_divergences;
		last_divergence = std::make_tuple(f1, f2, x);
		if (num_divergences <= 3)
		  output << "//  Divergence at"
			 << " " << arg1 << "=" << x
			 << " f=" << f1
			 << " f_" << baseline << "=" << f2 << '\n';
		continue;
	      }

	    if (std::isnan(std::real(f1)) || std::isnan(std::real(f2)))
	      {
		output << "//  Failure at"
		       << " " << arg1 << "=" << x
		       << " f=" << f1
		       << " f_" << baseline << "=" << f2 << '\n';
		break;
	      }

	    const auto diff = f1 - f2;
	    raw_stats << diff;
	    abs_stats << std::abs(diff);
	    if (std::abs(f2) > Val{10} * eps && std::abs(f1) > Val{10} * eps)
	      {
		const auto frac = diff / f2;
		if (std::abs(frac) > max_abs_frac)
		  max_abs_frac = std::abs(frac);
	      }
	    crud.push_back(std::tuple<Tp, Tp1>(f2, x));
	  }
	catch (...)
	  {
	    continue;
	  }
      }
    if (num_divergences > 0)
      {
	if (num_divergences > 4)
	  output << "//  ...\n";
	output << "//  Divergence at"
	       << " " << arg1 << "=" << std::get<2>(last_divergence)
	       << " f=" << std::get<0>(last_divergence)
	       << " f_" << baseline << "=" << std::get<1>(last_divergence) << '\n';
	num_divergences = 0;
      }

    if (abs_stats.max() >= Val{0} && max_abs_frac >= Val{0})
      {
	bool tol_ok = false;
	const auto min_tol = Val{1.0e-3L};
	const auto frac_toler = get_tolerance(max_abs_frac, min_tol, tol_ok);
	std::string ret_tname;
	if (ret_complex)
	  ret_tname = type_strings<Tp>::type().to_string();
	std::ostringstream dataname;
	dataname.fill('0');
	dataname << "data" << std::setw(3) << _M_start_test;
	dataname.fill(' ');
	output << '\n';
	output << "// Test data.\n";
	output << "// max(|f - f_" << baseline << "|): " << abs_stats.max() << '\n';
	output << "// max(|f - f_" << baseline << "| / |f_" << baseline << "|): " << max_abs_frac << '\n';
	output << "// mean(f - f_" << baseline << "): " << raw_stats.mean() << '\n';
	output << "// variance(f - f_" << baseline << "): " << raw_stats.variance() << '\n';
	output << "// stddev(f - f_" << baseline << "): " << raw_stats.std_deviation() << '\n';
	output.fill('0');
	output << "const " << structname << '\n' << dataname.str() << '[' << crud.size() << "] =\n{\n";
	output.fill(' ');
	for (unsigned int i = 0; i < crud.size(); ++i)
	  {
	    output << "  { ";
	    output << std::get<0>(crud[i]) << type_strings<Tp>::suffix() << ", ";
	    output << ret_tname;
	    output << std::get<1>(crud[i]) << type_strings<Tp>::suffix();
	    output << " },\n";
	  }
	output << "};\n";
	output.fill('0');
	output << "const " << numname << " toler" << std::setw(3) << _M_start_test << " = " << frac_toler << ";\n";
	output.fill(' ');
	++_M_start_test;
      }

    if (write_main)
      {
	std::string structname = "testcase_";
	structname += funcname;
	structname += "<Tp>";

	std::string ret_tname = "Tp";
	if (ret_complex)
	  ret_tname = "std::complex<Tp>";

	output << '\n';
	output << "template<typename Tp, unsigned int Num>\n";
	output.fill('0');
	output << "  void\n";
	output << "  test(const " << structname << " (&data)[Num], Tp toler)\n";
	output.fill(' ');
	output << "  {\n";
	output << "    bool test __attribute__((unused)) = true;\n";
	output << "    const Tp eps = std::numeric_limits<Tp>::epsilon();\n";
	output << "    Tp max_abs_diff = -Tp(1);\n";
	output << "    Tp max_abs_frac = -Tp(1);\n";
	if (riemann_zeta_limits)
	  output << "    unsigned int num_datum = MAX_ITERATIONS;\n";
	else
	  output << "    unsigned int num_datum = Num;\n";
	output << "    for (unsigned int i = 0; i < num_datum; ++i)\n";
	output << "      {\n";
	output << "\tconst " << ret_tname << " f = " << nsname << "::" << funcname << _M_templparm << "(data[i]." << arg1 << ");\n";
	output << "\tconst " << ret_tname << " f0 = data[i].f0;\n";
	output << "\tconst " << ret_tname << " diff = f - f0;\n";
	output << "\tif (std::abs(diff) > max_abs_diff)\n";
	output << "\t  max_abs_diff = std::abs(diff);\n";
	output << "\tif (std::abs(f0) > Tp(10) * eps\n";
	output << "\t && std::abs(f) > Tp(10) * eps)\n";
	output << "\t  {\n";
	output << "\t    const " << ret_tname << " frac = diff / f0;\n";
	output << "\t    if (std::abs(frac) > max_abs_frac)\n";
	output << "\t      max_abs_frac = std::abs(frac);\n";
	output << "\t  }\n";
	output << "      }\n";
	output << "    VERIFY(max_abs_frac < toler);\n";
	output << "  }\n";

	output << '\n';
	output << "int\n";
	output << "main()\n";
	output << "{\n";
	output.fill('0');
	for (unsigned int t = 1; t < _M_start_test; ++t)
	  output << "  test(data" << std::setw(3) << t << ", toler" << std::setw(3) << t << ");\n";
	output.fill(' ');
	output << "  return 0;\n";
	output << "}\n";
      }

    output.flush();

    return _M_start_test;
  }


///
///  @brief  Difference two two-argument functions.
///
template<typename Tp, typename Tp1, typename Tp2>
  unsigned int
  maketest(Tp _M_function1(Tp1,Tp2),
	   Tp _M_function2(Tp1,Tp2),
	   const std::string & nsname,
	   const std::string & funcname,
	   const std::string & arg1, const std::vector<Tp1> & argument1,
	   const std::string & arg2, const std::vector<Tp2> & argument2,
	   const std::string & baseline,
	   std::ostream & output,
	   bool write_header = true, bool write_main = true, unsigned int _M_start_test = 1)
  {
    using Val = __num_traits_t<Tp>;

    const int old_prec = output.precision(std::numeric_limits<Val>::max_digits10);
    output.flags(std::ios::showpoint);

    std::string _M_templparm;
    if (!std::experimental::is_floating_point_v<Tp1>
     && !std::experimental::is_floating_point_v<Tp2>)
      _M_templparm += "<Tp>";

    if (write_header)
      output << boilerplate << '\n';
    output << "//  " << funcname << '\n';
    if (write_header)
      output << header << '\n';

    constexpr auto eps = std::numeric_limits<Val>::epsilon();
    constexpr auto inf = std::numeric_limits<Val>::infinity();
    constexpr auto NaN = std::numeric_limits<Val>::quiet_NaN();
    constexpr auto ret_complex = is_complex_v<Tp>;

    auto numname = type_strings<Val>::type().to_string();

    std::string structname = "testcase_";
    structname += funcname;
    structname += '<' + numname + '>';

    for (unsigned int i = 0; i < argument1.size(); ++i)
      {
	const auto x = argument1[i];

	std::vector<std::tuple<Tp, Tp1, Tp2>> crud;
	_Statistics<Tp> raw_stats;
	_Statistics<decltype(std::abs(Tp{}))> abs_stats;
	auto num_divergences = 0;
	std::tuple<Tp, Tp, Tp1, Tp2> last_divergence;

	auto max_abs_frac = Val{-1};
	for (unsigned int j = 0; j < argument2.size(); ++j)
	  {
	    const auto y = argument2[j];

	    try
	      {
		const auto f1 = _M_function1(x, y);
		const auto f2 = _M_function2(x, y);
		if (std::abs(f1) == inf || std::abs(f2) == inf)
		  {
		    ++num_divergences;
		    last_divergence = std::make_tuple(f1, f2, x, y);
		    if (num_divergences <= 3)
		      output << "//  Divergence at"
			     << " " << arg1 << "=" << x
			     << " " << arg2 << "=" << y
			     << " f=" << f1
			     << " f_" << baseline << "=" << f2 << '\n';
		    continue;
		  }

		if (std::isnan(std::real(f1)) || std::isnan(std::real(f2)))
		  {
		    output << "//  Failure at"
			   << " " << arg1 << "=" << x
			   << " " << arg2 << "=" << y
			   << " f=" << f1
			   << " f_" << baseline << "=" << f2 << '\n';
		    break;
		  }

		const auto diff = f1 - f2;
		raw_stats << diff;
		abs_stats << std::abs(diff);
		if (std::abs(f2) > Val{10} * eps && std::abs(f1) > Val{10} * eps)
		  {
		    const auto frac = diff / f2;
		    if (std::abs(frac) > max_abs_frac)
		      max_abs_frac = std::abs(frac);
		  }
		crud.push_back(std::tuple<Tp, Tp1, Tp2>(f2, x, y));
	      }
	    catch (...)
	      {
		continue;
	      }
	  }
	if (num_divergences > 0)
	  {
	    if (num_divergences > 4)
	      output << "//  ...\n";
	    output << "//  Divergence at"
		   << " " << arg1 << "=" << std::get<2>(last_divergence)
		   << " " << arg2 << "=" << std::get<3>(last_divergence)
		   << " f=" << std::get<0>(last_divergence)
		   << " f_" << baseline << "=" << std::get<1>(last_divergence) << '\n';
	    num_divergences = 0;
	  }

	if (abs_stats.max() >= Val{0} && max_abs_frac >= Val{0})
	  {
	    bool tol_ok = false;
	    const auto min_tol = Val{1.0e-3L};
	    const auto frac_toler = get_tolerance(max_abs_frac, min_tol, tol_ok);
	    std::string ret_tname;
	    if (ret_complex)
	      ret_tname = type_strings<Tp>::type().to_string();
	    std::ostringstream dataname;
	    dataname.fill('0');
	    dataname << "data" << std::setw(3) << _M_start_test;
	    dataname.fill(' ');
	    output << '\n';
	    output << "// Test data for " << arg1 << '=' << std::get<1>(crud[0]) << ".\n";
	    output << "// max(|f - f_" << baseline << "|): " << abs_stats.max() << '\n';
	    output << "// max(|f - f_" << baseline << "| / |f_" << baseline << "|): " << max_abs_frac << '\n';
	    output << "// mean(f - f_" << baseline << "): " << raw_stats.mean() << '\n';
	    output << "// variance(f - f_" << baseline << "): " << raw_stats.variance() << '\n';
	    output << "// stddev(f - f_" << baseline << "): " << raw_stats.std_deviation() << '\n';
	    output.fill('0');
	    output << "const " << structname << '\n' << dataname.str() << '[' << crud.size() << "] =\n{\n";
	    output.fill(' ');
	    for (unsigned int j = 0; j < crud.size(); ++j)
	      {
		output << "  { ";
		output << std::get<0>(crud[j]) << type_strings<Tp>::suffix() << ", ";
		output << std::get<1>(crud[j]) << type_strings<Tp>::suffix() << ", ";
		output <<  << ret_tname;
		output << std::get<2>(crud[j]) << type_strings<Tp>::suffix();
		output << " },\n";
	      }
	    output << "};\n";
	    output.fill('0');
	    output << "const " << numname << " toler" << std::setw(3) << _M_start_test << " = " << frac_toler << ";\n";
	    output.fill(' ');
	    ++_M_start_test;
	  }
      }

    if (write_main)
      {
	std::string structname = "testcase_";
	structname += funcname;
	structname += "<Tp>";

	std::string ret_tname = "Tp";
	if (ret_complex)
	  ret_tname = "std::complex<Tp>";

	output << '\n';
	output << "template<typename Tp, unsigned int Num>\n";
	output.fill('0');
	output << "  void\n";
	output << "  test(const " << structname << " (&data)[Num], Tp toler)\n";
	output.fill(' ');
	output << "  {\n";
	output << "    bool test __attribute__((unused)) = true;\n";
	output << "    const Tp eps = std::numeric_limits<Tp>::epsilon();\n";
	output << "    Tp max_abs_diff = -Tp(1);\n";
	output << "    Tp max_abs_frac = -Tp(1);\n";
	output << "    unsigned int num_datum = Num;\n";
	output << "    for (unsigned int i = 0; i < num_datum; ++i)\n";
	output << "      {\n";
	output << "\tconst " << ret_tname << " f = " << nsname << "::" << funcname << _M_templparm << '('
	       << "data[i]." << arg1 << ", data[i]." << arg2 << ");\n";
	output << "\tconst " << ret_tname << " f0 = data[i].f0;\n";
	output << "\tconst " << ret_tname << " diff = f - f0;\n";
	output << "\tif (std::abs(diff) > max_abs_diff)\n";
	output << "\t  max_abs_diff = std::abs(diff);\n";
	output << "\tif (std::abs(f0) > Tp(10) * eps\n";
	output << "\t && std::abs(f) > Tp(10) * eps)\n";
	output << "\t  {\n";
	output << "\t    const " << ret_tname << " frac = diff / f0;\n";
	output << "\t    if (std::abs(frac) > max_abs_frac)\n";
	output << "\t      max_abs_frac = std::abs(frac);\n";
	output << "\t  }\n";
	output << "      }\n";
	output << "    VERIFY(max_abs_frac < toler);\n";
	output << "  }\n";
	output << '\n';

	output << "int\n";
	output << "main()\n";
	output << "{\n";
	output.fill('0');
	for (unsigned int t = 1; t < _M_start_test; ++t)
	  output << "  test(data" << std::setw(3) << t << ", toler" << std::setw(3) << t << ");\n";
	output.fill(' ');
	output << "  return 0;\n";
	output << "}\n";
      }

    output.flush();

    return _M_start_test;
  }

#endif // TESTCASE2_TCC

