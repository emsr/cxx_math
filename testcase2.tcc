#ifndef TESTCASE2_TCC
#define TESTCASE2_TCC 1

#include <complex>
#include <sstream>
#include <experimental/type_traits>
#include <experimental/string_view>
#include "complex_compare.h" // For the Statistics min/max (maybe rethink that there)
#include "statistics.h"
#include "spaceship.h"

const std::experimental::string_view boilerplate = 
R"(// { dg-options "-D__STDCPP_WANT_MATH_SPEC_FUNCS__" }
//
// Copyright (C) 2016 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING3.  If not see
// <http://www.gnu.org/licenses/>.
)";

const std::experimental::string_view header = 
R"(//  Compare against values generated by the GNU Scientific Library.
//  The GSL can be found on the web: http://www.gnu.org/software/gsl/
#include <limits>
#include <cmath>
#if defined(__TEST_DEBUG)
#  include <iostream>
#  define VERIFY(A) \
  if (!(A)) \
    { \
      std::cout << "line " << __LINE__ \
	<< "  max_abs_frac = " << max_abs_frac \
	<< std::endl; \
    }
#else
#  include <testsuite_hooks.h>
#endif
#include <specfun_testcase.h>
)";

const std::experimental::string_view riemann_limits = 
R"(// This can take long on simulators, timing out the test.
// { dg-options "-DMAX_ITERATIONS=5" { target simulator } }

#ifndef MAX_ITERATIONS
#define MAX_ITERATIONS (sizeof(data001) / sizeof(testcase_riemann_zeta<double>))
#endif
)";


/// A class to abstract the scalar data type in a generic way.
template<typename Tp>
  struct __num_traits
  {
    using __value_type = Tp;
  };

template<>
  template<typename Tp>
    struct __num_traits<std::complex<Tp>>
    {
      using __value_type = typename std::complex<Tp>::value_type;
    };

template<typename Tp>
  using __num_traits_t = typename __num_traits<Tp>::__value_type;

template<typename Tp>
  struct type_strings
  {
    static const std::experimental::string_view
    type()
    { return std::experimental::string_view(""); }

    static const std::experimental::string_view
    suffix()
    { return std::experimental::string_view(""); }
  };

template<>
  struct type_strings<float>
  {
    static const std::experimental::string_view
    type()
    { return std::string("float"); }

    static const std::experimental::string_view
    suffix()
    { return std::experimental::string_view("F"); }
  };

template<>
  struct type_strings<double>
  {
    static const std::experimental::string_view
    type()
    { return std::experimental::string_view("double"); }

    static const std::experimental::string_view
    suffix()
    { return std::experimental::string_view(""); }
  };

template<>
  struct type_strings<long double>
  {
    static const std::experimental::string_view
    type()
    { return std::experimental::string_view("long double"); }

    static const std::experimental::string_view
    suffix()
    { return std::experimental::string_view("L"); }
  };

template<>
  struct type_strings<__float128>
  {
    static const std::experimental::string_view
    type()
    { return std::experimental::string_view("__float128"); }

    static const std::experimental::string_view
    suffix()
    { return std::experimental::string_view("Q"); }
  };

// Fuck me.  I'm too stupid to do this right.
template<>
  struct type_strings<std::complex<float>>
  {
    static const std::experimental::string_view
    type()
    { return std::experimental::string_view("std::complex<float>"); }

    static const std::experimental::string_view
    suffix()
    { return std::experimental::string_view(""); }
  };

template<>
  struct type_strings<std::complex<double>>
  {
    static const std::experimental::string_view
    type()
    { return std::experimental::string_view("std::complex<double>"); }

    static const std::experimental::string_view
    suffix()
    { return std::experimental::string_view(""); }
  };

template<>
  struct type_strings<std::complex<long double>>
  {
    static const std::experimental::string_view
    type()
    { return std::experimental::string_view("std::complex<long double>"); }

    static const std::experimental::string_view
    suffix()
    { return std::experimental::string_view(""); }
  };

template<>
  struct type_strings<std::complex<__float128>>
  {
    static const std::experimental::string_view
    type()
    { return std::experimental::string_view("std::complex<__float128>"); }

    static const std::experimental::string_view
    suffix()
    { return std::experimental::string_view(""); }
  };


///
///  @brief  Append two testcase vectors.
///
template<typename Tp>
  std::vector<Tp>
  fill_argument(std::vector<Tp>&& arg, std::vector<Tp>&& more)
  {
    std::vector<Tp> ret;
    ret.reserve(arg.size() + more.size());
    ret.insert(ret.end(), arg.begin(), arg.end());
    ret.insert(ret.end(), more.begin(), more.end());
    return ret;
  }

///
///  @brief  Fill an array with evenly spaced values between two limits.
///
template<typename Tp>
  std::vector<Tp>
  fill_argument(const std::pair<Tp,Tp> & range,
		const std::pair<bool,bool> & inclusive,
		unsigned int num_points)
  {
    std::vector<Tp> argument;

    if (num_points == 1)
      {
	argument.push_back(range.first);
	return argument;
      }

    auto delta = (range.second - range.first) / (num_points - 1);
    auto min = std::min(range.first, range.second);
    auto max = std::max(range.first, range.second);
    auto clamp = [min, max](Tp x)
		 -> Tp
		 {
		   if (x < min)
		     return min;
		   else if (x > max)
		     return max;
		   else
		     return x;
		 };
    for (unsigned int i = 0; i < num_points; ++i)
      {
	if (i == 0 && ! inclusive.first)
	  continue;
	if (i == num_points - 1 && ! inclusive.second)
	  continue;

	argument.push_back(clamp(range.first + i * delta));
      }

    return argument;
  }


///
///  @brief  Find a nice round number limit.
///
template<typename Tp>
  Tp
  get_tolerance(Tp delta, Tp min_tol, bool & ok)
  {
    using Val = __num_traits_t<Tp>;

    const auto abs_delta = std::abs(delta);
    //  Make this some number larger because you lose some accuracy writing and reading.
    const auto eps = Tp{10} * std::numeric_limits<Val>::epsilon();
    Tp tol = min_tol;
    while (tol > std::abs(delta)
	&& tol > eps)
      {
	if (Tp(0.5L) * tol > abs_delta
	 && Tp(0.5L) * tol > eps)
	  {
	    if (Tp(0.2L) * tol > abs_delta
	     && Tp(0.2L) * tol > eps)
	      {
		if (Tp(0.1L) * tol > abs_delta
		 && Tp(0.1L) * tol > eps)
		  {
		    tol *= Tp(0.1L);
		  }
		else
		  {
		    tol *= Tp(0.2L);
		    break;
		  }
	      }
	    else
	      {
		tol *= Tp(0.5L);
		break;
	      }
	  }
	else
	  break;
      }
    ok = true;
    if (tol < min_tol && tol <= abs_delta)
      {
	ok = false;
	std::cerr << "**** Error in get_tolerance:"
		  << " abs(delta)=" << abs_delta
		  << " tol=" << tol
		  << '\n';
      }
    if (tol == min_tol && tol < abs_delta)
      {
	ok = false;
	std::cerr << "Note in get_tolerance:"
		  << " delta=" << delta
		  << " tol=" << tol
		  << '\n';
      }

    //  Somehow, we seem to need extra space to get the tests to pass.
    //  TODO: Figure this out.
    return Tp(50.0L) * tol;
  }

#if __cpp_concepts > 0

/**
 * A concept for mask functions.
 */
template<typename Fun, typename... Arg>
  concept bool
  Mask()
  requires(Fun mask, Arg... args)
  {
    { mask(args...) } -> bool;
  };
#  define CONCEPT_MASK Mask

/**
 * A concept for test functions.
 */
template<typename Fun, typename Ret, typename... Arg>
  concept bool
  TestFun()
  requires(Fun test, Arg... args)
  {
    //typename ::funcname;
    { test(args...) } -> Ret;
  };
#  define CONCEPT_TESTFUN TestFun

/**
 * A concept for baseline functions.
 */
template<typename Fun, typename Ret, typename... Arg>
  concept bool
  BaselineFun()
  requires(Fun baseline, Arg... args)
  {
    //typename ::source;
    //typename ::funcname;
    { baseline(args...) } -> Ret;
  };
#  define CONCEPT_BASELINEFUN BaselineFun

#else // Remember to #undef these below.
#  define CONCEPT_MASK typename
#  define CONCEPT_TESTFUN typename
#  define CONCEPT_BASELINEFUN typename
#endif

/**
 * A class for function arguments.
 */
template<typename Arg>
  class argument
  {

  public:

    argument(std::experimental::string_view arg,
	     const std::vector<Arg> & val)
    : name(arg),
      value(val)
    {}

    std::experimental::string_view name;
    std::vector<Arg> value;
    std::vector<Arg> error;

  private:

  };

/**
 * A class for test function - the function to be tested.
 */
template<typename Ret, typename... Arg>
  class test_function
  {

  public:

    test_function(std::experimental::string_view name,
		  Ret func(Arg...))
    : funcname(name),
      function(func)
    {}

    std::experimental::string_view funcname;
    Ret (*function)(Arg...);

  private:

  };

/**
 * A class for baseline function - the function that is a baseline.
 */
template<typename Ret, typename... Arg>
  class baseline_function
  {

  public:

    baseline_function(std::experimental::string_view src,
		      std::experimental::string_view name,
		      Ret func(Arg...))
    : source(src),
      funcname(name),
      function(func)
    {}

    std::experimental::string_view source;
    std::experimental::string_view funcname;
    Ret (*function)(Arg...);

  private:

  };


/**
 * A class for testcases.
 */
template<CONCEPT_MASK MaskFun, typename Ret, typename... Arg>
  class testcase2
  {

  public:

    testcase2(test_function<Ret, Arg...> test,
	     baseline_function<Ret, Arg...> base,
	     MaskFun mask,
	     std::experimental::string_view structname,
	     argument<Arg>... arg)
    : _M_testfun(test),
      _M_basefun(base),
      _M_maskfun(mask),
      _M_function1(_M_testfun.function),
      _M_function2(_M_basefun.function),
      _M_structname(structname),
      _M_range(arg...)
    {
      funcall = get_funcall();

      // Some functions taking only integral arguments must have explicit template args.
      auto _M_all_integral = !(std::experimental::is_floating_point_v<Arg> || ...);
      if (_M_all_integral)
	_M_templparm += "<Ret>";
    }

    void
    operator()(std::ostream & output) const
    {
      // Some targets take too long for riemann zeta.
      bool riemann_zeta_limits
	= (_S_arity == 1 && _M_testfun.funcname == "riemann_zeta");

      output << boilerplate << '\n';
      output << "//  " << _M_testfun.funcname << '\n' << '\n';
      if (riemann_zeta_limits)
	output << riemann_limits << '\n';
      output << header;

      write_test_data(output, std::index_sequence_for<Arg...>{});

      write_main(output, riemann_zeta_limits, get_funcall().str());
    }


  private:

    std::ostringstream get_funcall() const;

    template<std::size_t... Index>
      void get_funcall_help(std::ostringstream &, std::index_sequence<Index...>) const;

    template<std::size_t... Index>
      void write_test_data(std::ostream &, std::index_sequence<Index...>) const;

    //template<std::size_t Index, _Spaceship_t<std::size_t> Sign = _Spaceship<std::size_t>{}(Index + 1, testcase2::_S_arity)>
    //  struct Test_Data_Help;
    template<std::size_t Index, _SpaceshipType<std::size_t, _Spaceship_t<std::size_t>>r SignTp>
      struct Test_Data_Help;

    //template<std::size_t Index, _Spaceship_t<std::size_t> Sign>
    //  friend class Test_Data_Help<Index, Sign>;
    //template<std::size_t Index>
    //  friend class Test_Data_Help<Index, _Spaceship_t<std::size_t>{+1}>;
    //template<std::size_t Index>
    //  friend class Test_Data_Help<Index, _Spaceship_t<std::size_t>{0}>;

    static const auto _S_arity = sizeof...(Arg);

    void write_main(std::ostream & output,
		    bool riemann_zeta_limits,
		    std::experimental::string_view funcall) const;

    std::experimental::string_view _M_structname;
    mutable unsigned int _M_start_test = 1;
    test_function<Ret, Arg...> _M_testfun;
    baseline_function<Ret, Arg...> _M_basefun;
    MaskFun _M_maskfun;
    Ret (*_M_function1)(Arg...);
    Ret (*_M_function2)(Arg...);
    std::tuple<argument<Arg>...> _M_range;
    std::ostringstream funcall;
    std::string _M_templparm;
    bool _M_all_integral = true;
  };

/**
 * A testcase maker - ADL to the rescue.
 */
template<CONCEPT_MASK MaskFun, typename Ret, typename... Arg>
  testcase2<MaskFun, Ret, Arg...>
  make_testcase2(test_function<Ret, Arg...> test,
		 baseline_function<Ret, Arg...> base,
		 MaskFun mask,
		 std::experimental::string_view structname,
		 argument<Arg>... arg)
  {
    return testcase2<MaskFun, Ret, Arg...>(test, base, mask, structname, arg...);
  }

/**
 * Generate and write the test data.  Accumulate statistics.
 */
template<typename MaskFun, typename Ret, typename... Arg>
  template<std::size_t... Index>
    void
    testcase2<MaskFun, Ret, Arg...>::
    write_test_data(std::ostream & output, std::index_sequence<Index...>) const
    {
      using Val = __num_traits_t<Ret>;

      const int old_prec = output.precision(std::numeric_limits<Val>::max_digits10);
      output.flags(std::ios::showpoint);

      Test_Data_Help<0, _Spaceship<std::size_t>{}(1, _S_arity)>{}(output);
    }

/**
 * Generate and write the test data.  Accumulate statistics.
 */
template<typename MaskFun, typename Ret, typename... Arg>
  template<std::size_t Index>
    struct testcase2<MaskFun, Ret, Arg...>::
    Test_Data_Help<Index, _Spaceship_t<std::size_t>{+1}>
    {
      void
      operator()(std::ostream & output) const
      {
        for (const auto x : std::get<Index>(_M_range).value)
	  Test_Data_Help<Index + 1, _Spaceship<std::size_t>{}(Index + 1, _S_arity)>(output);
      }
    };

/**
 * Generate and write the test data.  Accumulate statistics.
 */
template<typename MaskFun, typename Ret, typename... Arg>
  template<std::size_t Index>
    struct testcase2<MaskFun, Ret, Arg...>::
    Test_Data_Help<Index, _Spaceship_t<std::size_t>{0}>
    {
      void
      operator()(std::ostream & output) const;
    };

template<typename MaskFun, typename Ret, typename... Arg>
  template<std::size_t Index>
    void
    testcase2<MaskFun, Ret, Arg...>::
    Test_Data_Help<Index, _Spaceship_t<std::size_t>{0}>::
    operator()(std::ostream & output) const
    {
      using Val = __num_traits_t<Ret>;
      constexpr auto eps = std::numeric_limits<Val>::epsilon();
      constexpr auto inf = std::numeric_limits<Val>::infinity();
      constexpr auto NaN = std::numeric_limits<Val>::quiet_NaN();
      constexpr auto ret_complex = is_complex_v<Ret>;

      auto numname = type_strings<Val>::type().to_string();
      auto structname = _M_structname.to_string() + '<' + numname + '>';
      auto baseline = _M_basefun.source;
      auto arg = std::get<Index>(_M_range).name;

      std::vector<std::tuple<Ret, Arg...>> crud;
      _Statistics<Ret> raw_stats;
      _Statistics<decltype(std::abs(Ret{}))> abs_stats;
      auto num_divergences = 0;
      std::tuple<Ret, Ret, Arg...> last_divergence;
      auto max_abs_frac = Val{-1};
      for (const auto x : std::get<Index>(_M_range).value)
	{
	  try
	    {
	      const auto f1 = _M_function1(x);
	      const auto f2 = _M_function2(x);

	      if (std::abs(f1) == inf || std::abs(f2) == inf)
		{
		  ++num_divergences;
		  last_divergence = std::make_tuple(f1, f2, x);
		  if (num_divergences <= 3)
		    output << "//  Divergence at"
			   << " " << arg << "=" << x
			   << " f=" << f1
			   << " f_" << baseline << "=" << f2 << '\n';
		  continue;
		}

	      if (std::isnan(std::real(f1)) || std::isnan(std::real(f2)))
		{
		  output << "//  Failure at"
			 << " " << arg << "=" << x
			 << " f=" << f1
			 << " f_" << baseline << "=" << f2 << '\n';
		  break;
		}

	      const auto diff = f1 - f2;
	      raw_stats << diff;
	      abs_stats << std::abs(diff);
	      if (std::abs(f2) > Val{10} * eps && std::abs(f1) > Val{10} * eps)
		{
		  const auto frac = diff / f2;
		  if (std::abs(frac) > max_abs_frac)
		    max_abs_frac = std::abs(frac);
		}
	      crud.emplace_back(f2, x);
	    }
	  catch (...)
	    {
	      continue;
	    }
	}
      if (num_divergences > 0)
	{
	  if (num_divergences > 4)
	    output << "//  ...\n";
	  output << "//  Divergence at"
		 << " " << arg << "=" << std::get<2>(last_divergence)
		 << " f=" << std::get<0>(last_divergence)
		 << " f_" << baseline << "=" << std::get<1>(last_divergence) << '\n';
	  num_divergences = 0;
	}

      if (abs_stats.max() >= Val{0} && max_abs_frac >= Val{0})
	{
	  bool tol_ok = false;
	  const auto min_tol = Val{1.0e-3L};
	  const auto frac_toler = get_tolerance(max_abs_frac, min_tol, tol_ok);
	  std::string tname;
	  if (ret_complex)
	    tname = type_strings<Ret>::type().to_string();
	  std::ostringstream dataname;
	  dataname.fill('0');
	  dataname << "data" << std::setw(3) << _M_start_test;
	  dataname.fill(' ');
	  output << '\n';
	  output << "// Test data.\n";
	  output << "// max(|f - f_" << baseline << "|): " << abs_stats.max() << '\n';
	  output << "// max(|f - f_" << baseline << "| / |f_" << baseline << "|): " << max_abs_frac << '\n';
	  output << "// mean(f - f_" << baseline << "): " << raw_stats.mean() << '\n';
	  output << "// variance(f - f_" << baseline << "): " << raw_stats.variance() << '\n';
	  output << "// stddev(f - f_" << baseline << "): " << raw_stats.std_deviation() << '\n';
	  output.fill('0');
	  output << "const " << structname << '\n' << dataname.str() << '[' << crud.size() << "] =\n{\n";
	  output.fill(' ');
	  for (unsigned int i = 0; i < crud.size(); ++i)
	    {
	      output << "  { " << tname << std::get<0>(crud[i]) << type_strings<Ret>::suffix();
	      output << ", " << std::get<1>(crud[i]) << type_strings<Ret>::suffix();
	      output << " },\n";
	    }
	  output << "};\n";
	  output.fill('0');
	  output << "const " << numname << " toler" << std::setw(3) << _M_start_test << " = " << frac_toler << ";\n";
	  output.fill(' ');
	  ++_M_start_test;
	}
    }

/**
 * Build the function call string for the test suite.
 */
template<typename MaskFun, typename Ret, typename... Arg>
  std::ostringstream
  testcase2<MaskFun, Ret, Arg...>::
  get_funcall() const
  {
    std::ostringstream funcall;
    funcall << _M_testfun.funcname << _M_templparm << '(';
    get_funcall_help(funcall, std::index_sequence_for<Arg...>{});
    funcall << ')';
    return funcall;
  }

template<typename MaskFun, typename Ret, typename... Arg>
  template<std::size_t... Index>
    void
    testcase2<MaskFun, Ret, Arg...>::
    get_funcall_help(std::ostringstream & funcall, std::index_sequence<Index...>) const
    {
      using swallow = int[]; // guaranties left to right order
      (void)swallow
      {
	(void(funcall << (Index > 0 ? ", " : "")
		      << "data[i]."
		      << std::get<Index>(_M_range).name), 0)...
      };
      // This actually should work:
      //((funcall << (Index > 0 ? ", " : "") << "data[i].") << std::get<Index>(_M_range).name << ...);
    }

/**
 * Write the test case main function.
 */
template<typename MaskFun, typename Ret, typename... Arg>
  void
  testcase2<MaskFun, Ret, Arg...>::
  write_main(std::ostream & output,
	     bool riemann_zeta_limits,
	     std::experimental::string_view funcall) const
  {
    constexpr auto ret_complex = is_complex_v<Ret>;
    std::string ret_tname = "Ret";
    if (ret_complex)
      ret_tname = "std::complex<Ret>";

    output << '\n';
    output << "template<typename Ret, unsigned int Num>\n";
    output.fill('0');
    output << "  void\n";
    output << "  test(const " << _M_structname << "<Ret> (&data)[Num], Ret toler)\n";
    output.fill(' ');
    output << "  {\n";
    output << "    bool test __attribute__((unused)) = true;\n";
    output << "    const Ret eps = std::numeric_limits<Ret>::epsilon();\n";
    output << "    Ret max_abs_diff = -Ret(1);\n";
    output << "    Ret max_abs_frac = -Ret(1);\n";
    if (riemann_zeta_limits)
      output << "    unsigned int num_datum = MAX_ITERATIONS;\n";
    else
      output << "    unsigned int num_datum = Num;\n";
    output << "    for (unsigned int i = 0; i < num_datum; ++i)\n";
    output << "      {\n";
    output << "\tconst " << ret_tname << " f = " << funcall << ";\n";
    output << "\tconst " << ret_tname << " f0 = data[i].f0;\n";
    output << "\tconst " << ret_tname << " diff = f - f0;\n";
    output << "\tif (std::abs(diff) > max_abs_diff)\n";
    output << "\t  max_abs_diff = std::abs(diff);\n";
    output << "\tif (std::abs(f0) > Ret(10) * eps\n";
    output << "\t && std::abs(f) > Ret(10) * eps)\n";
    output << "\t  {\n";
    output << "\t    const " << ret_tname << " frac = diff / f0;\n";
    output << "\t    if (std::abs(frac) > max_abs_frac)\n";
    output << "\t      max_abs_frac = std::abs(frac);\n";
    output << "\t  }\n";
    output << "      }\n";
    output << "    VERIFY(max_abs_frac < toler);\n";
    output << "  }\n";
    output << '\n';

    output << "int\n";
    output << "main()\n";
    output << "{\n";
    output.fill('0');
    for (unsigned int t = 1; t < _M_start_test; ++t)
      output << "  test(data" << std::setw(3) << t << ", toler" << std::setw(3) << t << ");\n";
    output.fill(' ');
    output << "  return 0;\n";
    output << "}\n";
  }

#undef CONCEPT_BASELINEFUN
#undef CONCEPT_TESTFUN
#undef CONCEPT_MASK

#endif // TESTCASE2_TCC
