
/*
/home/ed/bin_tr29124/bin/g++ -std=gnu++17 -fconcepts -g -D__STDCPP_WANT_MATH_SPEC_FUNCS__ -o testcase2 -I/usr/local/include -I/usr/local/include testcase2.cpp gsl_wrap.cpp boost_wrap.cpp lerchphi/Source/lerchphi.cpp /home/ed/tr29124_test/gslextras/Fresnel/fresnel.c -L/usr/local/lib -lgsl -lgslcblas -ljacobi
*/

#ifndef TESTCASE2_TCC
#define TESTCASE2_TCC 1

#include <complex>
#include <sstream>
#include <experimental/type_traits>
#include <experimental/string_view>
#include "complex_compare.h" // For the Statistics min/max (maybe rethink that there)

const std::experimental::string_view boilerplate = 
R"(// { dg-options "-D__STDCPP_WANT_MATH_SPEC_FUNCS__" }
//
// Copyright (C) 2016 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING3.  If not see
// <http://www.gnu.org/licenses/>.
)";

const std::experimental::string_view header = 
R"(//  Compare against values generated by the GNU Scientific Library.
//  The GSL can be found on the web: http://www.gnu.org/software/gsl/
#include <limits>
#include <cmath>
#if defined(__TEST_DEBUG)
#  include <iostream>
#  define VERIFY(A) \
  if (!(A)) \
    { \
      std::cout << "line " << __LINE__ \
	<< "  max_abs_frac = " << max_abs_frac \
	<< std::endl; \
    }
#else
#  include <testsuite_hooks.h>
#endif
#include <specfun_testcase.h>
)";

const std::experimental::string_view riemann_limits = 
R"(// This can take long on simulators, timing out the test.
// { dg-options "-DMAX_ITERATIONS=5" { target simulator } }

#ifndef MAX_ITERATIONS
#define MAX_ITERATIONS (sizeof(data001) / sizeof(testcase_riemann_zeta<double>))
#endif
)";

/**
 * Introspection class to detect if a type is std::complex.
 */
template<typename _Tp>
  struct is_complex : public std::false_type
  { };

/**
 * Introspection class to detect if a type is std::complex.
 */
template<>
  template<typename _Tp>
    struct is_complex<std::complex<_Tp>> : public std::true_type
    { };

/**
 * Introspection type to detect if a type is std::complex.
 */
template<typename _Tp>
  using is_complex_t = typename is_complex<_Tp>::type;

/**
 * Introspection variable template to detect if a type is std::complex.
 */
template<typename _Tp>
  constexpr bool is_complex_v = is_complex<_Tp>::value;

/**
 *  Incremental computation of statistics.
 */
template<typename _Tp>
  struct _Statistics
  {
    _Statistics&
    operator<<(_Tp __diff)
    {
      ++_M_count;
      auto __old_mean = _M_mean;
      _M_mean = (_M_type(__diff) + _M_type(_M_count - 1) * _M_mean) / _M_type(_M_count);
      auto __del_mean = _M_mean - __old_mean;
      auto __del_diff = _M_type(__diff) - _M_mean;
      if (_M_count > 1)
	_M_variance = (_M_type(_M_count - 2) * _M_variance * _M_variance
		    + _M_type(_M_count - 1) * __del_mean * __del_mean
		    + __del_diff * __del_diff) / _M_type(_M_count - 1);
      if (__diff < _M_min)
	_M_min = __diff;
      if (__diff > _M_max)
	_M_max = __diff;

      return *this;
    }

    static constexpr bool _M_is_complex = is_complex_v<_Tp>;

    using _M_type = std::conditional_t<is_complex_v<_Tp>,
				       std::complex<long double>, long double>;

    _Tp
    count() const
    { return _Tp(_M_count); }

    _Tp
    mean() const
    { return _Tp(_M_mean); }

    _Tp
    variance() const
    { return _Tp(_M_variance); }

    _Tp
    std_deviation() const
    { return _Tp(std::sqrt(_M_variance)); }

    _Tp
    min() const
    { return _Tp(_M_min); }

    _Tp
    max() const
    { return _Tp(_M_max); }

    std::size_t _M_count = 0;
    _M_type _M_mean = 0;
    _M_type _M_variance = 0;
    _M_type _M_min = std::numeric_limits<long double>::max();
    _M_type _M_max = std::numeric_limits<long double>::lowest();
  };


/// A class to abstract the scalar data type in a generic way.
template<typename Tp>
  struct __num_traits
  {
    using __value_type = Tp;
  };

template<>
  template<typename Tp>
    struct __num_traits<std::complex<Tp>>
    {
      using __value_type = typename std::complex<Tp>::value_type;
    };

template<typename Tp>
  using __num_traits_t = typename __num_traits<Tp>::__value_type;

template<typename Tp>
  struct type_strings
  {
    static const std::experimental::string_view
    type()
    { return std::experimental::string_view(""); }

    static const std::experimental::string_view
    suffix()
    { return std::experimental::string_view(""); }
  };

template<>
  struct type_strings<float>
  {
    static const std::experimental::string_view
    type()
    { return std::string("float"); }

    static const std::experimental::string_view
    suffix()
    { return std::experimental::string_view("F"); }
  };

template<>
  struct type_strings<double>
  {
    static const std::experimental::string_view
    type()
    { return std::experimental::string_view("double"); }

    static const std::experimental::string_view
    suffix()
    { return std::experimental::string_view(""); }
  };

template<>
  struct type_strings<long double>
  {
    static const std::experimental::string_view
    type()
    { return std::experimental::string_view("long double"); }

    static const std::experimental::string_view
    suffix()
    { return std::experimental::string_view("L"); }
  };

template<>
  struct type_strings<__float128>
  {
    static const std::experimental::string_view
    type()
    { return std::experimental::string_view("__float128"); }

    static const std::experimental::string_view
    suffix()
    { return std::experimental::string_view("Q"); }
  };

// Fuck me.  I'm too stupid to do this right.
template<>
  struct type_strings<std::complex<float>>
  {
    static const std::experimental::string_view
    type()
    { return std::experimental::string_view("std::complex<float>"); }

    static const std::experimental::string_view
    suffix()
    { return std::experimental::string_view(""); }
  };

template<>
  struct type_strings<std::complex<double>>
  {
    static const std::experimental::string_view
    type()
    { return std::experimental::string_view("std::complex<double>"); }

    static const std::experimental::string_view
    suffix()
    { return std::experimental::string_view(""); }
  };

template<>
  struct type_strings<std::complex<long double>>
  {
    static const std::experimental::string_view
    type()
    { return std::experimental::string_view("std::complex<long double>"); }

    static const std::experimental::string_view
    suffix()
    { return std::experimental::string_view(""); }
  };

template<>
  struct type_strings<std::complex<__float128>>
  {
    static const std::experimental::string_view
    type()
    { return std::experimental::string_view("std::complex<__float128>"); }

    static const std::experimental::string_view
    suffix()
    { return std::experimental::string_view(""); }
  };


///
///  @brief  Append two testcase vectors.
///
template<typename Tp>
  std::vector<Tp>
  fill_argument(std::vector<Tp>&& arg, std::vector<Tp>&& more)
  {
    std::vector<Tp> ret;
    ret.reserve(arg.size() + more.size());
    ret.insert(ret.end(), arg.begin(), arg.end());
    ret.insert(ret.end(), more.begin(), more.end());
    return ret;
  }

///
///  @brief  Fill an array with evenly spaced values between two limits.
///
template<typename Tp>
  std::vector<Tp>
  fill_argument(const std::pair<Tp,Tp> & _M_range,
		const std::pair<bool,bool> & inclusive,
		unsigned int num_points)
  {
    std::vector<Tp> argument;

    if (num_points == 1)
      {
	argument.push_back(_M_range.first);
	return argument;
      }

    auto delta = (_M_range.second - _M_range.first) / (num_points - 1);
    auto min = std::min(_M_range.first, _M_range.second);
    auto max = std::max(_M_range.first, _M_range.second);
    auto clamp = [min, max](Tp x)
		 -> Tp
		 {
		   if (x < min)
		     return min;
		   else if (x > max)
		     return max;
		   else
		     return x;
		 };
    for (unsigned int i = 0; i < num_points; ++i)
      {
	if (i == 0 && ! inclusive.first)
	  continue;
	if (i == num_points - 1 && ! inclusive.second)
	  continue;

	argument.push_back(clamp(_M_range.first + i * delta));
      }

    return argument;
  }


///
///  @brief  Find a nice round number limit.
///
template<typename Tp>
  Tp
  get_tolerance(Tp delta, Tp min_tol, bool & ok)
  {
    using Val = __num_traits_t<Tp>;

    const auto abs_delta = std::abs(delta);
    //  Make this some number larger because you lose some accuracy writing and reading.
    const auto eps = Tp{10} * std::numeric_limits<Val>::epsilon();
    Tp tol = min_tol;
    while (tol > std::abs(delta)
	&& tol > eps)
      {
	if (Tp(0.5L) * tol > abs_delta
	 && Tp(0.5L) * tol > eps)
	  {
	    if (Tp(0.2L) * tol > abs_delta
	     && Tp(0.2L) * tol > eps)
	      {
		if (Tp(0.1L) * tol > abs_delta
		 && Tp(0.1L) * tol > eps)
		  {
		    tol *= Tp(0.1L);
		  }
		else
		  {
		    tol *= Tp(0.2L);
		    break;
		  }
	      }
	    else
	      {
		tol *= Tp(0.5L);
		break;
	      }
	  }
	else
	  break;
      }
    ok = true;
    if (tol < min_tol && tol <= abs_delta)
      {
	ok = false;
	std::cerr << "**** Error in get_tolerance:"
		  << " abs(delta)=" << abs_delta
		  << " tol=" << tol
		  << '\n';
      }
    if (tol == min_tol && tol < abs_delta)
      {
	ok = false;
	std::cerr << "Note in get_tolerance:"
		  << " delta=" << delta
		  << " tol=" << tol
		  << '\n';
      }

    //  Somehow, we seem to need extra space to get the tests to pass.
    //  TODO: Figure this out.
    return Tp(50.0L) * tol;
  }

#if __cpp_concepts > 0

/**
 * A concept for mask functions.
 */
template<typename Fun, typename... Arg>
  concept bool
  Mask()
  requires(Fun mask, Arg... args)
  {
    { mask(args...) } -> bool;
  };
#  define CONCEPT_MASK Mask

/**
 * A concept for test functions.
 */
template<typename Fun, typename Ret, typename... Arg>
  concept bool
  TestFun()
  requires(Fun test, Arg... args)
  {
    //typename ::funcname;
    { test(args...) } -> Ret;
  };
#  define CONCEPT_TESTFUN TestFun

/**
 * A concept for baseline functions.
 */
template<typename Fun, typename Ret, typename... Arg>
  concept bool
  BaselineFun()
  requires(Fun baseline, Arg... args)
  {
    //typename ::source;
    //typename ::funcname;
    { baseline(args...) } -> Ret;
  };
#  define CONCEPT_BASELINEFUN BaselineFun

#else // Remember to #undef these below.
#  define CONCEPT_MASK typename
#  define CONCEPT_TESTFUN typename
#  define CONCEPT_BASELINEFUN typename
#endif

/**
 * A class for function arguments.
 */
template<typename Arg>
  class argument
  {

  public:

    argument(std::experimental::string_view arg,
	     const std::vector<Arg> & val)
    : name(arg),
      value(val)
    {}

    std::experimental::string_view name;
    std::vector<Arg> value;
    std::vector<Arg> error;

  private:

  };

/**
 * A class for test function - the function to be tested.
 */
template<typename Ret, typename... Arg>
  class test_function
  {

  public:

    test_function(std::experimental::string_view name,
		  Ret func(Arg...))
    : funcname(name),
      function(func)
    {}

    std::experimental::string_view funcname;
    Ret (*function)(Arg...);

  private:

  };

/**
 * A class for baseline function - the function that is a baseline.
 */
template<typename Ret, typename... Arg>
  class baseline_function
  {

  public:

    baseline_function(std::experimental::string_view src,
		      std::experimental::string_view name,
		      Ret func(Arg...))
    : source(src),
      funcname(name),
      function(func)
    {}

    std::experimental::string_view source;
    std::experimental::string_view funcname;
    Ret (*function)(Arg...);

  private:

  };


/**
 * A class for testcases.
 */
template<CONCEPT_MASK MaskFun, typename Ret, typename... Arg>
  class testcase2
  {

  public:

    testcase2(test_function<Ret, Arg...> test,
	     baseline_function<Ret, Arg...> base,
	     MaskFun mask,
	     std::experimental::string_view structname,
	     argument<Arg>... arg)
    : _M_testfun(test),
      _M_basefun(base),
      _M_maskfun(mask),
      _M_function1(_M_testfun.function),
      _M_function2(_M_basefun.function),
      _M_structname(structname),
      _M_range(arg...)
    {
      funcall = get_funcall();

      // Some functions taking only integral arguments must have explicit template args.
      auto _M_all_integral = !(std::experimental::is_floating_point_v<Arg> || ...);
      if (_M_all_integral)
	_M_templparm += "<Ret>";
    }

    void
    operator()(std::ostream & output) const
    {
      // Some targets take too long for riemann zeta.
      bool riemann_zeta_limits
	= (_S_arity == 1 && _M_testfun.funcname == "riemann_zeta");

      output << boilerplate << '\n';
      output << "//  " << _M_testfun.funcname << '\n' << '\n';
      if (riemann_zeta_limits)
	output << riemann_limits << '\n';
      output << header;

      write_test_data(output, std::index_sequence_for<Arg...>{});

      write_main(output, riemann_zeta_limits, get_funcall().str());
    }


  private:

    std::ostringstream get_funcall() const;

    template<std::size_t... Index>
      void get_funcall_help(std::ostringstream &, std::index_sequence<Index...>) const;

    template<std::size_t... Index>
      void write_test_data(std::ostream &, std::index_sequence<Index...>) const;

    static const auto _S_arity = sizeof...(Arg);

    void write_main(std::ostream & output,
		    bool riemann_zeta_limits,
		    std::experimental::string_view funcall) const;

    std::experimental::string_view _M_structname;
    unsigned int _M_start_test = 1;
    test_function<Ret, Arg...> _M_testfun;
    baseline_function<Ret, Arg...> _M_basefun;
    MaskFun _M_maskfun;
    Ret (*_M_function1)(Arg...);
    Ret (*_M_function2)(Arg...);
    std::tuple<argument<Arg>...> _M_range;
    std::ostringstream funcall;
    std::string _M_templparm;
    bool _M_all_integral = true;
  };

/**
 * A testcase maker - ADL to the rescue.
 */
template<CONCEPT_MASK MaskFun, typename Ret, typename... Arg>
  testcase2<MaskFun, Ret, Arg...>
  make_testcase2(test_function<Ret, Arg...> test,
		 baseline_function<Ret, Arg...> base,
		 MaskFun mask,
		 std::experimental::string_view structname,
		 argument<Arg>... arg)
  {
    return testcase2<MaskFun, Ret, Arg...>(test, base, mask, structname, arg...);
  }

template<typename MaskFun, typename Ret, typename... Arg>
  template<std::size_t... Index>
    void
    testcase2<MaskFun, Ret, Arg...>::
    write_test_data(std::ostream & output, std::index_sequence<Index...>) const
    {
      using Val = __num_traits_t<Ret>;

      const int old_prec = output.precision(std::numeric_limits<Val>::max_digits10);
      output.flags(std::ios::showpoint);



      constexpr auto eps = std::numeric_limits<Val>::epsilon();
      constexpr auto inf = std::numeric_limits<Val>::infinity();
      constexpr auto NaN = std::numeric_limits<Val>::quiet_NaN();
      constexpr auto ret_complex = is_complex_v<Ret>;

      auto numname = type_strings<Val>::type().to_string();
      auto structname = _M_structname.to_string() + '<' + numname + '>';
      //write_test_data<Index + 1>(output);
    }

/**
 * Build the function call string for the test suite.
 */
template<typename MaskFun, typename Ret, typename... Arg>
  std::ostringstream
  testcase2<MaskFun, Ret, Arg...>::
  get_funcall() const
  {
    std::ostringstream funcall;
    funcall << _M_testfun.funcname << _M_templparm << '(';
    get_funcall_help(funcall, std::index_sequence_for<Arg...>{});
    funcall << ')';
    return funcall;
  }

template<typename MaskFun, typename Ret, typename... Arg>
  template<std::size_t... Index>
    void
    testcase2<MaskFun, Ret, Arg...>::
    get_funcall_help(std::ostringstream & funcall, std::index_sequence<Index...>) const
    {
      using swallow = int[]; // guaranties left to right order
      (void)swallow
      {
	(void(funcall << (Index > 0 ? ", " : "")
		      << "data[i]."
		      << std::get<Index>(_M_range).name), 0)...
      };
      // Could we do this with fold expressions?
      //(funcall << (Index > 0 ? ", " : "") << "data[i].") << std::get<Index>(_M_range).name << ...;
    }

/**
 * Write the test case main function.
 */
template<typename MaskFun, typename Ret, typename... Arg>
  void
  testcase2<MaskFun, Ret, Arg...>::
  write_main(std::ostream & output,
	     bool riemann_zeta_limits,
	     std::experimental::string_view funcall) const
  {
    constexpr auto ret_complex = is_complex_v<Ret>;
    std::string ret_tname = "Ret";
    if (ret_complex)
      ret_tname = "std::complex<Ret>";

    output << '\n';
    output << "template<typename Ret, unsigned int Num>\n";
    output.fill('0');
    output << "  void\n";
    output << "  test(const " << _M_structname << "<Ret> (&data)[Num], Ret toler)\n";
    output.fill(' ');
    output << "  {\n";
    output << "    bool test __attribute__((unused)) = true;\n";
    output << "    const Ret eps = std::numeric_limits<Ret>::epsilon();\n";
    output << "    Ret max_abs_diff = -Ret(1);\n";
    output << "    Ret max_abs_frac = -Ret(1);\n";
    if (riemann_zeta_limits)
      output << "    unsigned int num_datum = MAX_ITERATIONS;\n";
    else
      output << "    unsigned int num_datum = Num;\n";
    output << "    for (unsigned int i = 0; i < num_datum; ++i)\n";
    output << "      {\n";
    output << "\tconst " << ret_tname << " f = " << funcall << ";\n";
    output << "\tconst " << ret_tname << " f0 = data[i].f0;\n";
    output << "\tconst " << ret_tname << " diff = f - f0;\n";
    output << "\tif (std::abs(diff) > max_abs_diff)\n";
    output << "\t  max_abs_diff = std::abs(diff);\n";
    output << "\tif (std::abs(f0) > Ret(10) * eps\n";
    output << "\t && std::abs(f) > Ret(10) * eps)\n";
    output << "\t  {\n";
    output << "\t    const " << ret_tname << " frac = diff / f0;\n";
    output << "\t    if (std::abs(frac) > max_abs_frac)\n";
    output << "\t      max_abs_frac = std::abs(frac);\n";
    output << "\t  }\n";
    output << "      }\n";
    output << "    VERIFY(max_abs_frac < toler);\n";
    output << "  }\n";
    output << '\n';

    output << "int\n";
    output << "main()\n";
    output << "{\n";
    output.fill('0');
    for (unsigned int t = 1; t < _M_start_test; ++t)
      output << "  test(data" << std::setw(3) << t << ", toler" << std::setw(3) << t << ");\n";
    output.fill(' ');
    output << "  return 0;\n";
    output << "}\n";
  }

#undef CONCEPT_BASELINEFUN
#undef CONCEPT_TESTFUN
#undef CONCEPT_MASK

#endif // TESTCASE2_TCC

