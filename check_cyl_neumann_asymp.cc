// { dg-options "-D__STDCPP_WANT_MATH_SPEC_FUNCS__" }
//
// Copyright (C) 2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING3.  If not see
// <http://www.gnu.org/licenses/>.

//  cyl_neumann_asymp
//  Compare against values generated by the GNU Scientific Library.
//  The GSL can be found on the web: http://www.gnu.org/software/gsl/
#include <limits>
#include <cmath>
#if defined(__TEST_DEBUG)
#  include <iostream>
#  define VERIFY(A) \
  if (!(A)) \
    { \
      std::cout << "line " << __LINE__ \
	<< "  max_abs_frac = " << max_abs_frac \
	<< std::endl; \
    }
#else
#  include <testsuite_hooks.h>
#endif
#include "../testcase.h"


// Test data for nu=0.0000000000000000.
testcase_cyl_neumann_asymp<double> data001[] = {
  { 0.018169168409408260, 0.0000000000000000, 1900.0000000000000 },
  { -0.00083647562019260803, 0.0000000000000000, 2800.0000000000000 },
  { -0.013116378945683339, 0.0000000000000000, 3700.0000000000000 },
  { -0.00090576923667506231, 0.0000000000000000, 4600.0000000000000 },
  { 0.010648304274360689, 0.0000000000000000, 5500.0000000000000 },
  { 0.0020757023306041361, 0.0000000000000000, 6400.0000000000000 },
  { -0.0089852362241878234, 0.0000000000000000, 7300.0000000000000 },
  { -0.0029570022049836861, 0.0000000000000000, 8200.0000000000000 },
  { 0.0076757755573784326, 0.0000000000000000, 9100.0000000000000 },
  { 0.0036478055589866053, 0.0000000000000000, 10000.000000000000 },
};

// Test function for nu=0.0000000000000000.
template<typename Tp>
  void
  test001()
  {
    bool test [[gnu::unused]] = true;
    const Tp eps = std::numeric_limits<Tp>::epsilon();
    Tp max_abs_diff = -Tp(1);
    Tp max_abs_frac = -Tp(1);
    unsigned int num_datum = sizeof(data001)
			   / sizeof(testcase_cyl_neumann_asymp<double>);
    for (unsigned int i = 0; i < num_datum; ++i)
      {
	const Tp f = std::cyl_neumann_asymp(Tp(data001[i].nu), Tp(data001[i].x));
	const Tp f0 = data001[i].f0;
	const Tp diff = f - f0;
	if (std::abs(diff) > max_abs_diff)
	  max_abs_diff = std::abs(diff);
	if (std::abs(f0) > Tp(10) * eps
	 && std::abs(f) > Tp(10) * eps)
	  {
	    const Tp frac = diff / f0;
	    if (std::abs(frac) > max_abs_frac)
	      max_abs_frac = std::abs(frac);
	  }
      }
    VERIFY(max_abs_frac < Tp(0.025000000000000001));
  }

// Test data for nu=0.33333333333333331.
testcase_cyl_neumann_asymp<double> data002[] = {
  { 0.016846965102846709, 0.33333333333333331, 1900.0000000000000 },
  { 0.0068030145942105736, 0.33333333333333331, 2800.0000000000000 },
  { -0.011288507522451164, 0.33333333333333331, 3700.0000000000000 },
  { -0.0066489243759160696, 0.33333333333333331, 4600.0000000000000 },
  { 0.0084532210772221041, 0.33333333333333331, 5500.0000000000000 },
  { 0.0066751305311630793, 0.33333333333333331, 6400.0000000000000 },
  { -0.0065093187070457744, 0.33333333333333331, 7300.0000000000000 },
  { -0.0067108815345043593, 0.33333333333333331, 8200.0000000000000 },
  { 0.0049860812214548734, 0.33333333333333331, 9100.0000000000000 },
  { 0.0067071484519784161, 0.33333333333333331, 10000.000000000000 },
};

// Test function for nu=0.33333333333333331.
template<typename Tp>
  void
  test002()
  {
    bool test [[gnu::unused]] = true;
    const Tp eps = std::numeric_limits<Tp>::epsilon();
    Tp max_abs_diff = -Tp(1);
    Tp max_abs_frac = -Tp(1);
    unsigned int num_datum = sizeof(data002)
			   / sizeof(testcase_cyl_neumann_asymp<double>);
    for (unsigned int i = 0; i < num_datum; ++i)
      {
	const Tp f = std::cyl_neumann_asymp(Tp(data002[i].nu), Tp(data002[i].x));
	const Tp f0 = data002[i].f0;
	const Tp diff = f - f0;
	if (std::abs(diff) > max_abs_diff)
	  max_abs_diff = std::abs(diff);
	if (std::abs(f0) > Tp(10) * eps
	 && std::abs(f) > Tp(10) * eps)
	  {
	    const Tp frac = diff / f0;
	    if (std::abs(frac) > max_abs_frac)
	      max_abs_frac = std::abs(frac);
	  }
      }
    VERIFY(max_abs_frac < Tp(0.025000000000000001));
  }

// Test data for nu=0.50000000000000000.
testcase_cyl_neumann_asymp<double> data003[] = {
  { 0.014420598704121726, 0.50000000000000000, 1900.0000000000000 },
  { 0.010053783111007217, 0.50000000000000000, 2800.0000000000000 },
  { -0.0091749979474336756, 0.50000000000000000, 3700.0000000000000 },
  { -0.0089340961688000094, 0.50000000000000000, 4600.0000000000000 },
  { 0.0064427927616249490, 0.50000000000000000, 5500.0000000000000 },
  { 0.0083655824549290804, 0.50000000000000000, 6400.0000000000000 },
  { -0.0045545338107322196, 0.50000000000000000, 7300.0000000000000 },
  { -0.0079599598223485286, 0.50000000000000000, 8200.0000000000000 },
  { 0.0030781587347138324, 0.50000000000000000, 9100.0000000000000 },
  { 0.0075971006781943452, 0.50000000000000000, 10000.000000000000 },
};

// Test function for nu=0.50000000000000000.
template<typename Tp>
  void
  test003()
  {
    bool test [[gnu::unused]] = true;
    const Tp eps = std::numeric_limits<Tp>::epsilon();
    Tp max_abs_diff = -Tp(1);
    Tp max_abs_frac = -Tp(1);
    unsigned int num_datum = sizeof(data003)
			   / sizeof(testcase_cyl_neumann_asymp<double>);
    for (unsigned int i = 0; i < num_datum; ++i)
      {
	const Tp f = std::cyl_neumann_asymp(Tp(data003[i].nu), Tp(data003[i].x));
	const Tp f0 = data003[i].f0;
	const Tp diff = f - f0;
	if (std::abs(diff) > max_abs_diff)
	  max_abs_diff = std::abs(diff);
	if (std::abs(f0) > Tp(10) * eps
	 && std::abs(f) > Tp(10) * eps)
	  {
	    const Tp frac = diff / f0;
	    if (std::abs(frac) > max_abs_frac)
	      max_abs_frac = std::abs(frac);
	  }
      }
    VERIFY(max_abs_frac < Tp(0.025000000000000001));
  }

// Test data for nu=0.66666666666666663.
testcase_cyl_neumann_asymp<double> data004[] = {
  { 0.011011978904613464, 0.66666666666666663, 1900.0000000000000 },
  { 0.012619450163147210, 0.66666666666666663, 2800.0000000000000 },
  { -0.0064364023616379227, 0.66666666666666663, 3700.0000000000000 },
  { -0.010610463219362853, 0.66666666666666663, 4600.0000000000000 },
  { 0.0039933913263344748, 0.66666666666666663, 5500.0000000000000 },
  { 0.0094859673817803292, 0.66666666666666663, 6400.0000000000000 },
  { -0.0022894218374445280, 0.66666666666666663, 7300.0000000000000 },
  { -0.0086666095154495845, 0.66666666666666663, 8200.0000000000000 },
  { 0.00096050233738250845, 0.66666666666666663, 9100.0000000000000 },
  { 0.0079693492775676656, 0.66666666666666663, 10000.000000000000 },
};

// Test function for nu=0.66666666666666663.
template<typename Tp>
  void
  test004()
  {
    bool test [[gnu::unused]] = true;
    const Tp eps = std::numeric_limits<Tp>::epsilon();
    Tp max_abs_diff = -Tp(1);
    Tp max_abs_frac = -Tp(1);
    unsigned int num_datum = sizeof(data004)
			   / sizeof(testcase_cyl_neumann_asymp<double>);
    for (unsigned int i = 0; i < num_datum; ++i)
      {
	const Tp f = std::cyl_neumann_asymp(Tp(data004[i].nu), Tp(data004[i].x));
	const Tp f0 = data004[i].f0;
	const Tp diff = f - f0;
	if (std::abs(diff) > max_abs_diff)
	  max_abs_diff = std::abs(diff);
	if (std::abs(f0) > Tp(10) * eps
	 && std::abs(f) > Tp(10) * eps)
	  {
	    const Tp frac = diff / f0;
	    if (std::abs(frac) > max_abs_frac)
	      max_abs_frac = std::abs(frac);
	  }
      }
    VERIFY(max_abs_frac < Tp(0.025000000000000001));
  }

// Test data for nu=1.0000000000000000.
testcase_cyl_neumann_asymp<double> data005[] = {
  { 0.0022283699321674960, 1.0000000000000000, 1900.0000000000000 },
  { 0.015055232277014111, 1.0000000000000000, 2800.0000000000000 },
  { 0.00013964788180102200, 1.0000000000000000, 3700.0000000000000 },
  { -0.011729343338776108, 1.0000000000000000, 4600.0000000000000 },
  { -0.0015361283074000968, 1.0000000000000000, 5500.0000000000000 },
  { 0.0097553300020834822, 1.0000000000000000, 6400.0000000000000 },
  { 0.0025437347486285556, 1.0000000000000000, 7300.0000000000000 },
  { -0.0083003426936245749, 1.0000000000000000, 8200.0000000000000 },
  { -0.0033223310682763169, 1.0000000000000000, 9100.0000000000000 },
  { 0.0070963427525364969, 1.0000000000000000, 10000.000000000000 },
};

// Test function for nu=1.0000000000000000.
template<typename Tp>
  void
  test005()
  {
    bool test [[gnu::unused]] = true;
    const Tp eps = std::numeric_limits<Tp>::epsilon();
    Tp max_abs_diff = -Tp(1);
    Tp max_abs_frac = -Tp(1);
    unsigned int num_datum = sizeof(data005)
			   / sizeof(testcase_cyl_neumann_asymp<double>);
    for (unsigned int i = 0; i < num_datum; ++i)
      {
	const Tp f = std::cyl_neumann_asymp(Tp(data005[i].nu), Tp(data005[i].x));
	const Tp f0 = data005[i].f0;
	const Tp diff = f - f0;
	if (std::abs(diff) > max_abs_diff)
	  max_abs_diff = std::abs(diff);
	if (std::abs(f0) > Tp(10) * eps
	 && std::abs(f) > Tp(10) * eps)
	  {
	    const Tp frac = diff / f0;
	    if (std::abs(frac) > max_abs_frac)
	      max_abs_frac = std::abs(frac);
	  }
      }
    VERIFY(max_abs_frac < Tp(0.010000000000000000));
  }

// Test data for nu=2.0000000000000000.
testcase_cyl_neumann_asymp<double> data006[] = {
  { -0.018166822756848083, 2.0000000000000000, 1900.0000000000000 },
  { 0.00084722935753333238, 2.0000000000000000, 2800.0000000000000 },
  { 0.013116454431024853, 2.0000000000000000, 3700.0000000000000 },
  { 0.00090066952217994229, 2.0000000000000000, 4600.0000000000000 },
  { -0.010648862866472472, 2.0000000000000000, 5500.0000000000000 },
  { -0.0020726537899784848, 2.0000000000000000, 6400.0000000000000 },
  { 0.0089859331378175852, 2.0000000000000000, 7300.0000000000000 },
  { 0.0029549777311559727, 2.0000000000000000, 8200.0000000000000 },
  { -0.0076765057400308007, 2.0000000000000000, 9100.0000000000000 },
  { -0.0036463862904360981, 2.0000000000000000, 10000.000000000000 },
};

// Test function for nu=2.0000000000000000.
template<typename Tp>
  void
  test006()
  {
    bool test [[gnu::unused]] = true;
    const Tp eps = std::numeric_limits<Tp>::epsilon();
    Tp max_abs_diff = -Tp(1);
    Tp max_abs_frac = -Tp(1);
    unsigned int num_datum = sizeof(data006)
			   / sizeof(testcase_cyl_neumann_asymp<double>);
    for (unsigned int i = 0; i < num_datum; ++i)
      {
	const Tp f = std::cyl_neumann_asymp(Tp(data006[i].nu), Tp(data006[i].x));
	const Tp f0 = data006[i].f0;
	const Tp diff = f - f0;
	if (std::abs(diff) > max_abs_diff)
	  max_abs_diff = std::abs(diff);
	if (std::abs(f0) > Tp(10) * eps
	 && std::abs(f) > Tp(10) * eps)
	  {
	    const Tp frac = diff / f0;
	    if (std::abs(frac) > max_abs_frac)
	      max_abs_frac = std::abs(frac);
	  }
      }
    VERIFY(max_abs_frac < Tp(0.025000000000000001));
  }

// Test data for nu=5.0000000000000000.
testcase_cyl_neumann_asymp<double> data007[] = {
  { 0.0023430776222766775, 5.0000000000000000, 1900.0000000000000 },
  { 0.015051509126571931, 5.0000000000000000, 2800.0000000000000 },
  { 9.7107589675514720e-05, 5.0000000000000000, 3700.0000000000000 },
  { -0.011731666302459988, 5.0000000000000000, 4600.0000000000000 },
  { -0.0015128919995784831, 5.0000000000000000, 5500.0000000000000 },
  { 0.0097592047943942887, 5.0000000000000000, 6400.0000000000000 },
  { 0.0025289610649018076, 5.0000000000000000, 7300.0000000000000 },
  { -0.0083046611249616778, 5.0000000000000000, 8200.0000000000000 },
  { -0.0033122062797636153, 5.0000000000000000, 9100.0000000000000 },
  { 0.0071007150091403929, 5.0000000000000000, 10000.000000000000 },
};

// Test function for nu=5.0000000000000000.
template<typename Tp>
  void
  test007()
  {
    bool test [[gnu::unused]] = true;
    const Tp eps = std::numeric_limits<Tp>::epsilon();
    Tp max_abs_diff = -Tp(1);
    Tp max_abs_frac = -Tp(1);
    unsigned int num_datum = sizeof(data007)
			   / sizeof(testcase_cyl_neumann_asymp<double>);
    for (unsigned int i = 0; i < num_datum; ++i)
      {
	const Tp f = std::cyl_neumann_asymp(Tp(data007[i].nu), Tp(data007[i].x));
	const Tp f0 = data007[i].f0;
	const Tp diff = f - f0;
	if (std::abs(diff) > max_abs_diff)
	  max_abs_diff = std::abs(diff);
	if (std::abs(f0) > Tp(10) * eps
	 && std::abs(f) > Tp(10) * eps)
	  {
	    const Tp frac = diff / f0;
	    if (std::abs(frac) > max_abs_frac)
	      max_abs_frac = std::abs(frac);
	  }
      }
    VERIFY(max_abs_frac < Tp(0.050000000000000003));
  }

// Test data for nu=10.000000000000000.
testcase_cyl_neumann_asymp<double> data008[] = {
  { -0.018104494001294564, 10.000000000000000, 1900.0000000000000 },
  { 0.0011051778567780575, 10.000000000000000, 2800.0000000000000 },
  { 0.013117116321278368, 10.000000000000000, 3700.0000000000000 },
  { 0.00077822732148991058, 10.000000000000000, 4600.0000000000000 },
  { -0.010661846490159112, 10.000000000000000, 5500.0000000000000 },
  { -0.0019994287181207349, 10.000000000000000, 6400.0000000000000 },
  { 0.0090024566078135033, 10.000000000000000, 7300.0000000000000 },
  { 0.0029063378762620453, 10.000000000000000, 8200.0000000000000 },
  { -0.0076939188095742714, 10.000000000000000, 9100.0000000000000 },
  { -0.0036122802078804154, 10.000000000000000, 10000.000000000000 },
};

// Test function for nu=10.000000000000000.
template<typename Tp>
  void
  test008()
  {
    bool test [[gnu::unused]] = true;
    const Tp eps = std::numeric_limits<Tp>::epsilon();
    Tp max_abs_diff = -Tp(1);
    Tp max_abs_frac = -Tp(1);
    unsigned int num_datum = sizeof(data008)
			   / sizeof(testcase_cyl_neumann_asymp<double>);
    for (unsigned int i = 0; i < num_datum; ++i)
      {
	const Tp f = std::cyl_neumann_asymp(Tp(data008[i].nu), Tp(data008[i].x));
	const Tp f0 = data008[i].f0;
	const Tp diff = f - f0;
	if (std::abs(diff) > max_abs_diff)
	  max_abs_diff = std::abs(diff);
	if (std::abs(f0) > Tp(10) * eps
	 && std::abs(f) > Tp(10) * eps)
	  {
	    const Tp frac = diff / f0;
	    if (std::abs(frac) > max_abs_frac)
	      max_abs_frac = std::abs(frac);
	  }
      }
    VERIFY(max_abs_frac < Tp(0.050000000000000003));
  }

// Test data for nu=20.000000000000000.
testcase_cyl_neumann_asymp<double> data009[] = {
  { 0.017835461306657755, 20.000000000000000, 1900.0000000000000 },
  { -0.0019088416545216451, 20.000000000000000, 2800.0000000000000 },
  { -0.013104957901631546, 20.000000000000000, 3700.0000000000000 },
  { -0.00039510782105818456, 20.000000000000000, 4600.0000000000000 },
  { 0.010697182351422977, 20.000000000000000, 5500.0000000000000 },
  { 0.0017698935829637695, 20.000000000000000, 6400.0000000000000 },
  { -0.0090515807594518712, 20.000000000000000, 7300.0000000000000 },
  { -0.0027537037941002289, 20.000000000000000, 8200.0000000000000 },
  { 0.0077469528416631520, 20.000000000000000, 9100.0000000000000 },
  { 0.0035051657346460820, 20.000000000000000, 10000.000000000000 },
};

// Test function for nu=20.000000000000000.
template<typename Tp>
  void
  test009()
  {
    bool test [[gnu::unused]] = true;
    const Tp eps = std::numeric_limits<Tp>::epsilon();
    Tp max_abs_diff = -Tp(1);
    Tp max_abs_frac = -Tp(1);
    unsigned int num_datum = sizeof(data009)
			   / sizeof(testcase_cyl_neumann_asymp<double>);
    for (unsigned int i = 0; i < num_datum; ++i)
      {
	const Tp f = std::cyl_neumann_asymp(Tp(data009[i].nu), Tp(data009[i].x));
	const Tp f0 = data009[i].f0;
	const Tp diff = f - f0;
	if (std::abs(diff) > max_abs_diff)
	  max_abs_diff = std::abs(diff);
	if (std::abs(f0) > Tp(10) * eps
	 && std::abs(f) > Tp(10) * eps)
	  {
	    const Tp frac = diff / f0;
	    if (std::abs(frac) > max_abs_frac)
	      max_abs_frac = std::abs(frac);
	  }
      }
    VERIFY(max_abs_frac < Tp(0.050000000000000003));
  }

// Test data for nu=50.000000000000000.
testcase_cyl_neumann_asymp<double> data010[] = {
  { -0.013019071050481064, 50.000000000000000, 1900.0000000000000 },
  { 0.0072553455615230120, 50.000000000000000, 2800.0000000000000 },
  { 0.012422375184533534, 50.000000000000000, 3700.0000000000000 },
  { -0.0022757787231334897, 50.000000000000000, 4600.0000000000000 },
  { -0.010721038661852872, 50.000000000000000, 5500.0000000000000 },
  { -0.00014301376194502896, 50.000000000000000, 6400.0000000000000 },
  { 0.0092874911124076285, 50.000000000000000, 7300.0000000000000 },
  { 0.0016623491280457234, 50.000000000000000, 8200.0000000000000 },
  { -0.0080585238900388115, 50.000000000000000, 9100.0000000000000 },
  { -0.0027346474108072187, 50.000000000000000, 10000.000000000000 },
};

// Test function for nu=50.000000000000000.
template<typename Tp>
  void
  test010()
  {
    bool test [[gnu::unused]] = true;
    const Tp eps = std::numeric_limits<Tp>::epsilon();
    Tp max_abs_diff = -Tp(1);
    Tp max_abs_frac = -Tp(1);
    unsigned int num_datum = sizeof(data010)
			   / sizeof(testcase_cyl_neumann_asymp<double>);
    for (unsigned int i = 0; i < num_datum; ++i)
      {
	const Tp f = std::cyl_neumann_asymp(Tp(data010[i].nu), Tp(data010[i].x));
	const Tp f0 = data010[i].f0;
	const Tp diff = f - f0;
	if (std::abs(diff) > max_abs_diff)
	  max_abs_diff = std::abs(diff);
	if (std::abs(f0) > Tp(10) * eps
	 && std::abs(f) > Tp(10) * eps)
	  {
	    const Tp frac = diff / f0;
	    if (std::abs(frac) > max_abs_frac)
	      max_abs_frac = std::abs(frac);
	  }
      }
    VERIFY(max_abs_frac < Tp(0.050000000000000003));
  }

// Test data for nu=100.00000000000000.
testcase_cyl_neumann_asymp<double> data011[] = {
  { -0.016958415593079763, 100.00000000000000, 1900.0000000000000 },
  { -0.014534495161704743, 100.00000000000000, 2800.0000000000000 },
  { -0.0029928030158166605, 100.00000000000000, 3700.0000000000000 },
  { 0.0099630041633254150, 100.00000000000000, 4600.0000000000000 },
  { 0.0077561310197815838, 100.00000000000000, 5500.0000000000000 },
  { -0.0053959158712868971, 100.00000000000000, 6400.0000000000000 },
  { -0.0085686964032746209, 100.00000000000000, 7300.0000000000000 },
  { 0.0023292701741820707, 100.00000000000000, 8200.0000000000000 },
  { 0.0082814375976159975, 100.00000000000000, 9100.0000000000000 },
  { -0.00020086818757102044, 100.00000000000000, 10000.000000000000 },
};

// Test function for nu=100.00000000000000.
template<typename Tp>
  void
  test011()
  {
    bool test [[gnu::unused]] = true;
    const Tp eps = std::numeric_limits<Tp>::epsilon();
    Tp max_abs_diff = -Tp(1);
    Tp max_abs_frac = -Tp(1);
    unsigned int num_datum = sizeof(data011)
			   / sizeof(testcase_cyl_neumann_asymp<double>);
    for (unsigned int i = 0; i < num_datum; ++i)
      {
	const Tp f = std::cyl_neumann_asymp(Tp(data011[i].nu), Tp(data011[i].x));
	const Tp f0 = data011[i].f0;
	const Tp diff = f - f0;
	if (std::abs(diff) > max_abs_diff)
	  max_abs_diff = std::abs(diff);
	if (std::abs(f0) > Tp(10) * eps
	 && std::abs(f) > Tp(10) * eps)
	  {
	    const Tp frac = diff / f0;
	    if (std::abs(frac) > max_abs_frac)
	      max_abs_frac = std::abs(frac);
	  }
      }
    VERIFY(max_abs_frac < Tp(0.050000000000000003));
  }

int
main()
{
  test001<double>();
  test002<double>();
  test003<double>();
  test004<double>();
  test005<double>();
  test006<double>();
  test007<double>();
  test008<double>();
  test009<double>();
  test010<double>();
  test011<double>();
  return 0;
}
