#ifndef TESTCASE_TCC
#define TESTCASE_TCC 1

#include <sstream>

const std::string boilerplate = 
R"(// { dg-options "-D__STDCPP_WANT_MATH_SPEC_FUNCS__" }
//
// Copyright (C) 2016 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING3.  If not see
// <http://www.gnu.org/licenses/>.
)";

const std::string header = 
R"(//  Compare against values generated by the GNU Scientific Library.
//  The GSL can be found on the web: http://www.gnu.org/software/gsl/
#include <limits>
#include <cmath>
#if defined(__TEST_DEBUG)
#  include <iostream>
#  define VERIFY(A) \
  if (!(A)) \
    { \
      std::cout << "line " << __LINE__ \
	<< "  max_abs_frac = " << max_abs_frac \
	<< std::endl; \
    }
#else
#  include <testsuite_hooks.h>
#endif
#include <specfun_testcase.h>
)";

const std::string riemann_limits = 
R"(// This can take long on simulators, timing out the test.
// { dg-options "-DMAX_ITERATIONS=5" { target simulator } }

#ifndef MAX_ITERATIONS
#define MAX_ITERATIONS (sizeof(data001) / sizeof(testcase_riemann_zeta<double>))
#endif
)";


template<typename Tp>
  struct type_strings
  {
    static const std::string
    type()
    { return std::string(""); }

    static const std::string
    suffix()
    { return std::string(""); }
  };

template<>
  struct type_strings<float>
  {
    static const std::string
    type()
    { return std::string("float"); }

    static const std::string
    suffix()
    { return std::string("F"); }
  };

template<>
  struct type_strings<double>
  {
    static const std::string
    type()
    { return std::string("double"); }

    static const std::string
    suffix()
    { return std::string(""); }
  };

template<>
  struct type_strings<long double>
  {
    static const std::string
    type()
    { return std::string("long double"); }

    static const std::string
    suffix()
    { return std::string("L"); }
  };

template<>
  struct type_strings<__float128>
  {
    static const std::string
    type()
    { return std::string("__float128"); }

    static const std::string
    suffix()
    { return std::string("Q"); }
  };

template<>
  template<typename Tp>
    struct type_strings<std::complex<Tp>>
    {
      static const std::string
      type()
      {
	std::ostringstream tp;
	tp << "std::complex<" << type_strings<Tp>::type() << ">";
	return std::string(tp.str());
      }
      static const std::string
      suffix()
      { return std::string(""); }
    };



///
///  @brief  Fill an array with evenly spaces values between two limits.
///
template<typename Tp>
  std::vector<Tp>
  fill_argument(const std::pair<Tp,Tp> & range,
		const std::pair<bool,bool> & inclusive,
		const unsigned int num_steps = 101)
  {
    std::vector<Tp> argument;

    for (unsigned int i = 0; i < num_steps; ++i)
      {
	if (i == 0 && ! inclusive.first)
	  continue;
	if (i == num_steps - 1 && ! inclusive.second)
	  continue;

	Tp x = range.first + i * (range.second - range.first) / (num_steps - 1);
	if (range.first <= range.second)
	  {
	    if (x < range.first)
	      x = range.first;
	    else if (x > range.second)
	      x = range.second;
	  }
	else
	  {
	    if (x > range.first)
	      x = range.first;
	    else if (x < range.second)
	      x = range.second;
	  }

	argument.push_back(x);
      }

    return argument;
  }


///
///  @brief  Find a nice round number limit.
///
template<typename Tp>
  Tp
  get_tolerance(const Tp delta, const Tp min_tol, bool & ok)
  {
    const Tp abs_delta = std::abs(delta);
    //  Make this some number larger because you lose some accuracy writing and reading.
    const Tp eps = Tp{10} * std::numeric_limits<Tp>::epsilon();
    Tp tol = min_tol;
    while (tol > std::abs(delta)
	&& tol > eps)
      {
	if (Tp(0.5L) * tol > abs_delta
	 && Tp(0.5L) * tol > eps)
	  {
	    if (Tp(0.2L) * tol > abs_delta
	     && Tp(0.2L) * tol > eps)
	      {
		if (Tp(0.1L) * tol > abs_delta
		 && Tp(0.1L) * tol > eps)
		  {
		    tol *= Tp(0.1L);
		  }
		else
		  {
		    tol *= Tp(0.2L);
		    break;
		  }
	      }
	    else
	      {
		tol *= Tp(0.5L);
		break;
	      }
	  }
	else
	  break;
      }
    ok = true;
    if (tol < min_tol && tol <= abs_delta)
      {
	ok = false;
	std::cerr << "**** Error in get_tolerance:"
		  << " abs(delta)=" << abs_delta
		  << " tol=" << tol
		  << '\n';
      }
    if (tol == min_tol && tol < abs_delta)
      {
	ok = false;
	std::cerr << "Note in get_tolerance:"
		  << " delta=" << delta
		  << " tol=" << tol
		  << '\n';
      }

    //  Somehow, we seem to need extra space to get the tests to pass.
    //  TODO: Figure this out.
    return Tp(50.0L) * tol;
  }


///
///  @brief  Difference two one-argument functions.
///
template<typename Tp, typename Tp1>
  unsigned int
  maketest(Tp function1(Tp1),
	   Tp function2(Tp1),
	   const std::string & nsname,
	   const std::string & funcname,
	   const std::string & arg1, const std::vector<Tp1> & argument1,
	   std::ostream & output,
	   bool write_header = true, bool write_main = true, unsigned int test = 1)
  {
    const int old_prec = output.precision(std::numeric_limits<Tp>::max_digits10);
    output.flags(std::ios::showpoint);

    bool riemann_zeta_limits = (funcname == "riemann_zeta");

    if (write_header)
      output << boilerplate << '\n';
    output << "//  " << funcname << '\n' << '\n';
    if (riemann_zeta_limits)
      output << riemann_limits << '\n';
    if (write_header)
      output << header;

    const Tp eps = std::numeric_limits<Tp>::epsilon();

    std::string numname = type_strings<Tp>::type();

    std::string structname = "testcase_";
    structname += funcname;
    structname += '<' + numname + '>';

    std::vector<std::tuple<Tp, Tp1>> crud;

    Tp max_abs_diff = -Tp(1);
    Tp max_abs_frac = -Tp(1);
    for (unsigned int i = 0; i < argument1.size(); ++i)
      {
	const Tp1 x = argument1[i];

	try
	  {
	    const Tp f1 = function1(x);
	    const Tp f2 = function2(x);
	    const Tp diff = f1 - f2;
	    if (std::abs(diff) > max_abs_diff)
	      max_abs_diff = std::abs(diff);
	    if (std::abs(f2) > Tp(10) * eps && std::abs(f1) > Tp(10) * eps)
	      {
		const Tp frac = diff / f2;
		if (std::abs(frac) > max_abs_frac)
		  max_abs_frac = std::abs(frac);
	      }
	    crud.push_back(std::tuple<Tp, Tp1>(f2, x));
	  }
	catch (...)
	  {
	    continue;
	  }
      }

    if (max_abs_diff >= Tp(0) && max_abs_frac >= Tp(0))
      {
	bool tol_ok = false;
	const Tp min_tol = Tp(1.0e-3L);
	//const Tp diff_toler = get_tolerance(max_abs_diff, min_tol, tol_ok);
	const Tp frac_toler = get_tolerance(max_abs_frac, min_tol, tol_ok);
	std::ostringstream dataname;
	dataname.fill('0');
	dataname << "data" << std::setw(3) << test;
	dataname.fill(' ');
	output << '\n';
	output << "// Test data.\n";
	output << "// max(|f - f_GSL|): " << max_abs_diff << "\n";
	output << "// max(|f - f_GSL| / |f_GSL|): " << max_abs_frac << "\n";
	output.fill('0');
	output << "const " << structname << '\n' << dataname.str() << '[' << crud.size() << "] =\n{\n";
	output.fill(' ');
	for (unsigned int i = 0; i < crud.size(); ++i)
	  {
	    output << "  { " << std::get<0>(crud[i]) << type_strings<Tp>::suffix();
	    output << ", " << std::get<1>(crud[i]) << type_strings<Tp>::suffix();
	    output << " },\n";
	  }
	output << "};\n";
	output.fill('0');
	output << "const " << numname << " toler" << std::setw(3) << test << " = " << frac_toler << ";\n";
	output.fill(' ');
	++test;
      }

    if (write_main)
      {
	std::string structname = "testcase_";
	structname += funcname;
	structname += "<Tp>";

	output << '\n';
	output << "template<typename Tp, unsigned int Num>\n";
	output.fill('0');
	output << "  void\n";
	output << "  test(const " << structname << " (&data)[Num], Tp toler)\n";
	output.fill(' ');
	output << "  {\n";
	output << "    bool test __attribute__((unused)) = true;\n";
	output << "    const Tp eps = std::numeric_limits<Tp>::epsilon();\n";
	output << "    Tp max_abs_diff = -Tp(1);\n";
	output << "    Tp max_abs_frac = -Tp(1);\n";
	if (riemann_zeta_limits)
	  output << "    unsigned int num_datum = MAX_ITERATIONS;\n";
	else
	  output << "    unsigned int num_datum = Num;\n";
	output << "    for (unsigned int i = 0; i < num_datum; ++i)\n";
	output << "      {\n";
	output << "\tconst Tp f = " << nsname << "::" << funcname << "(data[i]." << arg1 << ");\n";
	output << "\tconst Tp f0 = data[i].f0;\n";
	output << "\tconst Tp diff = f - f0;\n";
	output << "\tif (std::abs(diff) > max_abs_diff)\n";
	output << "\t  max_abs_diff = std::abs(diff);\n";
	output << "\tif (std::abs(f0) > Tp(10) * eps\n";
	output << "\t && std::abs(f) > Tp(10) * eps)\n";
	output << "\t  {\n";
	output << "\t    const Tp frac = diff / f0;\n";
	output << "\t    if (std::abs(frac) > max_abs_frac)\n";
	output << "\t      max_abs_frac = std::abs(frac);\n";
	output << "\t  }\n";
	output << "      }\n";
	output << "    VERIFY(max_abs_frac < toler);\n";
	output << "  }\n";

	output << '\n';
	output << "int\n";
	output << "main()\n";
	output << "{\n";
	output.fill('0');
	for (unsigned int t = 1; t < test; ++t)
	  output << "  test(data" << std::setw(3) << t << ", toler" << std::setw(3) << t << ");\n";
	output.fill(' ');
	output << "  return 0;\n";
	output << "}\n";
      }

    return test;
  }


///
///  @brief  Difference two two-argument functions.
///
template<typename Tp, typename Tp1, typename Tp2>
  unsigned int
  maketest(Tp function1(Tp1,Tp2),
	   Tp function2(Tp1,Tp2),
	   const std::string & nsname,
	   const std::string & funcname,
	   const std::string & arg1, const std::vector<Tp1> & argument1,
	   const std::string & arg2, const std::vector<Tp2> & argument2,
	   std::ostream & output,
	   bool write_header = true, bool write_main = true, unsigned int test = 1)
  {
    const int old_prec = output.precision(std::numeric_limits<Tp>::max_digits10);
    output.flags(std::ios::showpoint);

    if (write_header)
      output << boilerplate << '\n';
    output << "//  " << funcname << '\n';
    if (write_header)
      output << header << '\n';

    const Tp eps = std::numeric_limits<Tp>::epsilon();

    std::string numname = type_strings<Tp>::type();

    std::string structname = "testcase_";
    structname += funcname;
    structname += '<' + numname + '>';

    for (unsigned int i = 0; i < argument1.size(); ++i)
      {
	const Tp1 x = argument1[i];

	std::vector<std::tuple<Tp, Tp1, Tp2>> crud;

	Tp max_abs_diff = -Tp(1);
	Tp max_abs_frac = -Tp(1);
	for (unsigned int j = 0; j < argument2.size(); ++j)
	  {
	    const Tp2 y = argument2[j];

	    try
	      {
		const Tp f1 = function1(x, y);
		const Tp f2 = function2(x, y);
		const Tp diff = f1 - f2;
		if (std::abs(diff) > max_abs_diff)
		  max_abs_diff = std::abs(diff);
		if (std::abs(f2) > Tp(10) * eps && std::abs(f1) > Tp(10) * eps)
		  {
		    const Tp frac = diff / f2;
		    if (std::abs(frac) > max_abs_frac)
		      max_abs_frac = std::abs(frac);
		  }
		crud.push_back(std::tuple<Tp, Tp1, Tp2>(f2, x, y));
	      }
	    catch (...)
	      {
		continue;
	      }
	  }

	if (max_abs_diff >= Tp(0) && max_abs_frac >= Tp(0))
	  {
	    bool tol_ok = false;
	    const Tp min_tol = Tp(1.0e-3L);
	    //const Tp diff_toler = get_tolerance(max_abs_diff, min_tol, tol_ok);
	    const Tp frac_toler = get_tolerance(max_abs_frac, min_tol, tol_ok);
	    std::ostringstream dataname;
	    dataname.fill('0');
	    dataname << "data" << std::setw(3) << test;
	    dataname.fill(' ');
	    output << '\n';
	    output << "// Test data for " << arg1 << '=' << std::get<1>(crud[0]) << ".\n";
	    output << "// max(|f - f_GSL|): " << max_abs_diff << "\n";
	    output << "// max(|f - f_GSL| / |f_GSL|): " << max_abs_frac << "\n";
	    output.fill('0');
	    output << "const " << structname << '\n' << dataname.str() << '[' << crud.size() << "] =\n{\n";
	    output.fill(' ');
	    for (unsigned int j = 0; j < crud.size(); ++j)
	      {
		output << "  { " << std::get<0>(crud[j]) << type_strings<Tp>::suffix();
		output << ", " << std::get<1>(crud[j]) << type_strings<Tp>::suffix();
		output << ", " << std::get<2>(crud[j]) << type_strings<Tp>::suffix();
		output << " },\n";
	      }
	    output << "};\n";
	    output.fill('0');
	    output << "const " << numname << " toler" << std::setw(3) << test << " = " << frac_toler << ";\n";
	    output.fill(' ');
	    ++test;
	  }
      }

    if (write_main)
      {
	std::string structname = "testcase_";
	structname += funcname;
	structname += "<Tp>";

	output << '\n';
	output << "template<typename Tp, unsigned int Num>\n";
	output.fill('0');
	output << "  void\n";
	output << "  test(const " << structname << " (&data)[Num], Tp toler)\n";
	output.fill(' ');
	output << "  {\n";
	output << "    bool test __attribute__((unused)) = true;\n";
	output << "    const Tp eps = std::numeric_limits<Tp>::epsilon();\n";
	output << "    Tp max_abs_diff = -Tp(1);\n";
	output << "    Tp max_abs_frac = -Tp(1);\n";
	output << "    unsigned int num_datum = Num;\n";
	output << "    for (unsigned int i = 0; i < num_datum; ++i)\n";
	output << "      {\n";
	output << "\tconst Tp f = " << nsname << "::" << funcname << '('
	       << "data[i]." << arg1 << ", data[i]." << arg2 << ");\n";
	output << "\tconst Tp f0 = data[i].f0;\n";
	output << "\tconst Tp diff = f - f0;\n";
	output << "\tif (std::abs(diff) > max_abs_diff)\n";
	output << "\t  max_abs_diff = std::abs(diff);\n";
	output << "\tif (std::abs(f0) > Tp(10) * eps\n";
	output << "\t && std::abs(f) > Tp(10) * eps)\n";
	output << "\t  {\n";
	output << "\t    const Tp frac = diff / f0;\n";
	output << "\t    if (std::abs(frac) > max_abs_frac)\n";
	output << "\t      max_abs_frac = std::abs(frac);\n";
	output << "\t  }\n";
	output << "      }\n";
	output << "    VERIFY(max_abs_frac < toler);\n";
	output << "  }\n";
	output << '\n';

	output << "int\n";
	output << "main()\n";
	output << "{\n";
	output.fill('0');
	for (unsigned int t = 1; t < test; ++t)
	  output << "  test(data" << std::setw(3) << t << ", toler" << std::setw(3) << t << ");\n";
	output.fill(' ');
	output << "  return 0;\n";
	output << "}\n";
      }

    return test;
  }


///
///  @brief  Difference two three-argument functions.
///
template<typename Tp, typename Tp1, typename Tp2, typename Tp3>
  unsigned int
  maketest(Tp function1(Tp1,Tp2,Tp3),
	   Tp function2(Tp1,Tp2,Tp3),
	   const std::string & nsname,
	   const std::string & funcname,
	   const std::string & arg1, const std::vector<Tp1> & argument1,
	   const std::string & arg2, const std::vector<Tp2> & argument2,
	   const std::string & arg3, const std::vector<Tp3> & argument3,
	   std::ostream & output,
	   bool write_header = true, bool write_main = true, unsigned int test = 1)
  {
    const int old_prec = output.precision(std::numeric_limits<Tp>::max_digits10);
    output.flags(std::ios::showpoint);

    if (write_header)
      output << boilerplate << '\n';
    output << "//  " << funcname << '\n';
    if (write_header)
      output << header << '\n';

    const Tp eps = std::numeric_limits<Tp>::epsilon();

    std::string numname = type_strings<Tp>::type();

    std::string structname = "testcase_";
    structname += funcname;
    structname += '<' + numname + '>';

    for (unsigned int i = 0; i < argument1.size(); ++i)
      {
	const Tp1 x = argument1[i];

	for (unsigned int j = 0; j < argument2.size(); ++j)
	  {
	    const Tp2 y = argument2[j];

	    std::vector< std::tuple<Tp, Tp1, Tp2, Tp3> > crud;

	    Tp max_abs_diff = -Tp(1);
	    Tp max_abs_frac = -Tp(1);
	    for (unsigned int k = 0; k < argument3.size(); ++k)
	      {
		const Tp3 z = argument3[k];

		try
		  {
		    const Tp f1 = function1(x, y, z);
		    const Tp f2 = function2(x, y, z);
		    const Tp diff = f1 - f2;
		    if (std::abs(diff) > max_abs_diff)
		      max_abs_diff = std::abs(diff);
		    if (std::abs(f2) > Tp(10) * eps && std::abs(f1) > Tp(10) * eps)
		      {
			const Tp frac = diff / f2;
			if (std::abs(frac) > max_abs_frac)
			  max_abs_frac = std::abs(frac);
		      }
		    crud.push_back(std::tuple<Tp, Tp1, Tp2, Tp3>(f2, x, y, z));
		  }
		catch (...)
		  {
		    continue;
		  }
	      }

	    if (max_abs_diff >= Tp(0) && max_abs_frac >= Tp(0))
	      {
		bool tol_ok = false;
		const Tp min_tol = Tp(1.0e-3L);
		//const Tp diff_toler = get_tolerance(max_abs_diff, min_tol, tol_ok);
		const Tp frac_toler = get_tolerance(max_abs_frac, min_tol, tol_ok);
		std::ostringstream dataname;
		dataname.fill('0');
		dataname << "data" << std::setw(3) << test;
		dataname.fill(' ');
		output << '\n';
		output << "// Test data for " << arg1 << '=' << std::get<1>(crud[0]);
		output << ", " << arg2 << '=' << std::get<2>(crud[0]) << ".\n";
		output << "// max(|f - f_GSL|): " << max_abs_diff << "\n";
		output << "// max(|f - f_GSL| / |f_GSL|): " << max_abs_frac << "\n";
		output.fill('0');
		output << "const " << structname << '\n' << dataname.str() << '[' << crud.size() << "] =\n{\n";
		output.fill(' ');
		for (unsigned int k = 0; k < crud.size(); ++k)
		  {
		    output << "  { " << std::get<0>(crud[k]) << type_strings<Tp>::suffix();
		    output << ", " << std::get<1>(crud[k]) << type_strings<Tp>::suffix();
		    output << ", " << std::get<2>(crud[k]) << type_strings<Tp>::suffix();
		    output << ", \n";
		    output << "\t  " << std::get<3>(crud[k]) << type_strings<Tp>::suffix();
		    output << " },\n";
		  }
		output << "};\n";
		output.fill('0');
		output << "const " << numname << " toler" << std::setw(3) << test << " = " << frac_toler << ";\n";
		output.fill(' ');
		++test;
	      }
	  }
      }


    if (write_main)
      {
	std::string structname = "testcase_";
	structname += funcname;
	structname += "<Tp>";

	output << '\n';
	output << "template<typename Tp, unsigned int Num>\n";
	output.fill('0');
	output << "  void\n";
	output << "  test(const " << structname << " (&data)[Num], Tp toler)\n";
	output.fill(' ');
	output << "  {\n";
	output << "    bool test __attribute__((unused)) = true;\n";
	output << "    const Tp eps = std::numeric_limits<Tp>::epsilon();\n";
	output << "    Tp max_abs_diff = -Tp(1);\n";
	output << "    Tp max_abs_frac = -Tp(1);\n";
	output << "    unsigned int num_datum = Num;\n";
	output << "    for (unsigned int i = 0; i < num_datum; ++i)\n";
	output << "  	 {\n";
	output << "\tconst Tp f = " << nsname << "::" << funcname << '('
	       << "data[i]." << arg1 << ", data[i]." << arg2 << ",\n";
	output << "\t\t     data[i]." << arg3 << ");\n";
	output << "\tconst Tp f0 = data[i].f0;\n";
	output << "\tconst Tp diff = f - f0;\n";
	output << "\tif (std::abs(diff) > max_abs_diff)\n";
	output << "\t  max_abs_diff = std::abs(diff);\n";
	output << "\tif (std::abs(f0) > Tp(10) * eps\n";
	output << "\t && std::abs(f) > Tp(10) * eps)\n";
	output << "\t  {\n";
	output << "\t    const Tp frac = diff / f0;\n";
	output << "\t    if (std::abs(frac) > max_abs_frac)\n";
	output << "\t      max_abs_frac = std::abs(frac);\n";
	output << "\t  }\n";
	output << "      }\n";
	output << "    VERIFY(max_abs_frac < toler);\n";
	output << "  }\n";

	output << '\n';
	output << "int\n";
	output << "main()\n";
	output << "{\n";
	output.fill('0');
	for (unsigned int t = 1; t < test; ++t)
	  output << "  test(data" << std::setw(3) << t << ", toler" << std::setw(3) << t << ");\n";
	output.fill(' ');
	output << "  return 0;\n";
	output << "}\n";
      }

    return test;
  }


///
///  @brief  Difference two four-argument functions.
///
template<typename Tp, typename Tp1, typename Tp2, typename Tp3, typename Tp4>
  unsigned int
  maketest(Tp function1(Tp1,Tp2,Tp3,Tp4),
	   Tp function2(Tp1,Tp2,Tp3,Tp4),
	   const std::string & nsname,
	   const std::string & funcname,
	   const std::string & arg1, const std::vector<Tp1> & argument1,
	   const std::string & arg2, const std::vector<Tp2> & argument2,
	   const std::string & arg3, const std::vector<Tp3> & argument3,
	   const std::string & arg4, const std::vector<Tp4> & argument4,
	   std::ostream & output,
	   bool write_header = true, bool write_main = true, unsigned int test = 1)
  {
    const int old_prec = output.precision(std::numeric_limits<Tp>::max_digits10);
    output.flags(std::ios::showpoint);

    if (write_header)
      output << boilerplate << '\n';
    output << "//  " << funcname << '\n';
    if (write_header)
      output << header << '\n';

    const Tp eps = std::numeric_limits<Tp>::epsilon();

    std::string numname = type_strings<Tp>::type();

    std::string structname = "testcase_";
    structname += funcname;
    structname += '<' + numname + '>';

    for (unsigned int i = 0; i < argument1.size(); ++i)
      {
	const Tp1 w = argument1[i];

	for (unsigned int j = 0; j < argument2.size(); ++j)
	  {
	    const Tp2 x = argument2[j];

	    for (unsigned int k = 0; k < argument3.size(); ++k)
	      {
		const Tp3 y = argument3[k];

		std::vector< std::tuple<Tp, Tp1, Tp2, Tp3, Tp4> > crud;

		Tp max_abs_diff = -Tp(1);
		Tp max_abs_frac = -Tp(1);
		for (unsigned int l = 0; l < argument4.size(); ++l)
		  {
		    const Tp4 z = argument4[l];

		    try
		      {
			const Tp f1 = function1(w, x, y, z);
			const Tp f2 = function2(w, x, y, z);
			const Tp diff = f1 - f2;
			if (std::abs(diff) > max_abs_diff)
			  max_abs_diff = std::abs(diff);
			if (std::abs(f2) > Tp(10) * eps && std::abs(f1) > Tp(10) * eps)
			  {
			    const Tp frac = diff / f2;
			    if (std::abs(frac) > max_abs_frac)
			      max_abs_frac = std::abs(frac);
			  }
			crud.push_back(std::tuple<Tp, Tp1, Tp2, Tp3, Tp4>(f2, w, x, y, z));
		      }
		    catch (...)
		      {
			continue;
		      }
		  }

		if (max_abs_diff >= Tp(0) && max_abs_frac >= Tp(0))
		 {
		    bool tol_ok = false;
		    const Tp min_tol = Tp(1.0e-3L);
		    //const Tp diff_toler = get_tolerance(max_abs_diff, min_tol, tol_ok);
		    const Tp frac_toler = get_tolerance(max_abs_frac, min_tol, tol_ok);
		    std::ostringstream dataname;
		    dataname.fill('0');
		    dataname << "data" << std::setw(3) << test;
		    dataname.fill(' ');
		    output << '\n';
		    output << "// Test data for " << arg1 << '=' << std::get<1>(crud[0]);
		    output << ", " << arg2 << '=' << std::get<2>(crud[0]);
		    output << ", " << arg3 << '=' << std::get<3>(crud[0]) << ".\n";
		    output << "// max(|f - f_GSL|): " << max_abs_diff << "\n";
		    output << "// max(|f - f_GSL| / |f_GSL|): " << max_abs_frac << "\n";
		    output.fill('0');
		    output << "const " << structname << '\n' << dataname.str() << '[' << crud.size() << "] =\n{\n";
		    output.fill(' ');
		    for (unsigned int l = 0; l < crud.size(); ++l)
		      {
			output << "  { " << std::get<0>(crud[l]) << type_strings<Tp>::suffix();
			output << ", " << std::get<1>(crud[l]) << type_strings<Tp>::suffix();
			output << ", " << std::get<2>(crud[l]) << type_strings<Tp>::suffix();
			output << ", \n";
			output << "\t  " << std::get<3>(crud[l]) << type_strings<Tp>::suffix();
			output << ", " << std::get<4>(crud[l]) << type_strings<Tp>::suffix();
			output << " },\n";
		      }
		    output << "};\n";
		    output.fill('0');
		    output << "const " << numname << " toler" << std::setw(3) << test << " = " << frac_toler << ";\n";
		    output.fill(' ');
		    ++test;
		  }
	      }
	  }
      }

    if (write_main)
      {
	std::string structname = "testcase_";
	structname += funcname;
	structname += "<Tp>";

	output << '\n';
	output << "template<typename Tp, unsigned int Num>\n";
	output.fill('0');
	output << "  void\n";
	output << "  test(const " << structname << " (&data)[Num], Tp toler)\n";
	output.fill(' ');
	output << "  {\n";
	output << "    bool test __attribute__((unused)) = true;\n";
	output << "    const Tp eps = std::numeric_limits<Tp>::epsilon();\n";
	output << "    Tp max_abs_diff = -Tp(1);\n";
	output << "    Tp max_abs_frac = -Tp(1);\n";
	output << "    unsigned int num_datum = Num;\n";
	output << "    for (unsigned int i = 0; i < num_datum; ++i)\n";
	output << "      {\n";
	output << "\tconst Tp f = " << nsname << "::" << funcname << '('
	       << "data[i]." << arg1 << ", data[i]." << arg2 << ",\n";
	output << "\t\t     data[i]." << arg3 << ", data[i]." << arg4 << ");\n";
	output << "\tconst Tp f0 = data[i].f0;\n";
	output << "\tconst Tp diff = f - f0;\n";
	output << "\tif (std::abs(diff) > max_abs_diff)\n";
	output << "  	 max_abs_diff = std::abs(diff);\n";
	output << "\tif (std::abs(f0) > Tp(10) * eps && std::abs(f) > Tp(10) * eps)\n";
	output << "\t  {\n";
	output << "\t    const Tp frac = diff / f0;\n";
	output << "\t    if (std::abs(frac) > max_abs_frac)\n";
	output << "\t      max_abs_frac = std::abs(frac);\n";
	output << "\t  }\n";
	output << "      }\n";
	output << "    VERIFY(max_abs_frac < toler);\n";
	output << "  }\n";

	output << '\n';
	output << "int\n";
	output << "main()\n";
	output << "{\n";
	output.fill('0');
	for (unsigned int t = 1; t < test; ++t)
	  output << "  test(data" << std::setw(3) << t << ", toler" << std::setw(3) << t << ");\n";
	output.fill(' ');
	output << "  return 0;\n";
	output << "}\n";
      }

    return test;
  }

#endif // TESTCASE_TCC

